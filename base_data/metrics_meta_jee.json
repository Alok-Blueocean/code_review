{"2238": {"text": "All JSP Pages should be referenced. An unreferenced Artifact is an Artifact that is not explicitly called from within the analyzed code.\nAvoid unreferenced JSP pages\nThis report lists all unreferenced JSP pages\nIt provides the following information: \n - Page name or client file name (html, js, css...)\nUnreferenced code may be the symptom of Dead Code. Dead Code must be avoided as it makes source code less readable and increases the cost of the software maintenance.\n\nWarning:\nUnreferenced code can also be the symptoms of missing code (code not included in the source code analysis) and / or can be the symptom of use of polymorphism.\nThe intensive use of polymorphism can make the application easier to change but much more difficult to test, debug and stabilize.\nCheck if the JSP Page is truly unnecessary. \nRemove JSP Pages that are not used.\nJSP pages", "urls": []}, "4554": {"text": "Number of Methods\nClasses should have less than X Methods.\nThe threshold is a parameter and can be changed at will.\nAvoid large Classes - too many Methods (JEE)\nThis report lists all the Classes having more than X Methods.\nIt provides the following information:\n - Class full name\n - Number of Methods\nA class contains an unnecessarily large number of methods. This issue makes it more difficult to understand and maintain the software, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\nReview the Class design to reduce the number of Methods\nNumber of methods", "urls": []}, "4556": {"text": "Number of Constructors\nClasses should have less than X Constructors.\nThe threshold is a parameter and can be changed at will.\nAvoid large Classes - too many Constructors (JEE)\nThis report lists all the Classes having more than X Constructors.\nIt provides the following information:\n - Class full name\n - Number of Constructors\nA class contains an unnecessarily large number of constructors. This issue makes it more difficult to understand and maintain the software, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\nReview the Class design to reduce the number of Constructors\nNumber of Java classes", "urls": []}, "4558": {"text": "Number of Fields\nClasses should have less than X Fields.\nThe threshold is a parameter that can be changed at will.\nAvoid large Classes - too many Fields\nThis report lists all the Classes having more than X Fields.\nIt provides the following information:\n - Class full name\n - Number of Fields\nMaintainability and readability is affected by the number of fields an object has though. 40 to 50 fields is quite a lot of fields, and it'is an indication that your classes do too much on their own, and have too many responsibilities. Refactoring them to many, smaller subclasses, and using composition would probably be a good idea.\nReview the Class design to reduce the number of Fields\nNumber of Java classes", "urls": []}, "4560": {"text": "Number of Methods\nInterfaces should have less than X Methods.\nThe threshold is a parameter and can be changed at will.\nAvoid large Interfaces - too many Methods (JEE)\nThis report lists all the Interfaces having more than X Methods.\nIt provides the following information:\n - Interface full name\n - Number of Methods\nAn Inteface contains an unnecessarily large number of methods. This issue makes it more difficult to understand and maintain the software, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.\nReview the Interface design to reduce the number of Methods\nNumber of interfaces", "urls": []}, "4592": {"text": "Number of violation occurrences\nHiding Static Methods is not allowed. This Rule retrieves all static methods that are redefined in subclasses i.e. \"implicitly hidden\". \n\nA Static Method MyMethod of Class MySuperClass is \"implicitly hidden\" in Subclass MySubClass if MySubClass contains a similar declaration of MyMethod (i.e. same signature).\n\nThe \"createUI\" method of the class derives from  \u201cjavax.swing.plaf.ComponentUI;\u201d is not considered by this rule.\nAvoid hiding static Methods\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nHiding is all about polymorphism. This means that the OO designer expects to override methods and use polymorphism so that code calling methods through a base class will end up executing different methods depending on the instance being used. This is not the case with static methods. When static methods are called, there is no polymorphism in play. It is always the static method of the type used to reference the object used that is called. Hiding static methods is a misuse of OO practices that results in misunderstanding of what is going to be executed at runtime and thus leads to unexpected behavior, jeopardizing the stability of the application.\n\nExcept for class derives from \u201cjavax.swing.plaf.ComponentUI\u201d\nSee documentation:\nhttps://docs.oracle.com/javase/7/docs/api/javax/swing/plaf/ComponentUI.html#createUI(javax.swing.JComponent)\n\npublic static ComponentUI (https://docs.oracle.com/javase/7/docs/api/javax/swing/plaf/ComponentUI.html) createUI(JComponent (https://docs.oracle.com/javase/7/docs/api/javax/swing/JComponent.html) c)\n\nReturns an instance of the UI delegate for the specified component. Each subclass must provide its own static createUI method that returns an instance of that UI delegate subclass. If the UI delegate subclass is stateless, it may return an instance that is shared by multiple components. If the UI delegate is stateful, then it should return a new instance per component. The default implementation of this method throws an error, as it should never be invoked.\nhttps://coderanch.com/wiki/659959/Overriding-Hiding\nhttps://coderanch.com/t/380069/java/overriding-static-method\nReview the design of the Method.\nSimply not override the static (class) methods.\nclass Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Foo\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Foo\");\n    }\n}\n \nclass Bar extends Foo {\n    //Simply not override the static (class) methods: classMethod.\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Bar\");\n    }\n}\n  \nclass Test {\n    public static void main(String[] args) {\n        Foo f = new Bar();\n        f.instanceMethod();\n        \n        //Rather than writing:\n        //f.classMethod();\n        \n        //It would be better coding style to write either:\n        Foo.classMethod();\n    }\n}\nclass Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Foo\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Foo\");\n    }\n}\n \nclass Bar extends Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Bar\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Bar\");\n    }\n}\n  \nclass Test {\n    public static void main(String[] args) {\n        Foo f = new Bar();\n        f.instanceMethod();\n        f.classMethod();\n    }\n}\n\n// If you run this, the output is\n// instanceMethod() in Bar\n// classMethod() in Foo\nNumber of methods.", "urls": ["https://docs.oracle.com/javase/7/docs/api/javax/swing/plaf/ComponentUI.html#createUI(javax.swing.JComponent)", "https://docs.oracle.com/javase/7/docs/api/javax/swing/plaf/ComponentUI.html", "https://docs.oracle.com/javase/7/docs/api/javax/swing/JComponent.html", "https://coderanch.com/wiki/659959/Overriding-Hiding", "https://coderanch.com/t/380069/java/overriding-static-method"]}, "4594": {"text": "Java artifacts should not use 'java.io.File' for application deployed on a Web Server or an Application Server to avoid any kind of dependencies with deployment environment of your application\n\nThis rule is computed only when web.xml or ejb-jar.xml file are present.\nAvoid using 'java.io.File'\nThis report lists all java artifacts using 'java.io.File'.\nIt provides the following information:\n Artifact full name\nFor portability reasons, in Web applications or Application Server, 'java.io.File' should not be used since it means giving an absolute path and therefore being dependent on the environment where the application is deployed.\n\nAlso, a program violates the Enterprise JavaBeans (EJB) specification by using the java.io package.\nhttps://cwe.mitre.org/data/definitions/576.html\n\nhttps://cwe.mitre.org/data/definitions/73.html\nPrefer using RessourceBundle.\nFile f = new File(request.getParameter(\"fileName\"))\n\n---------------\n\nFile f = new File(configPath + \"avatar.\" + request.getParameter(\"extension\") )\nNumber of Java objects", "urls": ["https://cwe.mitre.org/data/definitions/576.html", "https://cwe.mitre.org/data/definitions/73.html"]}, "4602": {"text": "Number of violation occurrences\nTo respect OO encapsulation concepts, Fields should not be accessed from outside the Class without going through their accessors.\nProtected fields are also considered by this rule computation. Use of protected fields is allowed by the Java language but not a good practice as it introduces a hard coupling between implementation and interfaces (abstract class here).\nAs per the book \"Effective Java\" by Joshua Bloch : \"The need for protected members should be relatively rare\".Fields of an INNER class are considered as internal fields of the outer class and Fields of a Child class (By inheritance) are considered as internal fields of the outer.\nAvoid using Fields (non static final) from other Classes\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nThe fundamental concept of this rule is encapsulation:\nHiding the internals of the object protects its integrity by preventing users from setting the internal data of the component into an invalid or inconsistent state. A benefit of encapsulation is that it can reduce system complexity, and thus increases robustness, by allowing the developer to limit the inter-dependencies between software components.\nImplement and use accessors ( getter/setter methods ) to access non-static-final fields from other classes.\n// com/test/A.java\n\npackage com.test;\n\nimport java.awt.Insets;\n\nclass B{\n    private String s;\n    public  static final Integer i = 10;\n\n    public String getS(){ return s; }\n    public void setS( String t ) { s = t; }\n}\n\npublic class A {\n    \n    void metdhodAccessedByField() {\n        B b = new B();\n        b.getS().concat(\"\"); // NOT A VIOLATION ANYMORE - USING GETTER TO GET THE FIELD\n    }\n    \n    void publicFieldOtherClass() {\n        B b = new B();\n        b.setS( \"\" ); // NOT VIOLATION ANYMORE - USING SETTER TO SET THE FIELD\n    }\n    \n    // ...\n}\n\n// ...\n// com/test/A.java\n\npackage com.test;\n\nimport java.awt.Insets;\n\nclass B{\n    public String s;\n    public static final Integer i = 10;\n}\n\npublic class A {\n    \n    void metdhodAccessedByField() {\n        B b = new B();\n        b.s.concat(\"\"); // VIOLATION - DIRECT FIELD ACCESS OF ANOTHER CLASS DURING METHOD CALL\n    }\n    \n    void publicFieldOtherClass() {\n        B b = new B();\n        b.s = \"\"; // VIOLATION - DIRECT FIELD ACCESS OF ANOTHER CLASS\n    }\n    \n    void staticFinalField() {\n        Integer x = B.i;  // NO VIOLATION - ACCESS OF STATIC FINAL FIELD\n    }\n}\n\nclass C {\n    public int a;\n    class D {\n        private float x;\n        class E {\n            void outerClassField () {\n                x=10.0f;    // NO VIOLATION - ACCESSING OUTER CLASS FIELD\n            }\n            \n            void recursiveOuterClassField () {\n                a=10;        // NO VIOLATION - ACCESSING OUTER CLASS FIELD\n            }\n        }\n    }\n}\n\nclass F{\n    static class G {\n        static char c = 'x';\n        static class H {\n            static boolean b;\n        }\n    }\n    \n    void innerClassField() {\n        G.c = 'c';  // NO VIOLATION - ACEESSING INNERCLASS FIELD\n    }\n    \n    void recursiveInnerClassField() {\n        G.H.b = true; // NO VIOLATION - ACCESSING INNERCLASS FIELD\n    }\n    \n}\n\nclass I {\n    double d;\n}\n\nclass J extends I {\n    void baseClassField() {\n        d = 20.0; // NO VIOLATION - ACCESSING BASE CLASS FIELD\n    }\n}\n\nclass K {\n    byte b;\n    void sameClassField() {\n        b=1;     // NO VIOLATION - ACCESSING SAME CLASS FIELD\n    }\n}\n\nclass L extends java.awt.Insets {\n\n    public L(int t, int l, int b, int r) {\n        super(t, l, b, r);\n    } \n    private static final long serialVersionUID = 1L;\n    \n    void randomMethod(int x) {}\n    \n    void externalBaseClassMethodArgField() {\n        randomMethod(top); // NO VIOLATION - METHOD ARG IS A FIELD FROM BASE CLASS\n    }\n    \n    int externalClassFieldReturn() {\n        return right;    // NO VIOLATION - RETURNING VALUE IS A FIELD FROM BASE CLASS\n        \n    }\n}\nNumber of non abstract Java artifacts", "urls": []}, "4730": {"text": "Package names must be in lowercase characters\nPackage naming convention - case control\nThis report lists all the Package names containing letters in uppercase.\nIt provides the following information:\n Package full name\nFor readability aspects, naming conventions must be respected. Coding naming conventions allow teams to collaborate efficiently.\nChange name according to the naming convention\nNumber of Java packages", "urls": []}, "4732": {"text": "Interface names must start with an uppercase character\nInterface naming convention - case control\nThis report lists all the Interfaces with the first letter in lower case.\nIt provides the following information:\n Interface full name\nFor readability aspects, naming conventions must be respected. Coding naming conventions allow teams to collaborate efficiently.\nChange name according to the naming convention\nNumber of Java interfaces", "urls": []}, "4734": {"text": "Names of Classes must start with an uppercase character\nClass naming convention - case control (JEE)\nThis report lists all the Classes with the first letter in lowercase.\nIt provides the following information:\n Class full name\nFor readability aspects, naming conventions must be respected. Coding naming conventions allow teams to collaborate efficiently.\nChange name according to the naming convention\nNumber of Java classes", "urls": []}, "4736": {"text": "Names of Methods must start with a lowercase character\nMethod naming convention - case control (JEE)\nThis report lists all the Methods with the first letter in uppercase.\nIt provides the following information:\n Method full name\nFor readability aspects, naming conventions must be respected. Coding naming conventions allow teams to collaborate efficiently.\nChange name according to the naming convention\nNumber of Java methods", "urls": []}, "4738": {"text": "Names of Constants should be in uppercase character. Java constants are static final fields.\nConstant naming convention - case control (JEE)\nThis report lists all the Constants with a lowercase letter.\nIt provides the following information:\n Constant full name\nFor readability aspects, naming conventions must be respected. Coding naming conventions allow teams to collaborate efficiently.\nhttp://java.sun.com/docs/codeconv/html/CodeConventions.doc8.html\nChange name according to the naming convention\nNumber of static final fields", "urls": ["http://java.sun.com/docs/codeconv/html/CodeConventions.doc8.html"]}, "4740": {"text": "Names of Fields should start with a lowercase character. Java fields convention naming here exclude Java constant that are static final Java fields and follow another naming convention rule.\nField naming convention - case control\nThis report lists all the Fields with the first letter in uppercase.\nIt provides the following information:\n Field full name\nFor readability aspects, naming conventions must be respected. Coding naming conventions allow teams to collaborate efficiently\nhttp://java.sun.com/docs/codeconv/html/CodeConventions.doc8.html\nChange name according to the naming convention\nNumber of Java fields except static final fields", "urls": ["http://java.sun.com/docs/codeconv/html/CodeConventions.doc8.html"]}, "7144": {"text": "Database object used\nFor all action class (and parent classes) that are referenced in the struts-config.xml through the tag 'action-mapping' (in struts 1.x) or in struts.xml and its included files through the tag 'action' (in struts 2.x), list artifacts that reference direct database access\nDEPRECATED : Avoid using  database objects from Struts Action Artifacts\nAction artifacts should not directly use database objects. All the database access code should be encapsulated behind the business API classes, so Struts doesn't know what persistent layer you are using. This lets you use the same business API classes in other environments, and also to run unit tests against your business API outside of Struts or a HTTP environment.\nUse a Business Delegate to perform any business specific operations.\nThis report lists all Action artifacts having access to the database.\nIt provides the following information:\n - Action artifact full name\n - database object used\nNumber of artifacts of classes and parent classes that are referenced as an action in the XML configuration file.", "urls": []}, "7146": {"text": "Java object name\nIn the context of Struts implementation, the JSP pages must reference ONLY Java objects that belong to the bean scope or Java objects of a class belonging itself to the same scope\n\nThe scope is an attribute of the bean indicating the context of objects usage.\nIn struts-config, the scope refers to where to create/find ActionForm objects.\n\nAll JSP pages that refers to Java methods, field of a class or the class itself that is not associated to a scoped attribute will be reported as violation.\nAlways have JSP pages referencing Java Objects associated to JEE Scoped Bean\nThis report lists all JSP pages referencing Java objects that are not associated to J2EE Scoped Bean.\nIt provides the following information:\n - Page name\n - Java object name\nIn a Struts implementation, JSP pages are responsible for the presentation and must not call specific Java objects other than those associated to scoped attributes.\n\nThe consequences of combining HTML and Java code in the same JSP file are:\n- no separation of technology: Java skilled people and Web designers/HTML coders must work on the same file.\n- less reusable: the Java component can't be reused elsewhere in the application\n- maintenance difficulties because of the lack of modularization\nhttp://www.javaworld.com/javaworld/jw-11-2001/jw-1130-jsp.html\nhttps://javapapers.com/jsp/explain-the-scope-of-jsp-objects/\nUse taglib or change the architecture of the application so that the JSP page only rely on classes associated to scoped attributes.\n<%@ taglib prefix=\"bean\" uri=\"/tags/struts-bean\" %> \n<%@ taglib prefix=\"html\" uri=\"/tags/struts-html\" %> \n<html:html>\n  <head>\n    <meta http-equiv=\"content-type\" content=\"text/html;charset=ISO-8859-1\">\n    <meta http-equiv=\"pragma\" content=\"no-cache\">\n    <meta http-equiv=\"cache-control\" content=\"no-cache\">\n    <meta http-equiv=\"description\" content=\"MAM\">\n    <title><bean:message bundle=\"application\" key=\"app.name\"/></title>\n  </head>\n  <body>\n<!-- Login et mot de passe -->\n\n<html:form action =\"init.do\" method =\"post\">\n\n  <table width=\"100%\" border=\"1\">\n  <tr>\n      <td align=\"center\">\n          <a>\n              <bean:message bundle=\"application\" key=\"app.login\"/>\n              <html:text property=\"login\"></html:text>    \n          </a>\n      </td>\n  </tr>\n  <tr>\n      <td align=\"center\">\n      <a>\n         <bean:message bundle=\"application\" key=\"app.password\"/>\n          <html:text property=\"password\"></html:text>    \n      </a>\n      </td>\n      </tr>\n      <tr align=\"middle\">\n          <td align=\"right\">\n              <html:submit>connexion</html:submit>\n          </td>\n    </tr>\n  </table>  \n</html:form>\n</body>\n</html:html>\n<%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"ISO-8859-1\"%>\n<%\nString path = request.getContextPath();\nString basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";\n%>\n\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html>\n  <head>\n    <base href=\"<%=basePath%>\">\n    \n    <title>My JSP 'error.jsp' starting page</title>\n    \n    <meta http-equiv=\"pragma\" content=\"no-cache\">\n    <meta http-equiv=\"cache-control\" content=\"no-cache\">\n    <meta http-equiv=\"expires\" content=\"0\">    \n    <meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\">\n    <meta http-equiv=\"description\" content=\"This is my page\">\n    <!--\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\n    -->\n\n  </head>\n  \n  <body>\n    ERROR!!!! <br>\n  </body>\n</html>\nNumber of JSP pages when any object of type \"Struts Configuration File\" is present", "urls": ["http://www.javaworld.com/javaworld/jw-11-2001/jw-1130-jsp.html", "https://javapapers.com/jsp/explain-the-scope-of-jsp-objects/"]}, "7150": {"text": "Full Name of createStatement method called\nThis rule will check the use of the method java.sql.Connection.createStatement()\nFavor PreparedStatement or CallableStatement over Statement\nThis report lists all methods that reference java.sql.Connection.Statement interface instances (or its sub-interface or sub-class).\nIt provides the following information: \n - Method Full Name\n - The Full Name of createStatement method that has been called\nThere are two benefits to use PreparedStatement or CallableStatement over Statement:\n- Performance: PreparedStatement gives better performance when compared to Statement because it is pre-parsed. CallableStatement is even more efficient but as it uses a stored procedure in the database, it is less portable,\n- Security: to prevent SQL Injection Attacks.\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\nUse java.sql.Connection.prepareStatement() or java.sql.Connection.prepareCall() instead.\nPreparedStatement stmt = connection.prepareStatement(\"SELECT * FROM users WHERE userid=? AND password=?\");\nstmt.setString(1, userid);\nstmt.setString(2, password);\nResultSet rs = stmt.executeQuery();\nString query = \"SELECT * FROM users WHERE userid ='\"+ userid + \"'\" + \" AND password='\" + password + \"'\";\nStatement stmt = connection.createStatement(); //violation\nResultSet rs = stmt.executeQuery(query);\nNumber of methods that call java.sql.Connection.createStatement() or java.sql.Connection.prepareStatement() or java.sql.Connection.prepareCall()", "urls": ["https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"]}, "7200": {"text": "All String objects that use concatenation in loops (for, while, do while) will be reported as violation.\n\n\nThese cases when executed in loop are taken into account: \n\n* result += string (literal or not) \n* result = result + string (literal or not) \n* result = result.concat(string: literal or not)\nAvoid String concatenation in loops\nString concatenation is not efficient because it creates a StringBuffer for each concatenation. When placed in a loop, String concatenation  results in the creation and garbage collection of large numbers of temporary objects. This both consumes memory and can dramatically slow the program execution. It is recommended to create a StringBuffer before entering the loop, and append to it within the loop, thus reducing the overhead.\nIt is recommended to create a StringBuilder (if JDK >= 1.5 and not in thread environment) or StringBuffer before entering the loop, and append to it within the loop, thus reducing the overhead.\n\nThe JVM is optimizing code such as \n\nSystem.out.println(\"x:\"+x+\" y:\"+y);\n\nby \n\nSystem.out.println((new StringBuilder()).append(\"x:\").append(x).append(\" y:\").append(y).toString());\nRemediation for Sample#1\n\nStringBuffer result = new StringBuffer(\"hello\");\nfor (int i = 0; i < 1500; i++) {\n   result.append(\"hello\");  // FIXED\n}\n\nRemediation for Sample#2\n\nStringBuffer sb = new StringBuffer(\"JDBC Connection parameters were : \\n\");\n        for (String prop: props.stringPropertyNames())\n        {\n            if (\"password\".equalsIgnoreCase(prop) || \"pwd\".equalsIgnoreCase(prop))\n                continue;\n            \n            sb.append(\"{\").append(prop).append(\" : \");  //Resolved\n        }\nThis report lists all methods that call String concatenation in loops.\nIt provides the following information:\n Method full name\nSample#1\n\nString result = \"hello\";\nfor (int i = 0; i < 1500; i++) {\n   result += \"hello\";  // VIOLATION\n}\n\nSample#2\n\nStringBuffer sb = new StringBuffer(\"JDBC Connection parameters were : \\n\");\n        for (String prop: props.stringPropertyNames())\n        {\n            if (\"password\".equalsIgnoreCase(prop) || \"pwd\".equalsIgnoreCase(prop))\n                continue;\n            \n            sb.append(\"{\"+prop + \" : \" +props.get(prop)+\"}\\n\");  //Violation\n        }\nNumber of non abstract Java artifacts", "urls": []}, "7202": {"text": "This rule checks the usage of == and != operators between two objects (not primitive types). If detected, a violation will be reported.\nAvoid using '==' and '!=' to compare objects\nIt is a source of great confusion to novice programmers that Java has two ways of thinking about the equality of objects. When used with object references, the == operator returns true only if both references are to the same object. The == operator is used to compare values of primitive types or object references, but it does not test for value or semantic equality. This is the same for the '!=' operator.\n\nTwo objects are considered equal if they have the same states (values)\nwhen you use the == operator with object types, what you\u2019re actually doing is testing whether the two variables have references that point to the same space in memory. Even if the objects referenced by the variables are identical in regards to their values, the results will still be false. This is somewhat unintuitive, and it can be a source of confusion\u2014and bugs\nPractical Java Programming Language Guide - ISBN 0-201-61646-7\nhttp://javatechniques.com/blog/string-equality-and-interning\nhttps://javarevisited.blogspot.com/2013/05/java-mistake-3-using-instead-of-equals.html\nhttps://stackify.com/equality-in-java-operators-methods-and-what-to-use-when/\nIn the case of semantic equality replace it with a call to equals method.\nThe method '.compareTo()' of Comparable interface can be also as remediation: \nComparable interface Compares values and returns an int which tells if the values compare less than, equal, or greater than.\nIf your class objects have a natural order, implement the Comparable<T> interface and define this method. All Java classes that have a natural ordering implement Comparable<T> - Example: String, wrapper classes, BigInteger\nInteger ia;\nInteger ib;\n\nif (ia.equals(ib)) {}  // FIXED\nif (!ia.equals(ib)) {} // FIXED\n\npublic static void sort(Comparable[] a){ \n    int n = a.length;\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j > 0; j--) {\n            if(a[j].compareTo(a[j-1]) < 0)  swap(a, j, j-1);\n            else                            break;\n        }\n    }\n}\nThis report lists all methods that use the == or != operators. It provides the following information:\n Method full name\nint i = 1;\nint j = 2;\nInteger ia;\nInteger ib;\n\nif (i == j) {}     // OK: i and j are primitive types\nif (ia == ib) {} // VIOLATION\nif (ia != ib) {}  // VIOLATION\nNumber of non abstract Java Methods and Constructors", "urls": ["http://javatechniques.com/blog/string-equality-and-interning", "https://javarevisited.blogspot.com/2013/05/java-mistake-3-using-instead-of-equals.html", "https://stackify.com/equality-in-java-operators-methods-and-what-to-use-when/"]}, "7210": {"text": "Reports all artifacts with loops (for, while, do while)  that contain object instantiations (object creation)..\nJava artifacts include all methods and constructors with the following exclusions:\n- the cases where the instantiation appear at the end of a return or throw statement are excluded. \n- the case where the instantiated object is one of the arguments of a call to one of the following methods :\n   . java.util.Collection.add\n   . java.util.Map.put\n   . java.lang.StringBuilder.append\n   . java.lang.StringBuilder.insert\n   . java.lang.StringBuilder.replace\n   . java.lang.StringBuffer.append\n   . java.lang.StringBuffer.insert\n   . java.lang.StringBuffer.replace\n   . java.util.stream.Stream.map\n   . and any method with the same name in their respective derived classes (e.g. java.util.ArrayList. add(int index, E element)), as ArrayList implements java.util.Collection and has the same name as the authorized method add).\nAvoid instantiations inside loops\nThis report lists all methods that create objects in a loop.\nIt provides the following information:\n Method full name\nOne of the fundamental OO performance management principles is to Avoid excessive object creation. This doesn't mean that you should give up the benefits of object-oriented programming by not creating any objects, but you should be wary of object creation inside of tight loops when executing performance-critical code. Object creation is expensive enough that you should avoid unnecessarily creating temporary or intermediate objects in situations where performance is an issue.\nRedesign the loop.\npublic class MyLoop {\n     public void printCount() {\n         StringBuffer sb = new StringBuffer(); // FIXED\n         for (int i = 0; i < 100; i++) {\n             sb.setLength(0);\n             sb.append(\"count = \");\n             sb.append(i);\n             System.out.println(sb);\n         }\n     }\n }\npublic class MyLoop {\n     public void printCount() {\n         for (int i = 0; i < 100; i++) {\n             StringBuffer sb = new StringBuffer(); // VIOLATION\n             sb.append(\"count = \");\n             sb.append(i);\n             System.out.println(sb);\n         }\n     }\n }\nNumber of non abstract Java Artifacts", "urls": []}, "7442": {"text": "Number of occurrences of keyword 'this'\nThis rule detects all cases where keyword 'this' is - directly or not - referenced in a constructor.\nIndirect reference to keyword 'this' means the definition of an inner class in the constructor. \nIt includes also the case where the constructor call the method start of a thread within a constructor (i.e. a method that inherits from java.lang.Thread.start())\nAvoid to use keyword 'this' within Constructor in multi-thread environment\nThis report lists all constructors that involve keyword 'this' directly or indirectly.\nIt provides the following information:\n  - Method full name\n  - the number of occurrences of keyword 'this' detected in the constructor\nWhen making a reference to keyword 'this' within a constructor - either directly or indirectly through inner classes - visible to another thread, the result can be unpredictable.\nMoreover, testing and debugging multi-threaded programs is very difficult, because of concurrency hazard that makes difficult to reproduce the issue.\nhttps://www.ibm.com/developerworks/java/library/j-jtp0618/index.html\nhttp://java.sun.com/docs/books/tutorial/essential/concurrency/syncmeth.html\nIn the cases where the reference to keyword 'this' is visible to other thread a redesign of the class must be made to avoid it.\npublic class Safe { \n\n  private Object me;\n  private Set set = new HashSet();\n  private Thread thread;\n\n  public Safe() { \n    // Safe because \"me\" is not visible from any other thread\n    me = this;\n\n    // Safe because \"set\" is not visible from any other thread\n    set.add(this);\n\n    // Safe because MyThread won't start until construction is complete\n    // and the constructor doesn't publish the reference\n    thread = new MyThread(this);\n  }\n\n  public void start() {\n    thread.start();\n  }\n\n  private class MyThread(Object o) {\n    private Object theObject;\n\n    public MyThread(Object o) { \n      this.theObject = o;\n    }\n\n    ...\n  }\n}\npublic class Unsafe {\n  public static Unsafe anInstance;\n  public static Set set = new HashSet();\n  private Set mySet = new HashSet();\n  private Thread thread;\n\n  public Unsafe() {\n    // Unsafe because anInstance is globally visible\n    anInstance = this;\n\n    // Unsafe because SomeOtherClass.anInstance is globally visible\n    SomeOtherClass.anInstance = this;\n\n    // Unsafe because SomeOtherClass might save the \"this\" reference\n    // where another thread could see it\n    SomeOtherClass.registerObject(this);\n\n    // Unsafe because set is globally visible \n    set.add(this);\n\n    // Unsafe because we are publishing a reference to mySet\n    mySet.add(this);\n    SomeOtherClass.someMethod(mySet);\n\n    // Unsafe because the \"this\" object will be visible from the new\n    // thread before the constructor completes\n    // in any case, start() must not be called within the constructor\n    thread = new MyThread(this);\n    thread.start();\n  }\n\n  public Unsafe(Collection c) {\n    // Unsafe because \"c\" may be visible from other threads\n    c.add(this);\n  }\n}\nNumber of constructors", "urls": ["https://www.ibm.com/developerworks/java/library/j-jtp0618/index.html", "http://java.sun.com/docs/books/tutorial/essential/concurrency/syncmeth.html"]}, "7446": {"text": "Number of violation occurrences\nDouble checked locking is a software design pattern used to reduce locking overhead when implementing lazy initialization in a multi-thread environment. This avoids initializing a value until the first time it is accessed.\nThis pattern is unsafe because there is no guarantee it will work on single or multi-processor machines.\n\nFor JSE 4.x and previous versions, all methods that are not synchronized and that use double checked locking will be reported.\nAvoid double checked locking for JSE 4.x and previous version\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nDouble-checked locking refers to the situation where a programmer checks to see if a resource has been initialized, grabs a lock, checks again to see if the resource has been initialized, and then performs the initialization if it has not occurred yet. This should not be done, as is not guaranteed to work in all languages and on all architectures. In summary, other threads may not be operating inside the synchronous block and are not guaranteed to see the operations execute in the same order as they would appear inside the synchronous block.\nhttps://cwe.mitre.org/data/definitions/609.html\nhttp://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html\nhttp://www.artima.com/designtechniques/threadsafety.html\nhttp://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#dcl\nTo remediate, there are three solutions depending on performance considerations:\n1/ synchronize the method: each call to this method will cost more but the initialization will be made when needed\n2/ use Initialize-On-Demand Holder Class idiom: the field will be initialized during the initialization of the class even if is not required, but each call to the method that returns this field will not.\n3/ make the field volatile - Java 5 and above\n1/ synchronized the method getUnsafeResource()\npublic class UserClass {\n    private UnsafeResource unsafeResource = null;\n\n    // make getUnsafeResource() synchronized\n    public synchronized UnsafeResource getUnsafeResource() {\n        if (unsafeResource == null)\n            unsafeResource = new UnsafeResource();\n        return unsafeResource;\n    }\n}\n\n2/ use Initialize-On-Demand Holder Class idiom\npublic class UserClass {\n// Use initialize-on-demand holder class idiom\n    private static class HolderClass {\n        public static UnsafeResource unsafeResource = new UnsafeResource();\n    }\n\n    public static UnsafeResource getUnsafeResource() {\n        return HolderClass.unsafeResource;\n    }\n}\n\n3/ make the field volatile\npublic class UserClass {\n    private volatile UnsafeResource unsafeResource = null; // field is volatile\n\n    public UnsafeResource getUnsafeResource() {\n        if (unsafeResource == null) { //Double checked locking used\n            synchronized (this) {\n                if (unsafeResource == null) {\n                    unsafeResource = new UnsafeResource();\n                }\n            }\n        }\n        return unsafeResource;\n    }\n}\npublic class UserClass {\n    private UnsafeResource unsafeResource = null;\n\n    public UnsafeResource getUnsafeResource() {\n        //Double checked locking used for unsafeResource\n        if (unsafeResource == null) {\n            synchronized (this) {\n                if (unsafeResource == null) {\n                    unsafeResource = new UnsafeResource();\n                }\n            }\n        }\n        return unsafeResource;\n    }\n}\nNumber of methods that are synchronized or use the synchronized keyword", "urls": ["https://cwe.mitre.org/data/definitions/609.html", "http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html", "http://www.artima.com/designtechniques/threadsafety.html", "http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#dcl"]}, "7504": {"text": "Reports all persistent classes that don't implement equals() or hashCode() directly (class that is referenced in the mapping file) or in an inherited class that holds persistent fields (this is the case when a persistent class makes persistent inherited fields).\nPersistent classes should Implement hashCode() and equals()\nList all Hibernate and JPA persistent classes that don't implement equals() or hashCode() directly or in an inherited class that holds persistent fields.\n\nIt provides the following information:\n- Class Full Name\nHibernate guarantees that there is a unique instance for each row of the database inside a Session. But whenever you work with objects in detached state, and especially if you test them for equality (usually in hash-based collections), you need to supply your own implementation of the equals() and hashCode() methods for your persistent classes. This is true for Hibernate standard usage but also when used through the JPA API.\n\nNevertheless, it's possible to build a complex application with identity (default) equals as long as you exercise discipline when dealing with detached objects from different sessions. If this concept of equality isn't what you want, you must override equals() in your persistent classes.\nhttp://docs.jboss.org/hibernate/core/3.3/reference/en/html/persistent-classes.html#persistent-classes-equalshashcode\nHibernate in Action (ISBN 1932394-15-X) p 219\nThe Java Persistence API page 395 - ISBN 1-932394-88-5\nhttp://www.ideyatech.com/2011/04/effective-java-equals-and-hashcode/\n\nhttps://projectlombok.org/features/EqualsAndHashCode\nCheck if you have instances from multiple sessions and implement equals() and hashCode() if it is the case. \nIf it is not the case, we recommend implementing it anyway to avoid issues during future evolutions.\nUse lombock annotation @EqualsAndHashCode;\nsee https://projectlombok.org/features/EqualsAndHashCode\n----> B.java\npublic class B {\n  private long id;\n  ...\n\n  private void setId(long id) { \n    this.id = id;\n  }\n\n   public long getId() {\n      return id;\n   }\n  ...\n\n  // FIXED\n   public boolean equals(Object obj) {\n    ...\n   }\n\n   // FIXED\n   public int hashCode() {\n     ...\n    }\n}\n\n// Use lombock annotation @EqualsAndHashCode;\n----> B.java\nimport lombok.EqualsAndHashCode;\n...\n\n// FIXED\n@EqualsAndHashCode\npublic class B {\n  private long id;\n  ...\n\n  private void setId(long id) { \n    this.id = id;\n  }\n\n   public long getId() {\n      return id;\n   }\n  ...\n}\n----> a.hbm.xml\n<hibernate-mapping >\n  \n  <class name=\"A\" table =\"A\"> \n    <id name=\"id\">\n      <generator class=\"increment\"/>\n    </id>\n\n    <set name=\"b_items\" lazy=\"true\" table =\"B\"> \n      <key column=\"B_ID\"/>\n      <one-to-many class=\"B\"/>\n    </array>\n  </class>\n\n  <class name=\"B\" table=\"B\" lazy=\"true\">\n    <id name=\"id\" column=\"B_ID\">\n      <generator class=\"increment\"/>\n    </id>\n  </class>\n\n</hibernate-mapping>\n\n----> B.java\npublic class B {\n private long id;\n ...\n\n private void setId(long id) { \n    this.id = id;\n }\n\n   public long getId() {\n      return id;\n   }\n  ...\n  // VIOLATION: equals and hashCode are not defined\n}\nNumber of persistent classes (through Hibernate or JPA)", "urls": ["http://docs.jboss.org/hibernate/core/3.3/reference/en/html/persistent-classes.html#persistent-classes-equalshashcode", "http://www.ideyatech.com/2011/04/effective-java-equals-and-hashcode/", "https://projectlombok.org/features/EqualsAndHashCode", "https://projectlombok.org/features/EqualsAndHashCode"]}, "7652": {"text": "Reports all methods that reference a constructor of an exception (a class that inherits from Throwable) in a catch block except where:\n- java.lang.Throwable is the type of one parameter in the signature of the constructor\n- a call to the method or a method that overrides java.lang.Throwable.initCause(Throwable cause) \n\nNote that this rule does not check that the caught exception is the exception that is passed as the argument of the new Exception constructor or the initCause method.\nAvoid throwing an exception in a catch block without chaining it\nThis report lists all methods that contain try/catch blocks where an exception (a class that inherits from Throwable) constructor has java.lang.Throwable as the type of one parameter in the signature of the constructor or a call to the method (or a method that overrides) java.lang.Throwable.initCause(Throwable cause). It provides the following information: Method full name\nThere are many cases where it is very useful to change an exception's class. But if you create a new exception using the original exception message (i.e. MyException(originalException.getMessage())) valuable information about the original exception will not be propagated.\n\nAs such, you may loss the original exception's class and stack trace. This lack of information will slow the investigation process when an issue occurs in validation or in production.\nhttp://www.developer.com/java/other/article.php/1431531/Chained-Exceptions-in-Java.htm\nUse Exception(String message, Throwable cause) or Exception(Throwable cause) signature to chain the exceptions. Exception chains contain information about the full call stack, thus allowing a change of type on the exception's way up the call stack without loss of stack information.\nprivate void init() throws InitException {\n  ...\n  } catch( FileNotFoundException ex) {\n      throw new InitException(\"File Not Found\", ex); // FIXED\n   }\n}\nprivate void init() throws InitException {\n  ...\n  } catch( FileNotFoundException ex) {\n       throw new InitException(ex.getMessage()); // VIOLATION\n   }\n}\nNumber of methods that throw an exception (a class that inherits from Throwable) using a constructor in a catch block", "urls": ["http://www.developer.com/java/other/article.php/1431531/Chained-Exceptions-in-Java.htm"]}, "7706": {"text": "Reports all entities or column defined through annotation or XML that define a table or column name length greater than 30. \nThe table and column name length are parameters that can be changed at will.\nAvoid table and column names that are too long (portability)\nThis report lists all entities or property defined through annotation or XML that define a table or column name length greater than 30.\nIt provides the following information:\nPersistent Entity name or Persistent Property name\nIf you specify table name too long you won't be able to create it on some database. This will prevent you to use these table name unless you use a Naming Strategy to reduce the length of the table name.\n\nTo ease portability, choose table name with a length accepted by the majority of database you want to support.\nChange the table name size or use a Naming Strategy to reduce the table name length.\n\nSome facts from http://www.mssqlcity.com/Articles/Compare\n\n                                table name length     column name length\nSQL Server 2000   128                            128\nASE 12.5                  30                              30\nMYSQL 4.1               64                              64\nDB2 8.1                  128                            128\nOracle 9i                  30                              30\n<class name=\"cast.core.InputFieldValueResource\" table=\"input_field_value_resource\">\n   ...\n</class>\n<class name=\"cast.core.InputFieldValueResource\" table=\"cast_core_input_field_value_resource\">\n   ...\n</class>\nNumber of persistent entities and properties", "urls": ["http://www.mssqlcity.com/Articles/Compare"]}, "7714": {"text": "Number of violation occurrences\nField injection is not recommended. This rule reports all Spring Bean that use autowire attribute.\nAvoid using auto-wiring\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nAuto-wiring can save you time in small applications, but in many cases, it leads to bad practices and is inflexible in large applications. Using byName seems like a good idea, but it may lead you to give your classes artificial property names so that you can take advantage of the auto-wiring functionality. The whole idea behind Spring is that you can create your classes how you like and have Spring work for you, not the other way around. You may be tempted to use byType until you realize\nthat you can only have one bean for each type in your BeanFactory -- a restriction that is problematic when you need to maintain beans with different configurations of the same type.\n\nAlso it will affect the performance of your application since auto-wiring is slow.\nhttps://blog.marcnuri.com/field-injection-is-not-recommended/\nhttps://howtodoinjava.com/best-practices/13-best-practices-for-writing-spring-configuration-files/\nhttps://www.vojtechruzicka.com/field-dependency-injection-considered-harmful/\nhttp://code.google.com/p/google-guice/wiki/SpringComparison\nhttps://www.baeldung.com/spring-annotations-resource-inject-autowire\nhttps://stackoverflow.com/questions/7142622/what-is-the-difference-between-inject-and-autowired-in-spring-framework-which\nDefine your wiring explicitly, and you benefit from explicit semantics and full flexibility on property naming and on how many instances of\nthe same type you manage.\n\nSpring team recommands to Always use constructor based on dependency injection in your bean and Always use assertions  for mandatory dependencies\n<beans>\n   <bean id=\"myBean\" class=\"com.cast.MyBean\"/> // FIXED\n...\n</beans>\n\n@Service\npublic class ModuleManagementService {\n\n    \n  private ModuleManagementManager moduleManagementManager;\n \n  //  Prefer setter injection over constructor injection\n  @Inject  // OR @Autowired\n  public void setInjectedBean() {\n      moduleManagementManager = new ModuleManagementManager();   // NO VIOLATION\n  }\n}\n<beans>\n   <bean id=\"myBean\" autowire=\"byName\" class=\"com.cast.MyBean\"/> // VIOLATION\n...\n</beans>\n\n\n\nimport org.springframework.stereotype.Component;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@Component\npublic class ModuleManagementManager {\n  private static final Logger LOGGER = LoggerFactory.getLogger(ModuleManagementManager.class);\n}\n\nimport org.springframework.stereotype.Service;\n\nimport javax.enterprise.inject.Instance;\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Qualifier;\nimport javax.inject.Scope;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@Service\npublic class ModuleManagementService {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(ModuleManagementService.class);\n  \n  // JSR-330 injection\n  @Inject\n  ModuleManagementManager moduleManagementManager = new ModuleManagementManager(); // VIOLATION\n}\nNumber of Java classes", "urls": ["https://blog.marcnuri.com/field-injection-is-not-recommended/", "https://howtodoinjava.com/best-practices/13-best-practices-for-writing-spring-configuration-files/", "https://www.vojtechruzicka.com/field-dependency-injection-considered-harmful/", "http://code.google.com/p/google-guice/wiki/SpringComparison", "https://www.baeldung.com/spring-annotations-resource-inject-autowire", "https://stackoverflow.com/questions/7142622/what-is-the-difference-between-inject-and-autowired-in-spring-framework-which"]}, "7730": {"text": "The Bean Provider can choose between using programmatic transaction demarcation in the enterprise bean code (this style is called bean-managed transaction demarcation)  or  declarative transaction demarcation performed automatically by the EJB container (this style is called container-managed transaction demarcation).\n\nWithout theses features, transactions must be controlled using explicit transaction demarcation which is less recommanded as it requires that the transactional code be written within the business logic, which reduces the clarity of the code and more importantly creates inflexible distributed objects\n\n\nThis rule reports violation when an explicit transaction demarcation is done in project using EJB BEANS and / or Message Driven Beans\n\nThis Quality Rule reports all methods that directly (or indirectly through inheritance) reference an object of the following type:\n* java.sql.Connection\n* javax.transaction.UserTransaction\n* javax.persistence.EntityTransaction\n* org.hibernate.Transaction\n* org.springframework.transaction.PlatformTransactionManager\n* org.springframework.transaction.support.TransactionTemplate\nThe Bean Provider can choose between using programmatic transaction demarcation in the enterprise bean code (this style is called bean-managed transaction demarcation)  or  declarative transaction demarcation performed automatically by the EJB container (this style is called container-managed transaction demarcation).\n\nWithout theses features, transactions must be controlled using explicit transaction demarcation which is less recommended as it requires that the transactional code be written within the business logic, which reduces the clarity of the code and more importantly creates inflexible distributed objects\n\n\nThis rule reports violation when an explicit transaction demarcation is done in project using EJB BEANS and/or Message Driven Beans\n\nThis Quality Rule reports all methods that directly (or indirectly through inheritance) reference an object of the following type:\n\n* java.sql.Connection\n* javax.transaction.UserTransaction\n* javax.persistence.EntityTransaction\n* org.hibernate.Transaction\n* org.springframework.transaction.PlatformTransactionManager\n* org.springframework.transaction.support.TransactionTemplate\nAlways use declarative transaction\nThis Quality Rule reports all methods that reference programmatic transactions. It provides the following information: Method or Constructor Full Name\nOne of the primary advantages of an Application Server is the support of declarative transactions. Without this feature, transactions must be controlled using explicit transaction demarcation. Explicit demarcation is difficult for developers to use at best, particularly if you are new to transactional systems. In addition, explicit transaction demarcation requires that the transactional code be written within the business logic, which reduces the clarity of the code and more importantly creates inflexible distributed objects. Once transaction demarcation is \"hardcoded\" into the business object, changes in transaction behaviour require changes to the business logic itself.\n\nDeclarative transactions make it easier for you to create robust transactional applications. The risk to not use them is data corruption.\nhttp://docstore.mik.ua/orelly/java-ent/ebeans/ch08_02.htm\nUsing transaction attributes simplifies the construction of transactional applications by reducing the risks associated with improper use of transactional protocols like JTA. It is more efficient and easier to use transaction attributes than to control transactions explicitly. This can be done through EJB or Spring.\nuse container-managed transaction demarcation (@Transactional Annotation or Configure Transactions with XML)\n@Stateless\npublic class UserServiceImpl {\n   UserDAO UserDAO;\n   @Resource SessionContext context;\n\n   @TransactionAttribute(TransactionAttributeType.REQUIRED)\n   public void update(User user) throws Exception {\n      try {\n     userDAO.update(user);\n      } catch (Exception up) {\n         context.setRollbackOnly();\n         throw up;\n      }\n   }\n}\n// programmatic transaction demarcation\n\n@Stateless\n@TransactionManagement(TransactionManagementType.BEAN)\npublic class UserServiceImpl {\n   UserDAO userDAO;\n\n   public void update(User user) throws Exception {\n      InitialContext context = new InitialContext();\n      //reference of javax.transaction.UserTransaction\n       UserTransaction transaction = (UserTransaction)context.lookup(\"UserTransaction\");\n      try {\n         //explicit transaction demarcation\n         transaction.begin();// starting the transaction : violation\n     .......\n         transaction.commit(); // committing: violation\n      } catch (Exception up) {\n         transaction.rollback();\n         throw up;\n      }\n   }\n}\nNumber of Java Methods and Constructors (including generic methods and generic constructors) if ejb-jar.xml, Spring XML or JPA XML files exists", "urls": ["http://docstore.mik.ua/orelly/java-ent/ebeans/ch08_02.htm"]}, "8104": {"text": "Number of violation occurrences\nReports methods that open a connection to database in the body and do not close it (The Method is in violation when it open a connection to database and does not close it).\nThe following methods are taken into account:\n- JDBC:\n   . open: java.sql.DriverManager.getConnection(String)\n   . close: java.sql.Connection.close()\n- JDBC:\n   . open: java.sql.Connection.createStatement()\n   . close: java.sql.Statement.close()\n- JDBC:\n   . open: java.sql.Connection.prepareStatement(...)\n   . close: java.sql.PreparedStatement.close()\n- JDBC:\n   . open: java.sql.Connection.prepareCall(...)\n   . close: java.sql.CallableStatement.close()\n- JDBC:\n   . open: java.sql.PreparedStatement.executeQuery()\n   . close: java.sql.ResultSet.close()\n- JPA:\n    . open: javax.persistence.Persistence.createEntityManagerFactory(String)\n    . close: javax.persistence.EntityManagerFactory.close()\n- JPA:\n   . open:  javax.persistence.EntityManagerFactory.createEntityManager()\n   . close:  javax.persistence.EntityManager.close()\n- Hibernate:\n   . open: org.hibernate.SessionFactory.openSession()\n   . close: org.hibernate.Session.close()\n- Hibernate:\n  . open: org.hibernate.cfg.Configuration.buildSessionFactory()\n  . close: org.hibernate.SessionFactory.close()\n- Spring:\n  . open: org.springframework.orm.hibernate3.SessionFactoryUtils.getSession(...)\n  . close: org.springframework.orm.hibernate3.SessionFactoryUtils.closeSession(...)\nAvoid missing release of SQL connection after an effective lifetime (JEE)\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nA frequent issue when dealing with database resource is resource leak. This mainly comes from an incorrect code that miss to close the connection in any cases. Incorrect resource management is a common source of failures in production applications, with the usual pitfalls being database connections and file descriptors remaining opened after an exception has occurred somewhere else in the code. This leads to application servers being frequently restarted when resource exhaustion occurs, because operating systems and server applications generally have an upper-bound limit for resources.\nhttps://wiki.sei.cmu.edu/confluence/display/java/FIO04-J.+Release+resources+when+they+are+no+longer+needed\nhttps://cwe.mitre.org/data/definitions/772.html\nYou can:\n- close the resource in a finally block (only explicit closing is considered valid)\n- or annotate this resource with @Cleanup annotation (lombok.Cleanup)\n- or use the try with resource to declare the resource that must be closed (available in java 7)\n- or use Spring JDBC Template that open and close the connection for you (http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/jdbc.html)\n- or use CDI with @Dispose annotation\nwith finally\n~~~~~~~~~~~~\nString connectionURL = 'jdbc:mysql://localhost:3306/myDB';\nConnection connection = null;\nStatement st = null;\nResultSet rs = null;\ntry {\n    Class.forName('com.mysql.jdbc.Driver').newInstance();\n    connection = DriverManager.getConnection(connectionURL, 'root', 'admin');\n    st = connection.createStatement();\n    rs = st.executeQuery('Select * from EMPLOYEE_SALARIES');\n    while (rs.next()) {\n        System.out.println('EMPLOYEE_NAME/EMPLOYEE_SALARY');\n        System.out.println(rs.getString(1) + '/' + rs.getString(2));\n    }\n} catch (Exception ex) {\n    ex.printStackTrace();\n} finally { // FIX\n    try {\n        if (rs != null && !rs.isClosed()) {\n            rs.close();\n        }\n        if (st != null && !st.isClosed()) {\n            st.close();\n        }\n        if (connection != null && !connection.isClosed()) {\n            connection.close();\n        }\n    } catch (SQLException ex) {\n        ex.printStackTrace();\n    }\n}\n\nwith Java 7\n~~~~~~~~~~~~~~\nString connectionURL = 'jdbc:mysql://localhost:3306/myDB';\ntry ( // FIX\n    Connection connection =\n        DriverManager.getConnection(connectionURL, 'root', 'admin');\n    Statement st = connection.createStatement();\n    ResultSet rs = st.executeQuery('Select * from EMPLOYEE_SALARIES');\n) {\n    Class.forName('com.mysql.jdbc.Driver').newInstance();\n    while (rs.next())\n    {\n        System.out.println('EMPLOYEE_NAME/EMPLOYEE_SALARY');\n        System.out.println(rs.getString(1) + '/' + rs.getString(2));\n    }\n}\n\nwith annotation @Cleanup\n~~~~~~~~~~~~~~~~~~~~~~~~\nString connectionURL = 'jdbc:mysql://localhost:3306/myDB';\n@Cleanup Connection connection = null; // FIX\n@Cleanup Statement st = null; // FIX\n@Cleanup ResultSet rs = null; // FIX\n\nClass.forName('com.mysql.jdbc.Driver').newInstance();\nconnection = DriverManager.getConnection(connectionURL, 'root', 'admin');\nst = connection.createStatement();\nrs = st.executeQuery('Select * from EMPLOYEE_SALARIES');\nwhile (rs.next()) {\n    System.out.println('EMPLOYEE_NAME/EMPLOYEE_SALARY');\n    System.out.println(rs.getString(1) + '/' + rs.getString(2));\n}\n\nwith CDI annotation\n~~~~~~~~~~~~~~~~~~~~\n@Produces @RequestScoped\nConnection connect(User) {\n   return createConnection(user.getId(), user.getPassword())\n}\n\nvoid close (@Disposes Connection connection) {\n   connection.close();\n}\nString connectionURL = 'jdbc:mysql://localhost:3306/myDB';\nConnection connection = null;\nStatement st = null;\nResultSet rs = null;\ntry {\n    Class.forName('com.mysql.jdbc.Driver').newInstance();\n    connection = DriverManager.getConnection(connectionURL, 'root', 'admin');\n    st = connection.createStatement();\n    rs = st.executeQuery('Select * from EMPLOYEE_SALARIES');\n    while (rs.next()) {\n        System.out.println('EMPLOYEE_NAME/EMPLOYEE_SALARY');\n        System.out.println(rs.getString(1) + '/' + rs.getString(2));\n    } \n    rs.close(); \n    st.close();\n    connection.close();\n} catch (Exception ex) {\n    ex.printStackTrace();\n}  // VIOLATION, rs, st and connection must be closed in a finally\nNumber of methods that open a database resource in the body", "urls": ["https://wiki.sei.cmu.edu/confluence/display/java/FIO04-J.+Release+resources+when+they+are+no+longer+needed", "https://cwe.mitre.org/data/definitions/772.html", "http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/jdbc.html"]}, "8214": {"text": "Number of violation occurrences\nIf a released resource is subsequently reused or reallocated, then an attempt to use the original resource might allow access to sensitive data that is associated with a different user or entity.\n\nThis rule reports all methods accessing the closed SQL connections or data streams which are not valid. The following methods are taken into account:\n  \n- JDBC:\n   . close: java.sql.Connection.close()\n   . close: java.sql.Statement.close()\n   . close: java.sql.PreparedStatement.close()\n   . close: java.sql.CallableStatement.close()\n   . close: java.sql.ResultSet.close()\n- JPA:\n   . close: javax.persistence.EntityManagerFactory.close()\n   . close:  javax.persistence.EntityManager.close()\n- Hibernate:\n    . close: org.hibernate.Session.close()\n  . close: org.hibernate.SessionFactory.close()\n- Spring:\n    . close: org.springframework.orm.hibernate3.SessionFactoryUtils.closeSession(...)\n    . close: org.springframework.orm.hibernate4.SessionFactoryUtils.closeSession(...)\n    . close: org.springframework.orm.hibernate5.SessionFactoryUtils.closeSession(...)\n  \n-The following objects are taken into account:\n- output streams\n- input streams\n- readers\n- writers\n- channel\nAvoid operating on resource after expiration or release\nThe software uses, accesses, or otherwise operates on a resource after that resource has been expired, released, or revoked.\n\nWhen a resource is released it might not be in an expected state, later attempts to access the resource may lead to resultant errors that may lead to a crash.\nhttps://cwe.mitre.org/data/definitions/672.html\nASCSM-CWE-672: Expired or Released Resource Usage\nYou can use:\n- isClosed() methods before accessing the Connection object .\n- close() method should be called before closing the application.\nwith finally\n~~~~~~~~~~~~\nif(!connection.isClosed())\n  connection.prepareStatement(\"select * from ....\");\nor\nfinally{\n      System.out.println(\"Closing a connection\");\n      connection.close();\n}\n\nSample #2\n\npublic void finish()\n                throws ExtractorProcessingException\n            {\n                try\n                {\n                    extractor.finish();\n                }\n                finally\n                {\n                    try\n                    {\n               \n                            output.flush();   \n                            output.close();\n                      \n                        }\n                    catch (IOException ioe)\n                    {\n                        throw new ExtractorProcessingException(extractor, ioe);\n                    }\n\n                    }\n}}\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nSample#1\n\nString connectionUrl=\"jdbc:mysql://localhost:3306/MyDb\";\n    String userName=\"root\";\n    String userPass=\"root\";\n    DBConnectionInvalid connectionExample=new DBConnectionInvalid();\n    try{\n      connection=connectionExample.getConnection(connectionUrl, userName, userPass);\n    }catch(Exception e){\n      System.out.println(e.toString());\n    }finally{\n      System.out.println(\"Closing a connection\");\n      connection.close();\n\n      connection.prepareStatement(\"select * from ....\");\n    }\n\n-----------------------\nSample#2\n\npublic void finish()\n                throws ExtractorProcessingException\n            {\n                try\n                {\n                    extractor.finish();\n                }\n                finally\n                {\n                    try\n                    {\n               \n                            output.close();\n                      \n                            output.flush();    //Violation\n                        }\n                    catch (IOException ioe)\n                    {\n                        throw new ExtractorProcessingException(extractor, ioe);\n                    }\n\n                    }\n}}\nAll the methods that have access to the resource in the body", "urls": ["https://cwe.mitre.org/data/definitions/672.html"]}, "8216": {"text": "Number of violation occurrences\nThis rule reports all incorrect numeric type conversions which may produce unexpected results\n\n- int i = (int) 33457.8f; \n- int i1 = 1 + 2+ (int)3.5\n- if(integerValue == (int)floatValue)\n\nA violation is raised if converting from one data type to another, such as long to integer in the data which can be translated in a way that produces unexpected values.\nAvoid using incompatible mutation\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nThe program could wind up using the wrong number and generate incorrect results. If the number is used to allocate resources or make a security decision, then this could introduce a vulnerability.\n - A widening conversion of an int or a long value to float, or of a long value to double, may result in lose of precision - that is, the result may lose some of the least significant bits of the value. In this case, the resulting floating-point value will be a correctly rounded version of the integer value, using IEEE 754 round-to-nearest mode\n\n - A narrowing primitive conversion from double to float is governed by the IEEE 754 rounding rules (\u00a74.2.4). This conversion can lose precision, but also lose range, resulting in a float zero from a nonzero double and a float infinity from a finite double. A double NaN is converted to a float NaN and a double infinity is converted to the same-signed float infinity.\nhttps://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.3\nhttps://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.5\n\n\nhttps://cwe.mitre.org/data/definitions/681.html\nhttp://www.informit.com/articles/article.aspx?p=174371\nYou can use Widening Primitive Conversion to avoid loss of precision.\nA widening primitive conversion does not lose information about the overall magnitude of a numeric value.\n   byte to short, int, long, float, or double\n   short to int, long, float, or double\n   char to int, long, float, or double\n   int to long, float, or double\n   long to float or double\n   float to double\n-Despite the fact that loss of precision may occur, a widening primitive conversion never results in a run-time exception\n\nA narrowing primitive conversion may lose information about the overall magnitude of a numeric value.\n   short to byte or char\n   char to byte or short\n   int to byte, short, or char\n-Despite the fact that overflow, underflow, or other loss of information may occur, a narrowing primitive conversion never results in a run-time exception\nint i = (int) 33457.8f;\nshort i1 = (short)ic.readdata(); // VIOLATION if readdata returns long\nint i1 = 1 + 2+ (int)3.5 // VIOLATION\nNumber of Java artifacts that can reference an incompatible mutation which includes methods, lambdas and constructors", "urls": ["https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.3", "https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.5", "https://cwe.mitre.org/data/definitions/681.html", "http://www.informit.com/articles/article.aspx?p=174371"]}, "61010": {"text": "Complexity - OO Inheritance and Polymorphism", "urls": []}, "61017": {"text": "Documentation - Naming Convention Conformity", "urls": []}, "61022": {"text": "Volume - Number of Components", "urls": []}, "61027": {"text": "Dead code (static)", "urls": []}, "1022000": {"text": "Associated Value\nDES and 3DES are vulnerable to attack mainly because of time complexity and used techniques. \n   This rule is reporting violation when weak encryption algorithm like DES or Triple DES is used in the code source.\n   \n   This rule is compliant with \nCWE-326 - Inadequate Encryption Strength \nCWE-327 - Use of a Broken or Risky Cryptographic Algorithm \nOWASP Top 10 2013 : A6 Sensitive Data Exposure \nOWASP Top 10 2017 : A3 Sensitive Data Exposure\nDEPRECATED: Avoid weak encryption algorithm as DES and triple DES\nThis rule reports the full name of the java method using weak encryption like DES or Triple DES algorithm.\nThe Data Encryption Standard is a symmetric-key algorithm for the encryption of electronic data.\nDES is now considered to be insecure for many applications. This is mainly due to the 56-bit key size being too small. In January 1999, distributed.net and the Electronic Frontier Foundation collaborated to publicly break a DES key in 22 hours and 15 minutes (see chronology).\nSome analytical results demonstrate theoretical weaknesses in the cipher, Attack have been also demonstrated in practice. Even in the form of Triple DES, it is believed to be insecure.\nDES has been withdrawn as a standard by the National Institute of Standards and Technology. (NIST)\nhttps://cwe.mitre.org/data/definitions/780.html\nhttps://cwe.mitre.org/data/definitions/327.html\nhttps://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure\nFederal agencies are encouraged to use the Advanced Encryption Standard, a faster and stronger algorithm approved as FIPS 197 in 2001.\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);\n        byte[] encrypted = cipher.doFinal(clean);\n// Create a DES key object specification from the raw data\nDESKeySpec dks = new DESKeySpec(Hex.fromString(keyString));\n// Create a key factory and use it to turn the DESKeySpec into\n// a SecretKey object\nSecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\nSecretKey key = keyFactory.generateSecret( dks );\nCipher cipher = Cipher.getInstance(\"DES/ECB/NoPadding\");\n// Initialize the cipher with the key\ncipher.init( Cipher.ENCRYPT_MODE, key, sr );\nbyte[] data = Hex.fromString(plainData);\nNumber of Java methods", "urls": ["https://cwe.mitre.org/data/definitions/780.html", "https://cwe.mitre.org/data/definitions/327.html", "https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure"]}, "1022002": {"text": "Number of violation occurrences\nThe aim of this rule is to report violation when RSA encryption algorithm is used without Padding. This can be identified when literal value starting with RSA/NONE is found in source code\nAvoid using RSA Cryptographic algorithms without OAEP (Optimal Asymmetric Encryption Padding)\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nOptimal Asymmetric Encryption Padding schemes are often used with cryptographic algorithms to make the plaintext less predictable and complicate attack efforts. The OAEP scheme is often used with RSA to nullify the impact of predictable common text.\nhttps://cwe.mitre.org/data/definitions/780.html\nhttps://cwe.mitre.org/data/definitions/327.html\nhttps://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure\nhttps://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/\nFederal agencies are encouraged to use the Advanced Encryption Standard, a faster and stronger algorithm approved as FIPS 197 in 2001.\nCipher cipher = Cipher.getInstance(\"RSA/ECB/OAEPWithMD5AndMGF1Padding\", \"BC\");\npublic class TestRSA {\n\n    public static void main(String[] args) throws Exception {\n\n byte[] input = new byte[100];\n\n Cipher cipher = Cipher.getInstance(\"RSA/None/NoPadding\", \"BC\");\n KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\", \"BC\");\nNumber of Java methods", "urls": ["https://cwe.mitre.org/data/definitions/780.html", "https://cwe.mitre.org/data/definitions/327.html", "https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure", "https://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/"]}, "2258": {"text": "File directory\nTo be compliant with code Conventions for the JavaServer Pages Technology, this rule checks if all image files ( .gif, .jpg, etc.) are in the recommended location:  <context root> /images/\nDEPRECATED: All image files should be in a specific directory\nFor maintainability aspects, file organization must be respected.\nhttps://www.oracle.com/technical-resources/articles/javase/code-convention.html\nChange file location according to the recommended naming convention.\nThis report lists all image files (X) located outside the \"images\" directory. It provides the following information: File full name, File directory\nNumber of image files", "urls": ["https://www.oracle.com/technical-resources/articles/javase/code-convention.html"]}, "61015": {"text": "Respect of file organization practices\nProgramming Practices - File Organization Conformity", "urls": []}, "61028": {"text": "Respect of comment practices regarding comments volume\nDocumentation - Volume of Comments", "urls": []}, "61023": {"text": "Respect of sizing practices regarding the number of code lines\nVolume - Number of LOC", "urls": []}, "4656": {"text": "Exception Class Full Name\nThis rule reports all methods with code (i.e. not interface or abstract method or instance of generic method) that are declared to throw an exception that is never thrown in the method body.\n\nA violattion is raised for each method: \n- declared to throw an exception in the signature\n- AND \n   o not throwing this exception or subclass directly or via a method declared to throw it\n   o OR that catch this exception \n\nNote that catching an exception is verified independently of where it occurs in the method code.\nAvoid declaring an exception in the method signature and not throwing it\nWhen a method is declared to throw an exception but does not throw any exception:\n- the caller must write extra code to handle this potential exception\n- it makes the code difficult to read\n- the caller will have to write a try/catch block that will affect the performance of the application\nRemove the 'throws' declaration from the signature\npublic void aMethod() {\n   System.println(\"a Method\"); // FIXED\n}\nThis report lists all Methods declaring throwing an exception and not throwing it.\nIt provides the following information:\n - Method full name\n - Exception Class Full Name\npublic void aMethod() throws myException {\n   System.println(\"a Method\"); // VIOLATION\n}\nNumber of methods declaring throwing an exception in the signature except methods from interface and abstract methods", "urls": []}, "7254": {"text": "This rule reports non-static methods that don't use instance fields except if they have been extended in a subclass or inherit from their parents.\nDeclare as Static all methods not using instance members\nWhen an object is created:\n    * Memory is allocated to all the fields\n    * All super class fields are also allocated memory\n    * All sub class fields, super class fields are initialized .\n    * The constructor is invoked.\n\nUsing a static avoid to create an object that takes resources when it is unnecessary.\nhttps://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html\nMake this method static.\nclass Example {\n    static double pi = 3.14;\n\n    static int min (int x, int y) { // FIXED\n      return (x>y?y:x);\n    }\n\n    static double getPi() {  // FIXED\n       return pi;\n    }\nThis report lists all non-static methods that don't use any instance fields.\nIt provides the following information:  Method Full Name\nclass Example {\n    static double pi = 3.14;\n\n    int min (int x, int y) { // VIOLATION\n      return (x>y?y:x);\n    }\n\n    double getPi() {  // VIOLATION\n       return pi;\n    }\nNumber of non static methods\nNumber of violation occurrences\nThis rule reports non-static methods that don't use instance fields except if they have been extended in a subclass or inherit from their parents.\n\nThe rule excludes Bean methods from Spring.\nDeclare as Static all methods not using instance members\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nWhen an object is created:\n    * Memory is allocated to all the fields\n    * All super class fields are also allocated memory\n    * All sub class fields, super class fields are initialized .\n    * The constructor is invoked.\n\nUsing a static avoid to create an object that takes resources when it is unnecessary.\nhttps://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html\nhttps://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factorybeans-annotations (See note under 1.10.5. Defining Bean Metadata within Components)\nMake this method static.\nclass Example {\n    static double pi = 3.14;\n\n    static int min (int x, int y) { // FIXED\n      return (x>y?y:x);\n    }\n\n    static double getPi() {  // FIXED\n       return pi;\n    }\nclass Example {\n    static double pi = 3.14;\n\n    int min (int x, int y) { // VIOLATION\n      return (x>y?y:x);\n    }\n\n    double getPi() {  // VIOLATION\n       return pi;\n    }\nNumber of non static methods", "urls": ["https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html", "https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html", "https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factorybeans-annotations"]}, "7490": {"text": "Hibernate Entity name\nThis rule checks Hibernate Entities associated to a table that fires an UPDATE trigger and that does not set select-before-update property to true.\nAvoid UPDATE trigger firing when not necessary\nTriggers and object-relational mapping often create issues due to the difficulties of synchronizing the effect of a trigger with the representation of data in memory.\nWhen you are using detached objects associated to a table associated to trigger, Hibernate may execute unnecessary SQL UPDATE statements to ensure that the database state is synchronized with the session state and will affect the performances of your application.\nHibernate in Action (ISBN 1932394-15-X) p 339\nJava Persistence with Hibernate (ISBN 1-932394-88-5) p 349\nUse the attribute select-before-update for the persistent class associated to a table that have the UPDATE trigger. This setting forces Hibernate to retrieve a snapshot of the current database state using an SQL SELECT that will enable the subsequent UPDATE to be avoided when the state of the persistent object in the memory is the same.\n---> sample.hbm.xml\n// FIXED\n<class name=\"Sample\" table=\"SAMPLE\"\nselect-before-update=\"true\">\n...\n</class>\nList all Hibernate Entity that don't use select-before-update and that are associated to a table that fires an UPDATE trigger.\n\nIt provides the following information:\n XML File, Hibernate Entity\nSAMPLE is a table managed by an UPDATE trigger\n---> sample.hbm.xml\n// VIOLATION\n<class name=\"Sample\" table=\"SAMPLE\">\n...\n</class>\nNumber of Hibernate XML classes associated to a table managed by a trigger", "urls": []}, "7308": {"text": "Inner class accessed\nThis rule retrieves all methods that use inner classes except if the class is a static one.\nDEPRECATED: Avoid using Inner Classes\nJava bytecode has no concept of inner classes, so the compiler translates inner classes into ordinary classes that can be accessed by any code in the same package. An inner class can access the fields of the enclosing outer class even if these fields are declared private and the inner class is translated into a separate class. To allow this separate class to access the fields of the outer class, the compiler silently changes these fields' scope from private to package. As a result, when inner classes are declared, they are exposed but the compiler also silently overrules the decision to make some fields private.\nhttps://cwe.mitre.org/data/definitions/485.html\nhttps://cwe.mitre.org/data/definitions/492.html\nhttp://www.cs.umd.edu/~pugh/java/SecureInnerClasses.pdf\nMake the inner class a standard class.\npublic class MyInner {\n}\n\npublic class MyOuter {\n\n private MyInner inner;\n \n public MyInner saveInner(MyInner in) {\n  inner = in;\n  return in;\n }\n}\n\npublic class AClass extends MyOuter {\n MyOuter outer;\n \n   public MyInner saveInner(MyInner in) {\n    return outer.saveInner(in);\n   }\n}\nThis report lists all methods using Inner Classes. It provides the following information:\n - Method full name\n - Inner class accessed\npackage org.test;\n\npublic class MyOuter {\n\n \n public class MyInner {\n }\n private MyInner inner;\n \n public MyInner saveInner(MyInner in) {\n  inner = in;\n  return in;\n }\n}\n\n\npublic class AClass extends MyOuter{\n MyOuter outer;\n \n   public MyInner saveInner(MyInner in) { /* VIOLATION: reference to the inner class MyInner */\n    return outer.saveInner(in);\n   }\n}\nNumber of Java Methods", "urls": ["https://cwe.mitre.org/data/definitions/485.html", "https://cwe.mitre.org/data/definitions/492.html", "http://www.cs.umd.edu/~pugh/java/SecureInnerClasses.pdf"]}, "7306": {"text": "Class full name\nThis Quality Rule retrieves all classes that declare at least one inner class.\nDEPRECATED: Avoid declaring Inner Classes\nJava bytecode has no concept of inner classes, so the compiler translates inner classes into ordinary classes that are accessible to any code in the same package. An inner class gets access to the fields of the enclosing outer class even if these fields are declared private and the inner class is translated into a separate class. To let this separate class access the fields of the outer class, the compiler silently changes these fields' scope from private to package. As a result, when inner classes are declared, they are exposed but also the compiler silently overrules the decision to make some fields private. This is a threat to both the stability and the security of the application.\n\n\nInner classes quietly introduce several security concerns because of the way they are translated into Java bytecode. In Java source code, it appears that an inner class can be declared to be accessible only by the enclosing class, but Java bytecode has no concept of an inner class, so the compiler must transform an inner class declaration into a peer class with package level access to the original outer class. More insidiously, since an inner class can access private fields in their enclosing class, once an inner class becomes a peer class in bytecode, the compiler converts private fields accessed by the inner class into protected fields.\nhttps://cwe.mitre.org/data/definitions/485.html\nhttps://cwe.mitre.org/data/definitions/492.html\nhttp://www.cs.umd.edu/~pugh/java/SecureInnerClasses.pdf\nMake the inner class a standard class.\npublic class BankAccount {\n\n}\n\nclass AccountKey {  \n    // FIXED\n  }\nThis report lists all Classes declaring Inner Classes. It provides the following information:\n - Inner Class full name\n - Class full name\npublic class BankAccount {\n\n  private class AccountKey {  \n    // VIOLATION\n  }\n}\nNumber of Java classes", "urls": ["https://cwe.mitre.org/data/definitions/485.html", "https://cwe.mitre.org/data/definitions/492.html", "http://www.cs.umd.edu/~pugh/java/SecureInnerClasses.pdf"]}, "7220": {"text": "Number of violation occurrences\nMeasures the amount of unused and unnecessary Java imports compared to all Java imports.\nDEPRECATED: Avoid Unused Imports\nThis report lists Files having unused imports.\nIt provides the following information:\n File full name\nLeaving unused and unnecessary is detrimental to code readability.\nIt is also an issue for modularity and component reuse.\nRemove unused and unnecessary Java imports.\nThis remediation is now automated in the major Java development environments.\nNumber of Java files and Web files", "urls": []}, "7188": {"text": "When enforcing the utilization of JavaDoc Comments to document an application, all private fields must have JavaDoc Comments. Those comments must be defined just before the declaration of the Method with the appropriate structure (/** */)\nDEPRECATED : Private fields must have JavaDoc Comments\nThis report lists all private  Fields not having JavaDoc comments.\nThis report provides the following information:\n Field full name\nThere is no dispute that these comments contribute to a developer's understanding and help a developer write reliable applications more quickly. Without documenting fields it is dififcult for anyone else than the author to guess the purpose of the field except by looking at the code that is using it.\nNumber of private Java fields", "urls": []}, "4698": {"text": "'System.err' and 'System.out' should not be used outside a try catch block.\nDEPRECATED: Avoid using 'System.err' and 'System.out' outside a try catch block\n'System.err' and 'System.out' should not be used outside a try catch block.\nEnsure to have other ways of listing errors outside a try/catch  than 'System.err' and 'System.out'\nThis report lists all Methods using 'System.err' and 'System.out' outside a try catch block. It provides the following information: Method full name\nNumber of non-abstract Java artifacts.", "urls": []}, "4696": {"text": "This rule reports any reference to  'System.err' and/or'System.out' as violation.\nDEPRECATED: Avoid using 'System.err' and 'System.out' within a try catch block\nAccessing System.out or System.err from an application is a problem if the system (especially as a server) goes to production:\n\n\u2013 Messages are written directly to the console. This makes it difficult to redirect specific entries to separate files, configure the required log format (e.g. timestamp, current thread etc.) or specify rules for rollover, retention etc.\n\n\u2013 There\u2019s no way to use severity for messages (e.g. trace, debug, info, warn, error). There\u2019s natural difference between an exception which needs to be logged and some debugging output. The latter one is not desired to be visible in a production system as it negatively affects performance and creates large log files which are hard to analyze.\nPrefer using logging framework  as SLF4j.\nThis report lists all Methods using 'System.err' in catch blocks. It provides the following information: Method full name\ntry {\n  // Do something that may throw an exception.\n}\ncatch (Exception e) {\n  System.err.println(e);\n}\nNumber of non-abstract Java artifacts", "urls": []}, "4614": {"text": "This report lists all Methods overriding 'clone()' and not calling 'super.clone()'\nDEPRECATED: Proper overriding of 'clone()'\nA call to 'super.clone()' ensures the clone behavior will still work.\nWhen overriding the 'clone()' Method, a call to 'super.clone()' is necessary. Note that where a class 'A' that has a field 'a' of type 'A' and is calling a.clone() without calling super.clone() will not be reported as a violation.\nhttps://www.vojtechruzicka.com/java-cloning-problems/\nhttps://help.semmle.com/wiki/display/JAVA/Missing+super+clone\nReview the Method definition\nclass Person implements Cloneable {\n    private String name;\n    public Person(String name) { this.name = name; }\n    \n    public Person clone() {\n        try {\n            return (Person)super.clone(); // FIXED 'clone' correctly calls 'super.clone'\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should never happen\");\n        }\n    }\n}\nThis report lists all Methods overriding 'clone()' and not calling 'super.clone()'.\nIt provides the following information:\n Method full name\nclass Person implements Cloneable {\n    private String name;\n    public Person(String name) { this.name = name; }\n    \n    public Person clone() {\n        return new Person(this.name); // violation \n    }\n}\nNumber of Java methods", "urls": ["https://www.vojtechruzicka.com/java-cloning-problems/", "https://help.semmle.com/wiki/display/JAVA/Missing+super+clone"]}, "4574": {"text": "Deprecated Object full name\nList all Deprecated Methods or Fields.\nIn Java, Deprecated objects are defined with the JavaDoc tag @deprecated or the annotation @deprecated available since JSE 5. (to obtain accurate results, the java archive rt.jar must also have been analyzed).\nIn VC++ it reports objects using the deprecated __declspec declaration or pragma.\nIn GCC it reports objects with the deprecated attribute\n\nIf the reason/remediation of the deprecation is described in the source code, it is also displayed.\nDEPRECATED: Avoid using deprecated objects\nDeprecated Methods or Fields may not be available in the next version.\nhttp://msdn.microsoft.com/en-us/library/044swk7y%28VS.80%29.aspx\nhttp://msdn.microsoft.com/en-us/library/c8xdzzhh%28v=VS.80%29.aspx\nThis report lists all the Methods using a deprecated Method\nIt provides the following information:\n - Method full name\n - deprecated Object full name\nIf the reason/remediation of the deprecation is described in the source code, it is also displayed.\nNumber of Java objects", "urls": ["http://msdn.microsoft.com/en-us/library/044swk7y%28VS.80%29.aspx", "http://msdn.microsoft.com/en-us/library/c8xdzzhh%28v=VS.80%29.aspx"]}, "2282": {"text": "Included files\nIncluded files should not have more than X lines of code. The threshold is a parameter and can be changed at will.\nDEPRECATED: Avoid large Include Files\nLarge includes are more difficult to understand, and are often a sign of a bad modularity of the code.\nReview the design of the include to reduce its size.\nThis report lists all Files including Files with more than X lines of code. \nIt provides the following information: \n- JSP page name\n- Included files\nNumber of JSP pages", "urls": []}, "2280": {"text": "Avoid using \"Document.all\" JScript code.\nDEPRECATED: Avoid using Document.all collection\nUsing the Document.all collection is slow when retrieving its different objects into HTML, HTM, JSP, JS files as it collects - and loads in memory - all items.\nE.g.: Rather use: var temp = document.foo  temp.innerText = \"Hello\" Instead of document.all['foo'].innerText = \"Hello\"\nThis report lists all uses of Document.all JavaScript code.\nIt provides the following information: \n - Web file Artifact full name\nNumber of objects belonging to files with extension given by parameter", "urls": []}, "2278": {"text": "Utilization of \"foreach\" custom tag library may lead to performance problems.\nDEPRECATED: Check the use of \"foreach\" custom tag library\nDepending on the implementation of \"forEach\" custom tag, performance issues are at hand. E.g.: in JSTL 1.1., \"forEach\" is much slower than \"transform\" to process XML files; \"forEach\" can lead to the generation of huge table display; etc.\nCheck if the use of \"forEach\" is well controlled.\nThis report lists all uses of \"forEach\" custom\nNumber of JavaScript eFunctions and JSP eFile", "urls": []}, "2266": {"text": "All files should have standard file extensions. The list of standard, authorized extensions is a parameter that can be changed at will.\nDEPRECATED: Avoid non standard file extensions (JEE)\nThis report lists all files with a non-standard extension. It provides the following information: File full name\nFor readability aspects, naming conventions must be respected.\nChange the file extension according to the recommended naming convention.\nNumber of eFiles", "urls": []}, "2254": {"text": "Number of lines\nThe rule list all the large page files.\nDEPRECATED: Avoid large Page files (JEE)\nThis report lists all Page files with more than X lines of code. \nIt provides the following information: \n - Page name\n - number of lines\nPages should not have more than X lines of code. The threshold is a parameter and can be changed at will.\nReview the source code in order to have pages with less than  X lines of code\nNumber of JSP pages", "urls": []}, "2248": {"text": "Comment/code ratio\nWeb Server pages should have at least a ratio comment/code > X %.\nThe threshold is a parameter and can be changed at will.\nDEPRECATED: Avoid Web Server pages having a very low Comment/Code ratio\nMaintainability of the code is facilitated if there is documentation in the code. This rule will ensure there are enough comments within the Artifact\nEnrich Artifact code with comments\nThis report lists all pages with comment/code ratio lower than X %\nIt provides the following information:\n - Page full name\n - comment/code ratio\nNumber of JSP pages", "urls": []}, "2244": {"text": "Pages should have comments\nDEPRECATED: Avoid undocumented Web Server Pages\nMaintainability of the code is facilitated if there is documentation in the code. This rule will ensure there are comments within the Artifact\nEnrich Artifact code with comments\nThis report lists all undocumented pages. \nIt provides the following information:\n Page name, Page full name\nNumber of JSP pages", "urls": []}, "2242": {"text": "Page name\nAll JavaScript Functions should be defined in a JS file and not directly in the Web page (HTM, HTML, JSP).\nDEPRECATED: Avoid direct definition of JavaScript Functions in a Web page (JEE)\nSeparate behavior from presentation makes the code easier to read and debug, it lets designers and developer work on different files. It allows also to load the JavaScript from the browser one time only (and not each time the file is loaded) if included in the HTML file with the HTML link tag.\nBest Practices: Implementing JavaScript for rich internet applications\nhttp://thinkingandmaking.com/entries/63\nEnsure to have separate behavior from presentation and not to have direct definition of JavaScript Functions in a Web pag\nThis report lists all JavaScript Functions defined within the Web page and not within a JS file.\nIt provides the following information:\n - Function name\n - Page name\n \nNumber of JavaScript functions", "urls": ["http://thinkingandmaking.com/entries/63"]}, "2236": {"text": "Number of violation\nThe rule reports all pages that reference a class, interface or method whose full qualified name begin with 'java.sql.' or 'javax.sql'\n\nStandard SQL APIs java.sql.* and javax.sql.* are symptoms of direct access to tables.\n  \nDEPRECATED: Avoid use of standard SQL API\nReview the architecture design to invoke the layer in charge of database access.\nThis report lists all JSP pages using standard SQL APIs \nIt provides the following information: \n - Page name\n - the number of violation\n<%@ page import = \"java.sql.*\" %>\n<% Connection myConnection =null; //VIOLATION\n      Statement myStatement =null; //VIOLATION\n      ResultSet myResultSet =null; //VIOLATION\n      javax.sql.DataSource myDataSource = null; //VIOLATION\n%>\n\n// 4 violations will be reported\nNumber of JSP pages", "urls": []}, "2230": {"text": "This metric detects the pages where a Style sheet (*.css) is not directly or explicitly used.\nStyle sheet (*.css) should be used (instead of no css or hardcoded style definition like style= ).\nDEPRECATED: Use of style sheets (JEE)\nBy using a style sheet, you ensure that the display is the same across the website. It allows to centralize maintenance of pages look and feel.\nhttp://webdesign.about.com/od/css/a/aa073106.htm\nUse a style sheet\nThis report lists all pages not directly or explicitly using a style sheet. \nIt provides the following information: Page name\nNumber of pages", "urls": ["http://webdesign.about.com/od/css/a/aa073106.htm"]}, "4668": {"text": "This rule will check the use of JavaDoc @author tag for each Classes/Interfaces.\nDEPRECATED: Classes and Interfaces must have JavaDoc @author tag\nWhen enforcing the utilization of JavaDoc Comments to document an application, the @author tag should be used to know who wrote a given Class or Interface.\nPut as Deprecated as @author tag is something that you can have looking to history in SCM and it's useless when dev has left company.\nAdd JavaDoc @author tag to Classes and Interfaces\nThis report lists all Classes and Interfaces not having the @author JavaDoc comments.\nThis report provides the following information:\n Class or Interface Full Name\nNumber of classes and interfaces (generic or not)", "urls": []}, "7192": {"text": "Bypassing the validation framework for a form exposes the application to numerous types of attacks. \nForms derived from 'ActionForm' or 'DynaActionForm' classes cannot use the Struts Validator. This rule reports all classes that inherit from:\n- org.apache.struts.action.ActionForm\n- org.apache.struts.action.DynaActionForm\nAvoid using Struts Form that cannot extend Validator Class\nStruts validation framework allows preventing the application from any type of attacks based on invalid field input. To enable this framework on Struts Form, Struts Form must extend Struts Validation class. Unchecked input is the root cause of vulnerabilities like cross-site scripting, process control, and SQL injection. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.\nhttps://www.owasp.org/index.php/Struts:_Form_Does_Not_Extend_Validation_Class\nExtend these classes with one of these classes:\norg.apache.struts.validator.ValidatorForm\norg.apache.struts.validator.ValidatorActionForm\norg.apache.struts.validator.DynaValidatorForm\norg.apache.struts.validator.DynaValidatorActionForm\npublic class MyClassForm extends ValidatorForm {\n\n   public void validate() {  // NO VIOLATION because you subclass ValidatorForm and you override validate method\n   }\n\n}\nThis report lists all classes that violate this rule.\nIt provides the following information:\n Class Full Name\npublic class MyClassForm extends ActionForm {    // VIOLATION validate not overriden \n\n\n\n}\nNumber of Java classes in the Struts application\nList all classes that inherit from:\norg.apache.struts.action.ActionForm\norg.apache.struts.action.DynaActionForm\nAvoid using Struts Form that cannot extend Validator Class\nThis report lists all classes that violate this rule.\nIt provides the following information:\n Class Full Name\nStruts validation framework allows preventing the application from any type of attacks based on invalid field input. To enable this framework on Struts Form, Struts Form must extend Struts Validation class. Unchecked input is the root cause of vulnerabilities like cross-site scripting, process control, and SQL injection. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.\nhttp://cwe.mitre.org/documents/sources/SevenPerniciousKingdoms.pdf\nhttp://cwe.mitre.org/data/definitions/104.html\nExtend these classes with one of these classes:\norg.apache.struts.validator.ValidatorForm\norg.apache.struts.validator.ValidatorActionForm\norg.apache.struts.validator.DynaValidatorForm\norg.apache.struts.validator.DynaValidatorActionForm\npublic class MyClassForm extends ValidatorForm {\n\n   public void validate() {  // NO VIOLATION because you subclass ValidatorForm and you override validate method\n   }\n\n}\npublic class MyClassForm extends ActionForm {    // VIOLATION validate not overriden\n\n\n\n}\nNumber of Java classes in the Struts application", "urls": ["https://www.owasp.org/index.php/Struts:_Form_Does_Not_Extend_Validation_Class", "http://cwe.mitre.org/documents/sources/SevenPerniciousKingdoms.pdf", "http://cwe.mitre.org/data/definitions/104.html"]}, "8100": {"text": "Number of violation occurrences\nThis quality rule reports synchronous call that don't use timeout to prevent an infinite waiting time.\n\nHere is the list of control that are performed:\n- Socket : java.net.Socket.connect(SocketAddress endpoint) or connect(SocketAddress endpoint, int 0)\n- Future: a Future represents the result of an asynchronous computation: java.util.concurrent.Future<V>.get() \n- JMS: All call to methods that implement javax.jms.MessageConsumer.receive() or javax.jms.MessageConsumer.receive(0)\nBlocking synchronous calls should have associated timeouts\nBlocking calls can result in system failure if the called process fails. If the timeout is infinite that may cause the application to hang forever. Operations on the standard input/output streams depend directly on other processes outside of the Java VM. If they decide to block forever, so will reads/writes to these streams in the application.\nASCRM 1.0, Automated Source Code Reliability Measure, Object Management Group.\nhttp://satishgopal.wordpress.com/2011/04/24/ejb-3-1-asynchronous-methods/\nhttp://docs.oracle.com/javaee/1.3/jms/tutorial/1_3_1-fcs/doc/client.html\nhttp://stackoverflow.com/questions/1164301/how-do-i-call-some-blocking-method-with-a-timeout-in-java\nFor Socket\nYou should use call connect(SocketAddress endpoint, int timeout) instead of calling java.net.Socket.connect(SocketAddress endpoint) or connect(SocketAddress endpoint, int 0)\nTrue for child classes too\n\nFor Future : As remediation, you should use java.util.concurrent.Future<V>.get(long timeout, TimeUnit unit) for all classes that implement the interface such as java.util.concurrent.FutureTask<V>, java.util.concurrent.ForkJoinTask<V> ... and all classes that implement a sub-interface of Future<V>.\n\nFor JMS: You should call javax.jms.MessageConsumer.receive(long timeout) instead of calling methods that implement javax.jms.MessageConsumer.receive() or javax.jms.MessageConsumer.receive(0)\npublic static boolean pingHost(String host, int port, int timeout) {\n  try (Socket socket = new Socket()) {\n    socket.connect(new InetSocketAddress(host, port), timeout);\n    return true;\n  } catch (IOException e) {\n    return false; // Either timeout or unreachable or failed DNS lookup.\n  }\n}\n\n--------------------------------------------------------------------------\n\nimport java.util.concurrent.*;\nimport java.util.*;\n\nclass SimpleThreadPool{\n public static void main(String args[])throws Exception{\n  \n                List<Future<String>> l1 = new ArrayList<Future<String>> ();\n  ExecutorService exec = new ThreadPoolExecutor(3, 3, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());\n   CallableTask tasks[] =new CallableTask[5];\n   for(int i=0; i<5; i++){\n    tasks[i] = new CallableTask(\"task\" + i);\n    Future<String> future = exec.submit(tasks[i]);\n                                l1.add(future);\n                                try{\n                                    System.out.println(future.get(100,TimeUnit.MILLISECONDS));\n                                }\n                                catch(TimeoutException e){\n                                       System.out.println(e); \n                                        }\n   }\n\n--------------------------------------------------------------------------------------------------------\n\npublic void testChangeMutableObjectInObjectMessageThenRollback() throws Exception {\n  ArrayList<String> list = new ArrayList<String>();\n  list.add(\"First\");\n  Message outbound = session.createObjectMessage(list);\n  outbound.setStringProperty(\"foo\", \"abc\");\n  beginTx();\n  producer.send(outbound);\n  commitTx();\n  LOG.info(\"About to consume message 1\");\n  beginTx();\n  Message message = consumer.receive(5000);\nList all artifacts that call a blocking method without timeout\nIt provides the following information: \n - Artifact full name\nFOR SOCKET:\n\nvoid TKO() throws IOException, InterruptedException\n    {\n        SocketAddress me = new InetSocketAddress(\"127.0.0.1\", SERVER_PORT);\n        Socket s = new Socket();\n        s.connect(me,0);\n        OutputStream os = s.getOutputStream();\n        os.write(\"CONNECT \\n\\n\".getBytes());\n        os.flush();\n        os.close();\n        Thread.sleep(50);\n    }\n\n-----------------------------------------------------------------------------\nFOR FUTURE:\n\nFutureTask futureTask_1 = new FutureTask(new CallableCalculater(0, MAX_NUMBER / 2, DIVISOR));\ntaskList.add(futureTask_1);\nexecutor.execute(futureTask_1);\n  \nFutureTask futureTask_2 = new FutureTask(new CallableCalculater(MAX_NUMBER / 2 + 1, MAX_NUMBER, 3));\ntaskList.add(futureTask_2);\nexecutor.execute(futureTask_2);\n------------------------------------------------------------------------------\n\nFOR JMS:\n\npublic void receiveAndRespondWithMessageIdAsCorrelationId(ConnectionFactory connectionFactory, String queueName) throws JMSException {\n    Connection connection = connectionFactory.createConnection();\n    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n    MessageConsumer consumer = session.createConsumer(session.createQueue(queueName));\n    final javax.jms.Message inMessage = consumer.receive();\nNumber of Java Artifacts that call a blocking method", "urls": ["http://satishgopal.wordpress.com/2011/04/24/ejb-3-1-asynchronous-methods/", "http://docs.oracle.com/javaee/1.3/jms/tutorial/1_3_1-fcs/doc/client.html", "http://stackoverflow.com/questions/1164301/how-do-i-call-some-blocking-method-with-a-timeout-in-java"]}, "8136": {"text": "Number of violation occurrences\nThis quality rules checks all the CDI Beans, that is all the classes and producer methods which are annotated with a scope or a qualifier\nCDI Beans with normal scope must be proxyable to avoid runtime errors\nFor a CDI Bean with a normal scope, the CDI contained will provide a proxy of the underlying object instead of a reference to the object itself. If an injected class is not proxyable, the container will raise an exception at runtime. \n\nThis error will not be detected at compilation. \n\nAs per the CDI specs, A class can be put in a proxy if it fulfills the following constraints: \n* It must have a non private Constructor with no argument, \n* It must neither be final nor have a final method. \n\nThe normal scopes are Session, RequestScope, Conversation and Application, and any custom scope annotated as normal.\nhttps://docs.jboss.org/weld/reference/latest/en-US/html/injection.html#_client_proxies \nhttps://docs.jboss.org/cdi/spec/1.2/cdi-spec.html#client_proxies\nMake sure that the injected class fulfills the constraints of a proxy class, change the bean scope.\npublic class Producer{\n\n  @Produces\n  @Dependent\n  @Named(\"stringProvider\")\n  public static String getStringId()\n  {\n  return \"SomeStaticID\";\n  }\n}\n\n \n@Named\npublic class MyBean \n{\n  @Named(\"stringProvider\")\n  private String id;\n}\nThis quality rule reports all the CDI beans which cannot be proxied.\n\nIt handles both the standard scopes and the custom scopes.\npublic class Producer{\n  @Produces\n  @SessionScoped\n  @Named(\"stringProvider\")\n  public static String getStringId()\n  {\n     return \"SomeStaticID\";\n  }\n}\n\n \n@Named\npublic class MyBean \n{\n  @Named(\"stringProvider\")\n  private String id;\n}\nNumber of CDI Beans", "urls": ["https://docs.jboss.org/weld/reference/latest/en-US/html/injection.html#_client_proxies", "https://docs.jboss.org/cdi/spec/1.2/cdi-spec.html#client_proxies"]}, "4680": {"text": "When enforcing the utilization of JavaDoc Comments to document an application, all Fields must have JavaDoc Comments. Those comments must be defined just before the declaration of the field with the appropriate structure (/** */)\nPublic Fields must have JavaDoc Comments\nThere is no dispute that these comments contribute to a developer's understanding and help a developer write reliable applications more quickly. Without documenting fields it is dififcult for anyone else than the author to guess the purpose of the field except by looking at the code that is using it.\nhttps://developer.atlassian.com/server/confluence/javadoc-standards/\nhttps://www.baeldung.com/javadoc\nYou should add JavaDoc Comments for all public fields of the application.\npublic class Customer {\n    \n/**\n   * The first and last name of this customer.\n   */\n    public    String name;\nThis report lists all Public Fields not having JavaDoc comments.\nThis report provides the following information:\n Field full name\npublic class Customer {\n\n    public    String name;   //Violation as there is no JavaDoc Comments for the field.\n    public    String city;\nNumber of public Java fields", "urls": ["https://developer.atlassian.com/server/confluence/javadoc-standards/", "https://www.baeldung.com/javadoc"]}, "8096": {"text": "Number of violation occurrences\nReports all equality or inequality operations on floating point variables:\n- float x == (...)\n- float x != (...)\n- double x == (...)\n- double x != (...)\nA violation is raised if one of the operands of the ==/!= operator is a float or a double. The other operand is not considered, it can be another floating point variable, an integer or a boolean.\nComparing a Float to NULL is considered as violation.\nAvoid testing floating point numbers for equality\nDue to rounding errors, most floating-point numbers end up being slightly imprecise. As long as this imprecision stays small, it can usually be ignored. However, it also means that numbers expected to be equal (e.g. when calculating the same result through different correct methods) often differ slightly, and a simple equality test fails.\nA comparison between a floating point number and an integer has the same problem, since the integer is cast into a floating point for the comparison.\nhttp://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.4\nhttp://randomascii.wordpress.com/2012/06/26/doubles-are-not-floats-so-dont-compare-them/\nhttp://floating-point-gui.de/errors/comparison/\nhttps://howtodoinjava.com/java/basics/correctly-compare-float-double/\nExcept specific cases where we can expect that the value is the same (see http://randomascii.wordpress.com/2012/06/26/doubles-are-not-floats-so-dont-compare-them), the best is to compare the difference with Epsilon a small float number that you can configure according to the accuracy you want.\nstatic final float EPSILON = 0.0000001f;\n\nfloat a = 0.15f + 0.15f;\nfloat b = 0.1f + 0.2f;\nif(Math.abs(a - b) < EPSILON) {...} // FIX\nif(Math.abs(a - b) > EPSILON) {...} // FIX\n\n---------------------------------------------------------------------\n\nprivate static void testBdEquality()         //Better way to compare Double is with BigDecimal.\n{\n     BigDecimal a = new BigDecimal(\"2.00\");\n     BigDecimal b = new BigDecimal(\"2.0\");\n       \n     System.out.println(a.compareTo(b) == 0);   // FIXED\n}\nReport all artifact that perform float equality comparison. \nIt reports:\n- artifact fullname\nfloat a = 0.15f + 0.15f;\nfloat b = 0.1f + 0.2f;\nif(a == b) {...} // VIOLATION\nif(a != b) {...} // VIOLATION\n\n----------------------------------------\n\nprivate static void testBdEquality() // Do not use 'equals()' to compare 'BigDecimal' instances.\n{\n     BigDecimal a = new BigDecimal(\"2.00\");\n     BigDecimal b = new BigDecimal(\"2.0\");\n \n     System.out.println(a.equals(b));           // Violation\n}\nNumber of artifacts that reference a float", "urls": ["http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.4", "http://randomascii.wordpress.com/2012/06/26/doubles-are-not-floats-so-dont-compare-them/", "http://floating-point-gui.de/errors/comparison/", "https://howtodoinjava.com/java/basics/correctly-compare-float-double/", "http://randomascii.wordpress.com/2012/06/26/doubles-are-not-floats-so-dont-compare-them),"]}, "7936": {"text": "Report all explicit definition of the method finalize() except when the class has native methods.\nDEPRECATED: Avoid using finalize()\nWhen using finalizers, there is no fixed time for finalizers to get executed, which again is JVM dependent: The only thing that is guaranteed is that if at all a finalizer gets executed, it will be before the garbage collector's second cycle. An object may become unreachable and yet its finalizer may not execute for an arbitrarily long time. Nothing of time-critical nature should be run in the finalize method, for instance, closing file handles is not recommended.\n\nIt is possible for the JVM to terminate without invoking the finalizer on an unreachable object. Finalization on process exit is also not guaranteed.\n\nAccording to the Java Language Specification: Section 12.6.2: The Java programming language imposes no ordering on finalize method calls. Finalizers [of different objects] may be called in any order, or even concurrently.\nThis can be a problem as slow running finalizers tend to block others in the queue.\n\nUnintentional mistakes like memory leaks can also cause finalizers to never execute to completion.\n\nA possibility exists such that the programmer unintentionally resurrects the references in the finalize method. While the garbage collector must determine yet again whether the object is free to be deallocated, the finalize method is not invoked again.\n\nA common myth is that finalizers aid garbage collection. On the contrary, they increase garbage collection time and introduce space overheads. They also fail to respect the modern generational garbage collectors. Another trap unfolds while trying to finalize reachable objects, an exercise that is always counterproductive.\n\nSometimes it is necessary to use finalizers especially while working with native objects/code. This is because the garbage collector cannot re-claim memory from code written in another language. Also, the lifetime of the objects is often unknown. Again, the native process must not perform any critical jobs that require immediate resource deallocation.\nEffective Java, 2nd edition, by Joshua Bloch, Addison Wesley. (2008)\nhttps://www.securecoding.cert.org/confluence/display/java/MET12-J.+Do+not+use+finalizers\nhttp://java.sun.com/developer/technicalArticles/javase/finalization\nWhen you use an object that you know has native resources associated with it -- for example, a GUI component, file, or socket -- by all means call its dispose() or equivalent method (a method in charge of cleaning resources) when you are finished using it. This will ensure the immediate reclamation of the native resources and decrease the probability of resource depletion.\npublic class MyClass  {\n     ...\n      protected void dispose() throws Throwable { // FIXED\n          // some code here\n         ......\n          super.dispose();\n     }\n}\nThe metric will list all methods named finalize that belong to a class that has no native methods\n\nIt provides the following information:\n Method full name\npublic class MyClass  {\n     ...\n      protected void finalize() throws Throwable { // VIOLATION\n          // some code here\n         ......\n          super.finalize();\n     }\n}\nNumber of classes", "urls": ["https://www.securecoding.cert.org/confluence/display/java/MET12-J.+Do+not+use+finalizers", "http://java.sun.com/developer/technicalArticles/javase/finalization"]}, "7676": {"text": "This quality rule retrieves all packages that are making Mainframe invocation. This number must not exceed 1 (The threshold is a parameter and can be changed at will.)\nDEPRECATED: Avoid too many packages referencing Mainframe\nAll calls to Mainframe  must be encapsulated into one or more specific packages. It separates design concerns decreasing code duplication, centralizing control, and making the application more easily modifiable.\nReview the design of these package to decrease the number of package that are referencing Mainframe.\nThis report lists all packages that reference Mainframe.\nIt provides the following information:\n package full name\nNumber of packages", "urls": []}, "7510": {"text": "Number of reference\nReports all objects that reference the following java.sql interface and their methods\n- java.sql.Connection\n- java.sql.Statement\n- java.sql.PreparedStatement\n- java.sql.CallableStatement\nexcept when they are used as parameters of hibernate methods (methods whose FQDN begin with net.sf.hibernate or org.hibernate)\n\nThe threshold permits to add other interfaces or classes from other framework to the previous list.\nDEPRECATED: Use only Hibernate API to access to the database\nUsing Hibernate API only brings several benefits:\n- Performances: Hibernate provides potential for caching that is expected to outperforms queries that use direct JDBC access.\n- Implementation: object mapping takes care of mapping the JDBC result sets to graph of persistent objects. Using direct JDBC API means writing the tedious code by hand to transform a JDBC ResultSet to an object graph.\n- Database independence: the code can be used with all supported databases\n- Transparent support of JDBC and JTA in both managed and non-managed environments\nHibernate in Action (ISBN 1932394-15-X)\nIf you really need to use SQL for feature that are not supported by Hibernate (like specifying SQL query hints or hierarchical queries such as Oracle CONNECT BY clause), you can use either SQL queries defined in the hibernate XML file or by using native SQL with org.hibernate.Session.createSQLQuery(java.lang.String queryString).\nSession session = sessionFactory.openSession(); \n\nQuery query = session.createQuery(\"from EmployeeBean\"); \n// FIXED\nList<EmployeeBean> finalList = query.list();\nList objects that use other API than hibernate API\nIt provides the following information:\n - Artifact Full Name\n - Number of reference\nList<EmployeeBean> employeeList = new ArrayList<EmployeeBean>(); \n\nConnection con = DriverManager.getConnection(url); \nStatement stmt = con.createStatement();\n// VIOLATION\nResultSet rs = stmt.executeQuery(\"SELECT * FROM COMPANY\"); \nwhile ( rs.next() ) { \n   EmployeeBean eb = new Employeebean(); \n   eb.setName(rs.getString(\"name\")); \n   eb.setSalary(rs.getFloat(\"salary\")); \n   employeeList.add(eb); \n}\nNumber of artifacts that violate this rule plus the artifacts that reference net.sf.hibernate.Query, org.hiberate.Query, net.sf.hibernate.Session, org.hibernate.Session", "urls": []}, "7362": {"text": "Automatic filtering via a Struts bean has been turned off, which disables the Struts Validator and custom validation logic. This exposes the application to other weaknesses related to insufficient input validation.\n\nThis rule reports all action mapping with disabled validation.\nDEPRECATED: Avoid Struts action mappings validator turned off\nDisabling the validation of a form expose this action to various types of attacks such as SQL Injection, Command Injection, Cross-Site Scripting, Denial of Service... This is due to the fact that invalidated input may allow injecting arbitrary web script, HTML, SQL... Consequences can be severe, like deletion of the entire content of a database. Input validation is mandatory to secure an application. \nMoreover, the web interface is exposed to anyone.\nhttp://cwe.mitre.org/data/definitions/109.html\nEnable the validation.\n----> struts-config.xml:\n...\n<action path=\"/submit\"\n             type=\"submit.SubmitAction\"\n             name=\"submitForm\" input=\"/submit.jsp\"\n             scope=\"request\"\n             validate=\"true\"> // FIXED\n    <forward name=\"success\" path=\"/submit.jsp\"/>\n    <forward name=\"failure\" path=\"/submit.jsp\"/>\n</action>\n...\n\nNote also that the absence of validate attribute is interpreted as validate=\"true\"\nThis report lists all Struts action mappingsAction Mapping that have a disabled validation. It provides the following information:\n  Action Mapping Full Name\n----> struts-config.xml:\n...\n<action path=\"/submit\"\n             type=\"submit.SubmitAction\"\n             name=\"submitForm\" input=\"/submit.jsp\"\n             scope=\"request\" \n             validate=\"false\"> // VIOLATION\n    <forward name=\"success\" path=\"/submit.jsp\"/>\n    <forward name=\"failure\" path=\"/submit.jsp\"/>\n</action>\n...\nNumber of Struts action mapping or 0 if no object of type \"Struts Configuration File\" is present", "urls": ["http://cwe.mitre.org/data/definitions/109.html"]}, "7138": {"text": "Called Action Class full name\nAll Action classes that are referenced in the struts-config.xml through the tag 'action-mapping' (in struts 1.x) or in struts.xml and its included files through the tag 'action' (in struts 2.x) that are invoked by other Java code are listed except when the caller is in the inheritance tree of the Action class.\nDEPRECATED : Action Classes should only be called by Action Mappings tag (for Struts 1.x) or Action tag (for Struts 2.x)\nAction Classes should only be called by Action Mappings to respect struts pattern design\nUse the action mapping table in struts configuration file instead of direct call.\nThis report lists all methods that call Action Classes \nIt provides the following information:\n - Non action mapping class method that call the action class except those in its inheritance tree\n - Action Class full name\nNumber of methods or objects that call struts actions classes", "urls": []}, "7136": {"text": "Cyclomatic Complexity\nEach method in an Action Class (and inherited methods) that are referenced in the struts-config.xml through the tag 'action-mapping' (in struts 1.x) or in struts.xml and its included files through the tag 'action' (in struts 2.x) should have a small cyclomatic complexity.\nDEPRECATED: Each method in an Action Class should have a small complexity\nIt is wise to avoid creating lengthy and complex Action classes. If you start to embed too much logic in the Action class itself, you will begin to find the Action class hard to understand, maintain, and impossible to reuse. Rather than creating overly complex Action classes, it is generally a good practice to move most of the persistence, and \"business logic\" to a separate application layer.\nCyclomatic Complexity equals the minimum number of tests to check the Action Class's behavior. High CC means more testing and higher risk of errors.\nhttp://struts.apache.org/1.x/userGuide/building_controller.html\nRefactor your application architecture and move some of this logic to another conceptual layer; otherwise, you may be left with an inflexible application which can only be accessed in a web-application environment.\nThis report lists all Action methods with Cyclomatic complexity greater than X\nIt provides the following information:\n - Action Method full name\n - Cyclomatic Complexity\nNumber of methods of classes and parent classes that are referenced as an action in the XML configuration file", "urls": ["http://struts.apache.org/1.x/userGuide/building_controller.html"]}, "7132": {"text": "Number of forward\nAll Action Mappings with more than 5 forward will be listed.\nDEPRECATED: Struts action Mappings should have few forwards\nAction Mappings should have few forwards to avoid managing too complex behaviors in the Action class. A forward contains the request URI path to which control is passed when the mapping is invoked.\nReview the application and make sure that action mappings have few forwards to avoid managing too complex behaviors in the Action class.\nThis report lists all action mapping that have more than X forward and the number of forwards.\nIt provides the following information:\n Action Class full name, Number of forward\nNumber of action mapping", "urls": []}, "2264": {"text": "File directory\nAs per code Conventions for the JavaServer Pages Technology, all cascading style sheet files should be in a in the recommended location\n\nAll page files (X) should be in a \"pages\" directory, located in the web root.\nDEPRECATED: All page files should be in a specific directory\nFor maintainability aspects, file organization must be respected.\nChange file location according to the recommended naming convention.\nThis report lists all pages (X) located outside the \"pages\" directory. It provides the following information: File full name, File directory\nNumber of JSP pages", "urls": []}, "2284": {"text": "Number of scriptlets\nAvoid Pages with more than X Scriptlets. Scriptlets begin with <%, <%! or <%=. The threshold is a parameter that can be changed at will.\nDEPRECATED: Avoid large JSP Pages - too many Scriptlets\nFrom JSP 1.2 Specification, it is highly recommended that the JSP Standard Tag Library (JSTL) be used in your web application to help reduce the need for JSP scriptlets in your pages. Pages that use JSTL are, in general, more consistent andd easier for HTML programmers to learn.\nhttp://java.sun.com/developer/technicalArticles/javaserverpages/code_convention\nhttp://stackoverflow.com/questions/2128024/does-scriptlet-hit-the-performance-in-jsp\nReview the design of the Page to reduce the number of Scriptlets\n<%@ taglib uri=\"http://java.sun.com/jstl/core\" prefix=\"c\" %>\n<html>\n <head>\n  <title>Count to 10 Example (using JSTL)</title>\n </head>\n\n <body>\n  <c:forEach var=\"i\" begin=\"1\" end=\"10\" step=\"1\">\n   <c:out value=\"${i}\" />\n\n   <br />\n  </c:forEach>\n </body>\n</html>\nThis report lists all Pages with more than X scriptlets (<%= is considered as scriptlet) in a page. \nIt provides the following information: \n - Page full name\n - Number of scriptlets\n<html>\n <head>\n  <title>Count to 10 in JSP scriptlet</title>\n </head>\n <body>\n<%\n for(int i=1;i<=10;i++)\n{%>\n<%=i%><br/>\n<%\n}\n%>\n </body>\n</html>\nNumber of JSP pages", "urls": ["http://java.sun.com/developer/technicalArticles/javaserverpages/code_convention", "http://stackoverflow.com/questions/2128024/does-scriptlet-hit-the-performance-in-jsp", "http://java.sun.com/jstl/core"]}, "8220": {"text": "Number of violation occurrences\nA violation is reported if a deprecated class, method, field variable or type used/called in the java code.\nAvoid using deprecated method, constructor, field, type or package\nThe purpose is to avoid to use the deprecated  enity as currently good and appropriate new version of the same is available. The deprecated entity may be dropped sometime in near future without any intimation.\nhttps://docs.oracle.com/javase/1.5.0/docs/guide/javadoc/deprecation/deprecation.html\nhttp://cwe.mitre.org/data/definitions/477.html\nhttps://wiki.sei.cmu.edu/confluence/display/java/MET02-J.+Do+not+use+deprecated+or+obsolete+classes+or+methods\nCheck the documentation of the deprecated entity and avoid not to use the same. Some other way can be approached or new method, type or class can be used instead\n-Sample 1\nprivate void dumpResponse(ServerResponse response) {\n  \n  try {\n    String resp = new String(response.getByteArray());\n    logger.debug(\"Response Dump: \"+resp);\n    response.setResponseStream(nnew ByteArrayInputStream('resp'.getBytes(\"UTF-8\"));\n    // StringBufferInputStream is deprecated because it does not convert characters into bytes properly. You can use ByteArrayInputStream instead\n  } catch (CommunicationException e) {\n    e.printStackTrace();\n  }\n  \n}\n \n---------------------------------------------------------------------------------\npublic class MyTest {\n  \n  public static void main(String[] args) {\n    \n    List list = new List();\n    list.add(\"MyItemOne\"); // add is used instead of addItem()\n    list.add(\"MyItemTwo\"); \n    list.add(\"MyItemThree\"); \n    \n    list.removeall(); //  removeall is used instead of clear()\n  }\n}\nA violation is reported if a deprecated java entity is used/called by a method, constructor, field or type.\nclass Test\n            {\n                public void funUsingDerecatedField()\n                {\n                    value = 10;\n                }\n                @Deprecated\n                int value;\n            }\n            public class DeprecatedUse {\n                public static void main(String[] args) {\n                      Test obj = new Test();\n            obj.funUsingDeprecatedField(); // VIOLATION as function using a deprecated field is called\n                }\n            }\n\n\nFile_Save_Service.saveFileDialog(null,null,new StringBufferInputStream(\"testing\"),null);\n\n---------------------------------------------------------------------------------------------------\n\npublic class MyTest {\n  \n  public static void main(String[] args) {\n    \n    List list = new List();\n    list.addItem(\"MyItemOne\"); // Violation as addItem is deprecated\n    list.addItem(\"MyItemTwo\"); \n    list.addItem(\"MyItemThree\"); \n    \n    list.clear(); //  Violation as clear() is deprecated\n  }\n}\nNumber of Java Artifacts", "urls": ["https://docs.oracle.com/javase/1.5.0/docs/guide/javadoc/deprecation/deprecation.html", "http://cwe.mitre.org/data/definitions/477.html", "https://wiki.sei.cmu.edu/confluence/display/java/MET02-J.+Do+not+use+deprecated+or+obsolete+classes+or+methods"]}, "7634": {"text": "Hibernate Entity name\nselect-before-update (defaults to false): specifies that Hibernate should never perform an SQL UPDATE unless it is certain that an object is actually modified. Only when a transient object has been associated with a new session using update(), will Hibernate perform an extra SQL SELECT to determine if an UPDATE is actually required.\n\nUse of select-before-update will usually decrease performance. It is useful ONLY to prevent a database update trigger being called unnecessarily if you reattach a graph of detached instances to a Session.\n\nThis rule reports a violation for Hibernate Entity having 'select-before-update' set to true except when it's associated to a table that fires an UPDATE trigger.\nAvoid Hibernate Entity with 'select-before-update' set to true if not associated to table that fires an UPDATE trigger.\nTriggers and object-relational mapping often create issues due to the difficulties of synchronizing the effect of a trigger with the representation of data in memory.\nTo enhance performances, it is a best practice to use the attribute select-before-update for the persistent class associated to a table that have the UPDATE trigger.\nBut if the table is not associated to an UPDATE trigger, then it will affect your performance since the application will perform unnecessary SELECT.\nHibernate in Action (ISBN 1932394-15-X) p 339: https://www.cpe.ku.ac.th/~plw/oop/e_book/hibernate_in_action.pdf\nhttps://docs.jboss.org/hibernate/orm/3.5/reference/en/html/mapping.html\nRemove the attribute select-before-update for the persistent class that is not associated to a table that have the UPDATE trigger.\n---> sample.hbm.xml\n// FIXED\n<class name=\"Sample\" table=\"SAMPLE\">\n...\n</class>\nList all Hibernate Entity that use select-before-update and that are not associated to a table that fires an UPDATE trigger.\n\nIt provides the following information:\n - XML File\n - Hibernate Entity\nSAMPLE is a table not managed by an UPDATE trigger\n---> sample.hbm.xml\n// VIOLATION\n<class name=\"Sample\" table=\"SAMPLE\" select-before-update=\"true\">\n...\n</class>\nNumber of Hibernate XML Entities that have the select-before-update property", "urls": ["https://www.cpe.ku.ac.th/~plw/oop/e_book/hibernate_in_action.pdf", "https://docs.jboss.org/hibernate/orm/3.5/reference/en/html/mapping.html"]}, "8218": {"text": "Number of violation occurrences\nIf getContentType is not called inside the body of a HttpServlet.doPost or HttpServlet.doGet methods a violation will be reported by this rule.\nDEPRECATED: Content type should be checked when receiving a HTTP Post\nThe aim is to check that the content type of a message received in a HTTP POST request. Arbitrary code execution is possible if an uploaded file is interpreted and executed as code by the recipient\n\nThe software allows the attacker to transfer files of dangerous types that can be automatically processed within the product's environment.\n\nInjection flaws, such as SQL, OS, and LDAP injection occur when untrusted data is sent to an interpreter as part of a command or query. The attackers' hostile data can trick the interpreter into executing unintended commands or accessing data without proper authorization.\nhttps://cwe.mitre.org/data/definitions/434.html\nhttps://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/HttpServlet.html\ncheck that the content type of a message received in a HTTP POST and GET request.\nSample 1\n\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\nString strContentType = request.getContentType();\n  if (!strContentType.equals(\"text/xml\"))\n  {\n    //throw error as invalid MIME type and do not continue further\n  }\n}\n---------------------------------------------------------------------------------\nsample 2\nIf the browser doesn't pass content-type correctly,\nif(request.getContentType() == null)\n{\n}\nA violation is reported only if getContentType is not called inside the body of a HttpServlet.doPost or HttpServlet.doGet methods.\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    String firstName = request.getParameter(\"fname\");\n    response.getWriter().append(\"Served at: \").append(request.getContextPath());  \n    //VIOLATION as the request getcontent type is not used to check for the valid type\n  }\n\n@Override\nprotected void mainFlow(UsecaseExecution<TParams, TResult> execution) throws Exception {\n\n    URL url = getUrl();\n\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    connection.setDoOutput(true);\n    connection.setRequestMethod(\"POST\");\n    connection.setRequestProperty(\"Content-Type\", \"application/xml\");\n\n    try {\n\n        InputStream inputStream = connection.getInputStream();\n        InputStreamReader isReader = new InputStreamReader(inputStream, charSet);\n\n       \n        }\n}\n\n------------------------------------------------------------------------------------------------------\n\n@Override\nprotected void mainFlow(UsecaseExecution<TParams, TResult> execution) throws Exception {\n\n    URL url = getUrl();\n\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    connection.setDoOutput(true);\n    connection.setRequestMethod(\"POST\");\n    connection.setRequestProperty(\"Content-Type\", \"application/xml\");\n\n    try {\n\n        String contentType = connection.getContentType();  //Validating Content type.\n\n        String charSet = (contentType != null && contentType.contains(\"charset=\"))\n                ? contentType.substring(contentType.indexOf('=') + 1)\n                : \"UTF-8\";\n\n        InputStream inputStream = connection.getInputStream();\n        InputStreamReader isReader = new InputStreamReader(inputStream, charSet);\n\n       \n        }\n}\nReports if getContentType is not called inside the body of a HttpServlet.doPost or HttpServlet.doGet methods.", "urls": ["https://cwe.mitre.org/data/definitions/434.html", "https://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/HttpServlet.html"]}, "7910": {"text": "When the code has a jump statement inside a finally block, it will cause any thrown exception in the try/catch block to be discarded.\n\nThis rule raises violation when detecting method that contains an abrupt in a finally block. \nAn abrupt completion of a statement or block occurs when it throws an exception, executes a break or continue to an enclosing statement, or executes a return from the method thereby preventing the exception from being thrown to the caller.\nNever exit a finally block with a return, break, continue, or throw statements\nCare must be taken if completion of a try-catch block occurs as a result of executing a return. If a finally block also returns a value, then that return supersedes any previous return in the try-catch block. Also, if an exception was thrown in the try or catch blocks that was not caught, then execution of a return in the finally block prevents the exception from being thrown to the caller (because it is not possible for the caller to simultaneously evaluate the return and catch the exception). This is also valid for break or continue instructions.\nOWASP\nhttp://www.owasp.org/index.php/Return_Inside_Finally_Block\n\nCERT\nhttps://www.securecoding.cert.org/confluence/display/java/ERR04-J.+Do+not+exit+abruptly+from+a+finally+block\n\nPuzzle 36: Indecision from the book \"Java Puzzlers: Traps, Pitfalls, and Corner Cases\"  By Joshua Bloch, Neal Gafter\nhttp://www.javapuzzlers.com/\ntry {\n   ...\n   throw IllegalArgumentException(); // the IllegalArgumentException will be delivered to the caller\n}\nfinally {\n\n  /* ... */\n   \n}\nReports all methods that contain an abrupt exit in a finally block. An abrupt exit of a statement or block occurs when it throws an exception, executes a break or continues to an enclosing statement, or executes a return from the method.\n\nIt provides the following information:\n Method full name\ntry {\n   ...\n   throw IllegalArgumentException(); // the IllegalArgumentException will never be delivered to the caller\n}\nfinally {\n\n  /* ... */\n  return r; // VIOLATION: The finally block will cause the exception to be discarded. \n}\nNumber of methods that have a finally block", "urls": ["http://www.owasp.org/index.php/Return_Inside_Finally_Block", "https://www.securecoding.cert.org/confluence/display/java/ERR04-J.+Do+not+exit+abruptly+from+a+finally+block", "http://www.javapuzzlers.com/"]}, "4568": {"text": "A public instance variable is just an instance variable that is public. That is, you are allowed to use the instance variable from outside the class. \nThis rule reports a violation when Public Instance Variable is detected in source files.\n\nInstance Variables are Non Static Fields.\nDEPRECATED: Avoid declaring Public Instance Variables\nA Public Instance Variable can be accessed by any other Class, therefore its value can be modified at any time, without control by the Class itself. This is contrary to OO Encapsulation concepts.\nEnsure to declare instance variables as 'private' in order to obey Encapsulation.\nChange the Field's visibility or make it Static Final.\nThis report lists all Public and Non Static Fields. It provides the following information: Field full name\npublic class Person {\n    public int age;\n    public String hairColor;\n}\nNumber of Java attributes", "urls": []}, "4616": {"text": "When overriding the 'finalize()' Method, a call to 'super.finalize()' is necessary to ensure disposing system resources.\n\nThis rule report a violation when a method overriding 'finalize()' and not calling 'super.finalize()'.\n'super.finalize()' should be invoked when overriding finalize() method\nThis report lists all Methods overriding 'finalize()' and not calling 'super.finalize()'. It provides the following information: Method full name\nfinalize() method is a pre-defined method in the Object class and it is protected. The purpose of a finalize() method can be overridden for an object to include the cleanup code or to dispose of the system resources that can be done before the object is garbage collected. One of the most important points of finalize method is that it's not automatically chained like constructors. If you are overriding finalize method then it's your responsibility to call finalize() method of the superclass, if you forgot to call then finalize of super class will never be called. so it becomes critical to remember this and provide an opportunity to finalize of super class to perform cleanup\nhttps://javarevisited.blogspot.com/2012/03/finalize-method-in-java-tutorial.html\nhttps://howtodoinjava.com/java/basics/why-not-to-use-finalize-method-in-java\nhttps://cwe.mitre.org/data/definitions/568.html\nReview the Method's definition: Ensure to call 'super.finalize()' at the end, while overriding finalize() method. \nIt's usually recommended to call superclass finalize method in the finally block.\nprotected void finalize()\n{\n  releaseSomeResources();\n  super.finalize();\n}\n\nWe can also add call to super.finalize() in a finally block: \n\nprotected void finalize()throws Throwable\n{try {\n         releaseSomeResources();\n      } catch(Throwable th) {\n           throw th;\n      } finally {  \n         super.finalize();\n}\nprotected void finalize() \n{  \n  SomeSystemResourcesRelease(); //Violation: no call to super.finalize();\n}\n---------------------------------------------------------------------\nprotected void finalize()\n{\n  super.finalize();  // Violation as the call should be done at end of the method\n  SomeSystemResourcesRelease();\n}\nAll methods overriding finalize()", "urls": ["https://javarevisited.blogspot.com/2012/03/finalize-method-in-java-tutorial.html", "https://howtodoinjava.com/java/basics/why-not-to-use-finalize-method-in-java", "https://cwe.mitre.org/data/definitions/568.html"]}, "7636": {"text": "Using the version attribute or timestamp instructs Hibernate that we would like to use an optimistic locking mechanism.\nBut the usage of timestamp is slightly less safe and a little less reliable than a version number. This is because of the following drawbacks of using Timestamp, \n1. The JVM usually doesn\u2019t provide the timestamp with millisecond accuracy.\n2. Hibernate can\u2019t detect 2 concurrent updates that are executed at the same millisecond.\n3. If you scale your application horizontally, you need to keep the timestamp of all instances in sync\n\n\n\nThis rule reports all hibernate entities that use timestamp property instead of version number.\nPrefer using version number instead of timestamp for Hibernate Entity\nIf the Hibernate application is on different systems that are not time-synchronized, the timestamp generated by each system might be different thereby generating improper optimistic lock success or failures.\nIf your timestamp data type doesn't include a daylight saving time attribute, you'll run into problems with Hibernate's automatic versioning. The version property is less problematic for automatic versioning; hence we recommend it.\nHibernate in Action (ISBN 1932394-15-X) p 169 & 391\nUse version attribute as a control.\nRemdiation 1\n<class name=\"Sample\" table=\"SAMPLE\">\n   <id ...../>\n   <version name=\"version\" column=\"VERSION\"/> // FIXED\n...\n</class>\n\n------------------------------------------------\nRemediation 2\n\n@Entity(name = \"Phone\")\npublic static class Phone {\n\n    @Id\n    private Long id;\n\n    @Column(name = \"`number`\")\n    private String number;\n\n    @Version //Fixed\n    private Long version;\n}\nThe metric will list all hibernate entities that use timestamp property instead of version.\n\nIt provides the following information:\n Hibernate Entity\nSample 1\n<class name=\"Sample\" table=\"SAMPLE\">\n   <id ...../>\n   <timestamp name=\"lastUpdated\" column=\"LAST_UPDATED\"/> // VIOLATION\n...\n</class>\n--------------------------------------\nSample 2\n\n//Timestamping is automatically used if you the @Version annotation on a Date or Calendar\n@Entity\npublic class Flight implements Serializable {\n...\n    @Version //Violation\n    public Date getLastUpdate() { ... }\n}\n\nor \n\n@Entity(name = \"Person\")\npublic static class Person {\n\n    @Id\n    private Long id;\n\n    private String firstName;\n\n    private String lastName;\n\n    @Version                    //Violation\n    @Source(value = SourceType.DB)\n    private Date version;\n}\n--------------------------------------------------------------------------------------------\nNumber of Hibernate entities that use version or timestamp property", "urls": []}, "7940": {"text": "The @Remove annotation is used with a method to inform the container that the client no longer needs a session and that the session should be destroyed. This annotation is important, as it is the only way to request the container that the session should end. If the remove method is not used, every stateful bean instance ever created would always have to be timed out to be passivated (if the container implementation supports passivation) and timed out again to be finally destroyed.\n\n\n\nThis rule reports a violation for :\n- Class that defines an instance variable or local variable whose type is a local or remote business interface of a Stateful Session but doesn't invoke the remove method in any of its methods. \n- Class when the Stateful Session Bean doesn't implement the remove method.\n\nNotes\n1- The remove method is defined by the @Remove annotation or remove-method deployment descriptor element on the Stateful Session Bean.\n2- In the case of several EJB instances, there is no guarantee that all EJB instances will be removed. \nWe only check there is at least one call to remove method for the concerned class\nAvoid accumulating Stateful Beans\nSince stateful session beans cannot be pooled and reused like stateless beans, there is a real danger of accumulating too many of them if we don\u2019t have a way to destroy them. Therefore, we have to define a business method for removing the bean instance by the client using the @Remove annotation.\nif not done, and especially in a highly concurrent system, this could have a drastic performance impact. There would be wasted CPU cycles and disk space used in the unnecessary activation/passivation process. This is why it is critical that you remove stateful bean instances when the client is finished with its work instead of relying on the container to destroy them when they time out.\nEJB 3 in Action (ISBN 1-933988-34-7) page 94\nhttp://what-when-how.com/enterprise-javabeans-3/stateful-session-beans-ejb-3/\nThe client should remove the Stateful session bean instance by invoking the method annotated with @Remove.\n@Remote\npublic interface MyRemoteBean {\n    public int aMethod();\n    public void removeMethod();\n}\n\n@Stateful\npublic class MyBean implements MyRemoteBean {\n    ...\n    public int aMethod() {\n        ...\n    }\n\n    @Remove // defining the remove method\n    public void removeMethod() {\n        ...\n    }\n}\n\npublic class Client {\n\n    private static @EJB MyRemoteBean myClientBean;\n\n    public static void main(String[] args) {\n        Client client = new Client(args);\n        client.callServer();\n    }\n\n    public Client(String[] args) {}\n\n    public void callServer() {\n\n        try {\n            int res=myClientBean.aMethod();\n            myClientBean.removeMethod(); // FIXED : Calling the remove method\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n}\nThis report lists all classes that define a variable whose type is a remote or local business interface of a stateful bean and that don't call the remove method.\n\nIt provides the following information:\n     Class Full Name\n@Remote\npublic interface MyRemoteBean {\n    public int aMethod();\n    public void removeMethod();\n}\n\n@Stateful\npublic class MyBean implements MyRemoteBean {\n    ...\n    public int aMethod() {\n        ...\n    }\n\n    @Remove // defining the remove method\n    public void removeMethod() {\n        ...\n    }\n}\n\npublic class Client { // VIOLATION : NOT Calling the remove method\n    \n    @EJB\n    private static MyRemoteBean myClientBean;\n\n    public static void main(String[] args) {\n        Client client = new Client(args);\n        client.callServer();\n    }\n\n    public Client(String[] args) {}\n\n    public void callServer() {\n        try {\n            int res=myClientBean.aMethod();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n}\nNumber of classes that define a variable whose type is a remote or local business interface of a stateful bean", "urls": ["http://what-when-how.com/enterprise-javabeans-3/stateful-session-beans-ejb-3/"]}, "8040": {"text": "Reports all action classes (and parent) fields  (except boolean type and final fields) that are :\n\n- Not referenced directly or indirectly (i.e. the field or a call to a getter) in the validate() method when the Strut Action class implements it (inherited from com.opensymphony.xwork2.Validateable).\n\n- Not referenced in the \"Action class name\"-validation.xml or \"Action class name\"-\"alias\"-validation.xml\n\nIn the case of a Struts Action with parent class:\n- If validation is programmatic through a validate() method, then all the fields must be referenced directly or indirectly in the validate() method and a call to super.validate() in the Struts Action class must be made\n\n- If the validation is declarative, fields must be referenced in \"Parent Action class name\"-validation.xml or \"Parent Action class name\"-\"alias\"-validation.xml\n\nNote that we suppose that any fields (except boolean type and final fields) of the action class must be validated even if they are always used as read-only fields by JSP pages.\nStruts 2: Avoid Action Fields without Validation\nInput validation is required to secure an application. Moreover, the web interface is exposed to anyone. Non validating input may allow injecting arbitrary web script, HTML, SQL... Consequences can be severe, like erasing the content of a database.\nOnly one invalidated input can be exploited by an attacker.\n\nNote that unused fields should be constrained so that they can only be empty or undefined. If unused fields are not validated, shared business logic in an action may allow attackers to bypass the validation checks that are performed for other uses of the form.\nhttps://www.owasp.org/index.php/Improper_Data_Validation#Struts:_Form_Field_Without_Validator\nValidate each field of the action class referenced in the methods of the action class called by the Struts framework. You can do it either by implementing the validate() method of the com.opensymphony.xwork2.ActionSupport class (or com.opensymphony.xwork2.Validateable interface) or by updating the 'Action class'-validation.xml file.\npublic class Register extends ActionSupport {\n  private String username;\n  private String password;\n\n  public String execute(){\n    User user = new User();\n    user.setPassword( getPassword() );\n    user.setUsername( getUsername() );\n    session.put(Constants.USER, user);\n    return SUCCESS;\n  }\n\n  public void validate(){ /* FIXED: the password is referenced in this method */\n    if ( getUsername().length() == 0 ){\n      addFieldError( \"username\", getText(\"username.required\") );\n    }\n\n if ( getPassword().length() == 0 ){\n   addFieldError( \"password\", getText(\"password.required\") );\n    }\n \n    if (getUsers().userExists(getUsername() ) ){\n      addFieldError(\"username\", getText( \"user.exists\"));\n    }\n  }\n}\n\n==> with the validation.xml file:\npublic class Register extends ActionSupport {\n  private String username;\n  private String password; /* FIXED: the password referenced in the Register-validation.xml file (2 times) */ \n\n  public String execute(){\n    User user = new User();\n    user.setPassword( getPassword() );\n    user.setUsername( getUsername() );\n    session.put(Constants.USER, user);\n    return SUCCESS;\n  }\n}\n\nRegister-validation.xml\n<validators>\n  <field name=\"password\">\n      <field-validator type=\"requiredstring\">\n         <message >Password is required.</message>\n      </field-validator>\n      <field-validator type=\"stringlength\">\n         <param name=\"maxLength\">10</param>\n         <param name=\"minLength\">6</param>\n         <message>Your password should be 6-10 characters.</message>\n      </field-validator>\n  </field>\n  <field name=\"username\">\n      <field-validator type=\"requiredstring\">\n           <message >Username is required.</message>\n      </field-validator>\n      <field-validator type=\"stringlength\">\n         <param name=\"maxLength\">8</param>\n         <param name=\"minLength\">5</param>\n         <message>While ${username} is a nice name, a valid username must be between ${minLength} and ${maxLength} characters long. </message>\n     </field-validator>\n  </field>\n  <validator type=\"expression\">\n      <param name=\"expression\">username != password</param>\n      <message>Username and password can't be the same.</message>\n  </validator>\n</validators>\nReport lists all action class (and parent) fields (except boolean type) that are not validated. It provides the following information:\n  Java action class fields\n==> with the validate() method\npublic class Register extends ActionSupport {\n  private String username;\n  private String password; /* VIOLATION: the password is not referenced in the validate() method */\n\n  public String execute(){\n    User user = new User();\n    user.setPassword( getPassword() );\n    user.setUsername( getUsername() );\n    session.put(Constants.USER, user);\n    return SUCCESS;\n  }\n\n  public void validate(){ /* VIOLATION: the password is not referenced in this method */\n    if ( getUsername().length() == 0 ){\n      addFieldError( \"username\", getText(\"username.required\") );\n    }\n    if (getUsers().userExists(getUsername() ) ){\n      addFieldError(\"username\", getText( \"user.exists\"));\n    }\n  }\n}\n\n==> with the validation.xml file:\npublic class Register extends ActionSupport {\n  private String username;\n  private String password; /* VIOLATION: the password is not referenced in Register-validation.xml */\n\n  public String execute(){\n    User user = new User();\n    user.setPassword( getPassword() );\n    user.setUsername( getUsername() );\n    session.put(Constants.USER, user);\n    return SUCCESS;\n  }\n}\n\nRegister-validation.xml\n<validators>\n  <field name=\"username\">\n      <field-validator type=\"requiredstring\">\n           <message >Username is required.</message>\n      </field-validator>\n      <field-validator type=\"stringlength\">\n         <param name=\"maxLength\">8</param>\n         <param name=\"minLength\">5</param>\n         <message>While ${username} is a nice name, a valid username must be between ${minLength} and ${maxLength} characters long. </message>\n     </field-validator>\n  </field>\n</validators>\nNumber of actions class (and parent) fields", "urls": ["https://www.owasp.org/index.php/Improper_Data_Validation#Struts:_Form_Field_Without_Validator"]}, "8016": {"text": "This rule reports all EJB remote methods that are not associated with permission unless this method is defined in the excluded-list (can't be called). \n\nIt works for EJB 3.0 and takes into account both annotation and descriptor specifications.\nAvoid unrestricted access to EJB remote methods\nIf you handle sensitive data or offer restricted services, you need a clearly defined security policy for your application and a framework that enforces it.\n\nWhen an application exposes a remote interface for an entity bean, it might also expose methods that get or set the bean's data. These methods could be leveraged to read sensitive information, or to change data in ways that violate the application's expectations, potentially leading to other vulnerabilities.\n\n\nIt is common to think that EJBs are deployed where they can only be accessed from their related JSPs and servlets, and security is applied at the JSP/servlet layer. But in reality, you can often find situations where the security policy needs to change, for example, the ports to access to the EJB become opened, and the access to these EJB becomes possible.\nhttp://download.oracle.com/docs/cd/E19253-01/817-6087/dgsecure.html\nhttps://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/6.4/html/development_guide/sect-ejb_application_security\nhttps://docs.oracle.com/cd/E19226-01/820-7627/gjgdi/index.html\nAssociate roles to the remote methods of EJB session.\n\n\nException :\nIf you have used programmatic security, then you must check the reason and see if there is a real need.\nIt is strongly discouraged since Programmatic login places the burden on the application developer with respect to assuring that the resulting system meets their security requirements. Programmatic login allows the application developer to bypass the application server-supported authentication mechanisms and feed authentication data directly to the security service. Since this mechanism bypasses the container-managed authentication process and sequence, the application developer must be very careful in making sure that authentication is established before accessing any restricted resources or methods. It is also the application developer's responsibility to verify the status of the login attempt and to alter the behavior of the application accordingly.\n\nHowever, applications may, at some point, need to implement security policies in code. This is the case if you want to apply security policies that depend on the application's business logic. For example: a customer can access only her own account.\n===> ejb-jar.xml version 2.1\n <enterprise-beans>\n    <session>\n      <ejb-name>SecAuthSampleBean</ejb-name>\n      <home>sample.ejb.SecAuthSampleHome</home>\n      <remote>sample.ejb.SecAuthSample</remote>\n      <ejb-class>sample.ejb.SecAuthSampleBean</ejb-class>\n      <session-type>Stateless</session-type>\n      <security-role-ref>\n         [...]\n      </security-role-ref>\n    </session>\n  </enterprise-beans>\n\n  <assembly-descriptor>\n    [...]\n\n    <method-permission>\n      <role-name>Administrator</role-name>\n      <method>\n        <ejb-name>SecAuthSampleBean</ejb-name>\n        // FIXED: methodIsAuthorized is associated to a permission\n        <method-name>methodIsAuthorized</method-name>\n      </method>\n    </method-permission>\n\n    // FIXED: methodIsNotAuthorized is associated to a permission\n    <method-permission>\n      <role-name>SecretRole</role-name>\n      <method>\n        <ejb-name>SecAuthSampleBean</ejb-name>\n        <method-name>methodIsNotAuthorized</method-name>\n      </method>\n    </method-permission>\n\n    <exclude-list>\n      <method>\n        <ejb-name>SecAuthSampleBean</ejb-name>\n         // FIXED: methodIsExcluded can't be called\n        <method-name>methodIsExcluded</method-name>\n      </method>\n    </exclude-list>\n\n  </assembly-descriptor>\n\n</ejb-jar>\n\n\n-----\n\n@Stateless\n\npublic class EmployeeBean implements EmployeeServiceLocal, EmployeeServiceRemote {\n  @PersistenceContext(unitName=\"EmployeeService\") private EntityManager manager;\n  @RolesAllowed(\"Users\")\n  public void doAction(){\n\n    Customer cust = new Customer();\n\n    cust.setLastName(\"Bond\");\n    cust.setSsn(1L);\n    manager.persist(cust);\n    \n    System.out.println(\"Saved\");\n}\n}\nThis report all EJB remote methods (i.e methods of the remote interface and its parent) that are not associated with permission unless this method is defined in the excluded-list. \nIt provides the following information:\n Method Full Name\n===> Java files\n// EJB Remote interface\npublic interface SecAuthSample extends EJBObject {\n    public boolean methodIsAuthorized()        throws RemoteException;\n    public boolean methodIsNotAuthorized()   throws RemoteException;\n    public boolean methodIsExcluded()          throws RemoteException;      \n}\n\n// Session bean\npublic class SecAuthSampleBean implements SessionBean {\n    [...]    \n    public boolean methodIsAuthorized() { [...] }\n    public boolean methodIsNotAuthorized() { [...] }\n    public boolean methodIsExcluded() { [...] }\n}\n\n===> ejb-jar.xml version 2.1\n <enterprise-beans>\n    <session>\n      <ejb-name>SecAuthSampleBean</ejb-name>\n      <home>sample.ejb.SecAuthSampleHome</home>\n      <remote>sample.ejb.SecAuthSample</remote>\n      <ejb-class>sample.ejb.SecAuthSampleBean</ejb-class>\n      <session-type>Stateless</session-type>\n      <security-role-ref>\n         [...]\n      </security-role-ref>\n    </session>\n  </enterprise-beans>\n\n  <assembly-descriptor>\n    [...]\n\n    // VIOLATION methodIsNotAuthorized is permitted to any role (unchecked)\n    <method-permission>\n      <unchecked/>\n      <method>\n        <ejb-name>SecAuthSampleBean</ejb-name>\n        <method-name>methodIsNotAuthorized</method-name>\n      </method>\n    </method-permission>\n\n    <exclude-list>\n      <method>\n        <ejb-name>SecAuthSampleBean</ejb-name>\n        <method-name>methodIsExcluded</method-name>\n      </method>\n    </exclude-list>\n\n  </assembly-descriptor>\n\n</ejb-jar>\n\n\n------\nWhen @PermitAll is used\n\n@Stateless\n\npublic class EmployeeBean implements EmployeeServiceLocal, EmployeeServiceRemote {\n  @PersistenceContext(unitName=\"EmployeeService\") private EntityManager manager;\n  @PermitAll  //Violation\n  public void doAction(){\n\n    Customer cust = new Customer();\n\n    cust.setLastName(\"Bond\");\n    cust.setSsn(1L);\n    manager.persist(cust);\n    \n    System.out.println(\"Saved\");\n}\n}\nNumber of EJB remote methods (i.e methods of the remote interface and its parent)", "urls": ["http://download.oracle.com/docs/cd/E19253-01/817-6087/dgsecure.html", "https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/6.4/html/development_guide/sect-ejb_application_security", "https://docs.oracle.com/cd/E19226-01/820-7627/gjgdi/index.html"]}, "7962": {"text": "Path until the remote called artifact\nThis rules reports violation when detecting one of the following remote call inside a loop at a depth level less than <depth level>:\n* SQL Statement through loop (example: SQL cursor on SQL Server, nested cursors on Oracle)\n* Stored procedure called many times from the client in a loop.\n* EJB3 Session remote method\n\n\n<depth level> is a parameter that can be changed at will.\nAvoid direct or indirect remote calls inside a loop\nHaving a loop body or loop condition that contains a control element that directly or indirectly consumes platform resources (e.g. messaging, sessions, locks, or file descriptors) can make the software perform more slowly. \nSoftware that is coded so as to execute expensive computations repeatedly (such as in loops) requires excessive computational resources when the usage and data volume grow.\n\nIf an attacker can influence the number of iterations in the loop, then this performance problem might allow a denial of service by consuming more platform resources than intended\nPlease refer to  CISQ rule: ASCPEM-PRF-8 : http://www.omg.org/spec/ASCPEM/1.0/PDF\nThe loop execution can be delegated to the server side of the application so that not network latency will occur.\nThis report all remote call inside a loop. \nIt provides the following information:\n - Caller Artifact Full Name that contains the loop\n - path until the remote called artifact\n\nNote that:\n1/ The call path may contains different path while only one is an error. For example:\ng(){myException()}\n f() {\n       while { g ()}\n        g()\n        } \n\nwill report both path to g() while only one is a violation.\n\n2/ 2/ Several paths for the same method violating the rule are identified in the Metric Detail page by a sequence ID (in the Value column), this ID is dynamically set during each snapshot and the same path can have a different sequence ID in different snapshots.\nfor ( i int i=0, children.lengh && CheckNumFiles.ToProcess(), i++){\n     writeObjectToDatabase(children[i])// violation \n}\nNumber of methods calling at least one method inside a loop", "urls": ["http://www.omg.org/spec/ASCPEM/1.0/PDF"]}, "7732": {"text": "JSF supports validators, which are responsible for making sure that the user enters an acceptable value. Each input control must be associated with one or more validators.\n\n\nThis rule checks if the input field in JSP files using JSF (i.e. reference the JSF core taglib) has been validated as expected.\n\nFollowing validation ways supported by JSF are considered by this rule: \nStandard validation, Custom validation, Validation in the backing bean.\n\nThe validation can be done also by using the annotation @FacesValidator in the class during runtime\n\n\n\nAll other ways that consist of making the validation in the application (in the method called when a button is selected like createEmail method in the Example section) is not considered. In this case, a manual check will be needed to validate if the validation is made or not in this way.\nAvoid non validated inputs in JSP files that use JSF\nThe software does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.\n\n\nInput validation is required to secure an application. Moreover, the web interface is exposed to anyone. Non validating input may allow injecting arbitrary web script, HTML, SQL... Consequences can be severe, like erasing the content of a database.\nOnly one invalidated input can be exploited by an attacker.\nJava Server Faces in Action ISBN 1-932394-11-7 p 44\nhttps://www.journaldev.com/7035/jsf-validation-example-tutorial-validator-tag-custom-validator\nhttps://laliluna.com/articles/posts/jsf-validation-error-handling-tutorial.html\nhttps://dzone.com/articles/jsf-validation-tutorial-error\nValidate each input field through one of  the three ways - at the UI component level, via validator methods in backing beans, or in validator classes.\nUI components generally handle simple validation, such as whether a value is required, or validation logic that's specific to the component itself (and therefore not usable with other components).\nValidator methods are useful when you need to validate one or more\nfields on a form (and you don't need to share that logic with other components). External validators are useful for generic cases like the length of a field or a number range; they are pluggable, which means you can attach one or more of them to any component.\n-------------- 1st sample (standard validation) --------------\n\n----> JSP file\n<%@taglib prefix=\"f\" uri=\"http://java.sun.com/jsf/core\"%>\n<%@taglib prefix=\"h\" uri=\"http://java.sun.com/jsf/html\"%>\n\n<h:inputText id=\"age\" value=\"#{UserRegistration.user.age}\">\n          <f:validateLongRange maximum=\"150\" minimum=\"0\"/>\n</h:inputText>\n\n----> jsf_core.tld\n<tag>\n    <name>validateLongRange</name>\n    <tag-class>\n     com.sun.faces.taglib.jsf_core.ValidateLongRangeTag\n    </tag-class>\n...\n\n----> ValidateLongRangeTag.java:\npublic class ValidateLongRangeTag extends com.sun.faces.taglib.jsf_core.MaxMinValidatorTag {\n....\n}\n\n---> MaxMinValidatorTag.java:\npublic class MaxMinValidatorTag extends javax.faces.webapp.ValidatorTag {\n  ...\n}\n\n\n-------------- 2nd sample ( custom validation) --------------\n----> JSP file:\n<%@taglib prefix=\"f\" uri=\"http://java.sun.com/jsf/core\"%>\n<%@taglib prefix=\"h\" uri=\"http://java.sun.com/jsf/html\"%>\n\n<h:inputText id=\"emailInput\"\n               value=\"#{registrationBean.email}/>\n      <f:validator validatorId=\"emailValidator\"/> // FIXED\n</h:inputText>\n\n----> faces-config.xml\n<faces-config>\n  ...\n       <validator>\n            <validator-id>emailValidator</validator-id>\n            <validator-class>com.sample.EmailValidator</validator-class>\n        </validator>\n  ... \n\n</faces-config>\n\n----> EmailValidator.java\npackage com.sample;\n\npublic class EmailValidator implements javax.faces.validator.Validator {\n    ....\n}\n\n\n-------------- 3rd sample ( validation in the backing bean) --------------\n----> JSP file:\n<h:inputText id=\"emailInput\"\n            validator=\"#{registrationBean.validateEmail}\" // FIXED\n            value=\"#{registrationBean.email}/>\n\n----> faces-config.xml\n<faces-config>\n...\n    <managed-bean>\n        <managed-bean-name>registrationBean</managed-bean-name>\n        <managed-bean-class>\n            com.sample.registrationBean\n        </managed-bean-class>\n        <managed-bean-scope>session</managed-bean-scope>\n    </managed-bean> \n...\n</faces-config>\n\n----> RegistrationBean.java\npackage com.sample;\n\n\npublic class RegistrationBean {\n    ...\n    public void validateEmail(FacesContext context, UIComponent validate, Object value){\n       ...\n    }\n}\nThis report lists all input that are not validated. It provides the following information:\n  JSP Input Field Full Name\n----> JSP file (1st sample: standard validation)\n<%@taglib prefix=\"f\" uri=\"http://java.sun.com/jsf/core\"%>\n<%@taglib prefix=\"h\" uri=\"http://java.sun.com/jsf/html\"%>\n\n<h:inputText id=\"age\" value=\"#{UserRegistration.user.age}\"> // VIOLATION\n</h:inputText>\n\n----> JSP file (for 2nd, 3rd and 4th sample)\n<%@taglib prefix=\"f\" uri=\"http://java.sun.com/jsf/core\"%>\n<%@taglib prefix=\"h\" uri=\"http://java.sun.com/jsf/html\"%>\n\n<h:form id=\"create\"> \n     ....\n\n     <h:inputText id=\"emailInput\"\n            value=\"#{registrationBean.email}/> // VIOLATION\n\n     <h:commandButton id=\"submit\" \n                                  value=\"CreateEmail\"\n                                  action=\"#{registrationBean.createEmail}\"/>\n     ....\n</h:form>\n\n---> faces-config.xml\n<faces-config>\n...\n    <managed-bean>\n        <managed-bean-name>registrationBean</managed-bean-name>\n        <managed-bean-class>\n            com.sample.registrationBean\n        </managed-bean-class>\n        <managed-bean-scope>session</managed-bean-scope>\n    </managed-bean> \n...\n</faces-config>\n\n---> RegistrationBean.java\npackage com.sample;\n\npublic class RegistrationBean {\n    ...\n\n    }\n}\nNumber of input fields, 0 if JSF is not used", "urls": ["https://www.journaldev.com/7035/jsf-validation-example-tutorial-validator-tag-custom-validator", "https://laliluna.com/articles/posts/jsf-validation-error-handling-tutorial.html", "https://dzone.com/articles/jsf-validation-tutorial-error", "http://java.sun.com/jsf/core", "http://java.sun.com/jsf/html", "http://java.sun.com/jsf/core", "http://java.sun.com/jsf/html", "http://java.sun.com/jsf/core", "http://java.sun.com/jsf/html", "http://java.sun.com/jsf/core", "http://java.sun.com/jsf/html"]}, "7724": {"text": "Number of violation occurrences\nTo preserve the equality contract, overriden equals() Methods in persistent Subclasses should only reference properties from the persistent base Class\n\nThis rule reports equals() methods of persistent subclasses that involves an attribute or a getter of the subclasses of the persistent base class (subclass or joined-subclass).\nOverriden equals() Methods in persistent Subclasses should only reference properties from the persistent base Class\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nIt's almost never correct to override equals() on a persistant subclass and include properties that do not belong to the persistent base class in the comparison. It's tricky to satisfy the requirements that equality be both symmetric and transitive in this case; and, more important, the business key wouldn't correspond to any well-defined candidate natural key in the database (subclass properties may be mapped to a different table).\nHibernate in Action (ISBN 1932394-15-X) p 125\nhttps://wiki.sei.cmu.edu/confluence/display/java/MET08-J.+Preserve+the+equality+contract+when+overriding+the+equals%28%29+method\nReconsider your business key attributes and use only attributes from the base class.\nRemove the equals() method from Cat and Dog. If necessary, race and color attributes must be moved to the Animal class and be used into the equals() method. They will become a part of the business key.\n----> Java files:\n\npublic class Animal {\n  private Long id;\n  private String name;\n  ...\n  public Long getId() {\n    return this.id;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n...\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof Animal)) return false;\n    final Animal animal = (Animal) o;\n    if (! (this.getName() == animal.getName()) ) return false;\n    return true;\n  }\n}\n\npublic class Dog extends Animal {\n   private String race;\n   ...\n   \n   public String getRace() {\n      return this.race;\n   }\n\n  public String setRace(String race) {\n     this.race = race;\n  }\n\n  public boolean equals(Object o) {  // VIOLATION\n    if (this == o) return true;\n    if (!(o instanceof Dog)) return false;\n    final Dog dog = (Dog) o;\n    if (! (this.getName() == dog.getName())) return false;\n    if (! (this.getRace() == dog.getRace())) return false;\n\n    return true;\n  }\n}\n\npublic class Cat extends Animal {\n   private String color;\n   ...\n   \n   public String getColor() {\n      return this.color;\n   }\n\n  public String setColor(String color) {\n     this.color = color;\n  }\n\n  public boolean equals(Object o) {  // VIOLATION\n    if (this == o) return true;\n    if (!(o instanceof Cat)) return false;\n    final Cat cat = (Cat) o;\n    if (! (this.getName() == cat.getName())) return false;\n    if (! (this.getColor() == cat.getColor())) return false;\n\n    return true;\n  }\n}\n\n----> animal.hbm.xml\n<class name=\"Animal\" table=\"animal\">\n    <id name=\"id\" type=\"long\" column=\"animal_id\">\n        <generator class=\"native\"/>\n    </id>\n    <discriminator column=\"type\" type=\"string\"/>\n    <property name=\"name\" column=\"name\"/>\n    ...\n    <subclass name=\"Dog\" discriminator-value=\"DOG\">\n        <property name=\"race\" column=\"race\"/>\n        ...\n    </subclass>\n    <subclass name=\"Cat\" discriminator-value=\"CAT\">\n        <property name=\"color\" column=\"color\"/>\n        ...\n    </subclass>\n</class>\nNumber of persistent subclasses (subclass or joined-subclass) that override the equals method", "urls": ["https://wiki.sei.cmu.edu/confluence/display/java/MET08-J.+Preserve+the+equality+contract+when+overriding+the+equals%28%29+method"]}, "7722": {"text": "Number of violation occurrences\nThis rule reports all the equals() methods of a persistent class that refer to the persistence class's identifier (through the identifier attribute or the identifier getter). \n\nNote that the case where the equals method is implemented on a parent class and reference the id is taken into account too.\nAvoid using persistent class's identifier in equals() method\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nSince the programmer can define the meaning of Java Equality, it is important not to use the id field in this definition if the id field is a surrogate key. This is because Hibernate only sets the field when saving the object. Hence, for example, if you add the object to some set collection, then saving the object will result in its identity changing, and part of the rules about using Set/Map collection class is that the contained object's identity must not change while it is in the collection (the behavior of a set is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is an element in the set.\nHibernate in Action (ISBN 1932394-15-X) p 123, Java Persistence with Hibernate (ISBN 1-932394-88-5) 397, \nhttp://www.ideyatech.com/2011/04/effective-java-equals-and-hashcode\nhttps://medium.com/@MichaelMuller/hibernate-fix-avoid-referencing-the-id-in-the-persistent-classs-equals-151e08f745bd\nImplement your equals() and hashCode() methods based on business keys. In cases where the business key is composite, you can use  the Jakarta Commons libraries - in particular the EqualsBuilder and HashCodeBuilder classes. It may be that your class is not an @Entity, but a value object (@Embeddable) instead and perhaps the entity needs to be modelled in a different way.\n\nCould be added - \nBusiness key equality means that the equals() method compares only the properties that form the business key. It is a key that would identify our instance in the real world (a natural candidate key)\n------> Sample.java:\npublic class Sample {\n   private long id;\n   private String name;\n   ...\n   public String getName() {\n      return name;\n   }\n\n   public Long getId() {\n      return id;\n   }\n\n    public boolean equals(Object other) {\n        if (this==other) return true;\n        if ( !(other instanceof Sample) ) return false;\n        final Sample that = (Sample) other;\n        return this.getName().equals( that.getName()); // FIXED\n    }\n}\n------> sample.hbm.xml:\n...\n<class name=\"Sample\" table=\"SAMPLE\">\n           <id name=\"id\" column=\"id\" type=\"long\">\n                  <generator class=\"sequence\"/>\n           </id>\n           <property name=\"name\" column=\"NAME\" type=\"string\"/>\n...\n</class>\n\n------> Sample.java:\npublic class Sample {\n   private long id;\n   private String name;\n...\n   public String getName() {\n      return name;\n   }\n\n   public Long getId() {\n      return id;\n   }\n\n    public boolean equals(Object other) {\n        if (this==other) return true;\n        if ( !(other instanceof Sample) ) return false;\n        final Sample that = (Sample) other;\n        return this.getId().equals( that.getId()); // VIOLATION\n    }\n}\nTotal number of equals() methods in persistent classes", "urls": ["http://www.ideyatech.com/2011/04/effective-java-equals-and-hashcode", "https://medium.com/@MichaelMuller/hibernate-fix-avoid-referencing-the-id-in-the-persistent-classs-equals-151e08f745bd"]}, "7506": {"text": "This rule reports all hibernate and/or JPA persistent classes associated with a component (component and composite-element) declared in the mapping file or through annotation (@Embeddable and @IdClass) and that don't implement equals() and hashCode().\nequals() and hashCode() should be defined for Hibernate/JPA component\nPersistent classes do not have an identifier property. You must implement equals() and hashCode(). Hibernate or JPA implementation relies on this equality routine to check instances for modifications.\n\nA custom implementation of equals() and hashCode() is not required for all component classes. However, it is recommended for any persistent class because the implementation is straightforward and safer.\nhttp://docs.jboss.org/hibernate/core/3.3/reference/en/html/components.html\nHibernate in Action (ISBN 1932394-15-X) p 217\nThe Java Persistence API page 252 - ISBN 1-932394-88-5\nImplement equals() and hashCode().\n----> B.java\npublic class B {\n  private long id;\n  private String name;\n  ...\n\n  private void setId(long id) { \n    this.id = id;\n  }\n\n  public long getId() {\n    return id;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public Sring getName() {\n    return name;\n  }\n\n\n  ...\n\n  // FIXED\n  public boolean equals(Object obj) {\n    ...\n  }\n\n  // FIXED\n  public int hashCode() {\n     ...\n  }\n}\nList all Hibernate and/or JPA persistent classes associated to a component (component and composite-element) declared in the mapping file or through annotation (@Embeddable/@IdClass) and that do not implement equals() and hashCode().\n\nIt provides the following information:\n- Class Full Name\n----> a.hbm.xml\n<hibernate-mapping >\n  \n  <class name=\"A\" table =\"A\"> \n    <id name=\"id\" column=\"A_ID\">\n      <generator class=\"increment\"/>\n    </id>\n\n    <set name=\"B_items\" lazy=\"true\" table =\"B_ITEMS\"> \n      <key column=\"B_ID\"/>\n      <composite-element class=\"B\"/>\n        <property name=\"name\" column=\"B_NAME\" not-null=\"true\"/>\n        ...\n      </composite-element>\n    </set>\n  </class>\n\n</hibernate-mapping>\n\n----> B.java\npublic class B {\n  private long id;\n  private String name;\n  ...\n\n  private void setId(long id) { \n    this.id = id;\n  }\n\n  public long getId() {\n    return id;\n  }\n \n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public Sring getName() {\n    return name;\n  }\n\n  ...\n  // VIOLATION: equals and hashCode are not defined\n}\nNumber of classes associated to a component (component and composite-element or @Embeddable/@IdClass)", "urls": ["http://docs.jboss.org/hibernate/core/3.3/reference/en/html/components.html"]}, "7502": {"text": "Using array  to map a collection can affect your application performance when it can contain many items, it looses lazy loading, optimized dirty checking and performance features for persistent collections.\n\nThis rule reports Hibernate Entities that use array to map a collection.\nNever use an array to map Hibernate collection\nHibernate supports array usage: the details of an array mapping are virtually identical to those of a list. However, we very strongly recommend against the use of arrays, since arrays can't be lazily initialized: there is no way to proxy an array at the virtual machine level.\n\nLists, maps, and sets are the most efficient collection types.\n\nEven in cases where we need to retain order, we use java.util.List because the size of the array can not grow dynamically but it can grow dynamically in the case of List. Arrays cant be lazily initialized. The idea of disabling proxies or lazy loading is considered a bad practice in Hibernate. It can result in a lot of data being fetched from a database and stored in a memory, irrespective of the need for it.\nHibernate in Action (ISBN 1932394-15-X) p 214\nhttp://srcrr.com/java/hibernate/3.6.2/reference/org/hibernate/collection/PersistentArrayHolder.html\nUse lists, maps, bags, idbags and sets depending on your case.\n<hibernate-mapping >\n  \n  <class name=\"A\" table =\"A\"> \n    <id name=\"id\">\n      <generator class=\"increment\"/>\n    </id>\n\n    // FIXED with a list (it could have been set, map, idbag or bag)\n    <list name=\"Bitems\" cascade=\"all\" fetch=\"join\"> \n      <key column=\"B_ID\"/>\n      <list-index column=\"ID\"/>\n      <one-to-many class=\"B\"/>\n    </array>\n  </class>\n\n  <class name=\"B\" table=\"B\" lazy=\"true\">\n    <id name=\"id\" column=\"B_ID\">\n      <generator class=\"increment\"/>\n    </id>\n  </class>\n\n</hibernate-mapping>\nList all Hibernate Entities that use array to map a collection.\n\nIt provides the following information:\n Hibernate Entity Full Name\n<hibernate-mapping >\n  \n  <class name=\"A\" table =\"A\">\n    <id name=\"id\" column=\"A_ID\">\n      <generator class=\"increment\"/>\n    </id>\n     <array name=\"Bitems\" cascade=\"all\" fetch=\"join\"> // VIOLATION\n      <key column=\"A_ID\"/>\n      <one-to-many class=\"B\"/>\n    </array>\n  </class>\n\n  <class name=\"B\" table=\"B\" lazy=\"true\">\n    <id name=\"id\" column=\"B_ID\">\n      <generator class=\"increment\"/>\n    </id>\n  </class>\n\n</hibernate-mapping\nNumber of Hibernate entities that map a collection that could be: array, map, list, set, bag or idbag", "urls": ["http://srcrr.com/java/hibernate/3.6.2/reference/org/hibernate/collection/PersistentArrayHolder.html"]}, "7488": {"text": "Field Name\nThis rule reports all collection association (set, list, bag, idbag, map) that don't use lazy fetching strategy. This strategy is set through the lazy property set to \"true\".\nLazy fetching should be used for Hibernate collection\nIn a lazy association, the associated object or collection is fetched when it's first accessed. This results in a new request to the database (unless the associated object is cached). This option is almost always used for collection mappings (it should be the default, and we recommend that you consider it as a default for all your collection mappings). Generally, the performance benefits are such that you will want to use lazy instantiation wherever possible (compared with the massive task of reading in all of the entities concerned)\n\nWhen eager fetching is used, the associated object or collection is fetched together with the owning object, using an SQL outer join, and no further database request is required. But the issue is that it will always be done like this and if the number of rows is high, the performance will be affected.\nHibernate in Action (ISBN 1932394-15-X) p 148\nhttps://thoughts-on-java.org/entity-mappings-introduction-jpa-fetchtypes/\nhttps://howtodoinjava.com/hibernate/lazy-loading-in-hibernate/\nYou need to make sure to use the right FetchType for your use case to avoid common Hibernate performance issues. For most use cases, the FetchType.LAZY is a good choice.\n\nEAGER fetching tells Hibernate to get the related entities with the initial query. This can be very efficient because all entities are fetched with only one query. But in most cases it just creates a huge overhead because you select entities you don\u2019t need in your use case.\n\nYou can prevent this with FetchType.LAZY. This tells Hibernate to delay the initialization of the relationship until you access it in your business code. The drawback of this approach is that Hibernate needs to execute an additional query to initialize each relationship.\n<hibernate-mapping >\n  \n  <class name=\"A\" table =\"A\"> \n    <id name=\"id\">\n      <generator class=\"increment\"/>\n    </id>\n\n    // FIXED\n    <set name=\"b_items\" lazy=\"true\" table =\"B\"> \n      <key column=\"B_ID\"/>\n      <one-to-many class=\"B\"/>\n    </array>\n  </class>\n\n</hibernate-mapping>\n\nRemediation sample for Sample-2 (annotation)\n\n@Entity\n@Table(name = \"USER\")\npublic class UserLazy implements Serializable { \n    @Id\n    @GeneratedValue\n    @Column(name = \"USER_ID\")\n    private Long userId;\n \n    @OneToMany(fetch = FetchType.LAZY, mappedBy = \"user\")  //FIXED\n    private Set<OrderDetail> orderDetail = new HashSet();\n    //standard getters and setters\n}\nList all Hibernate Entity Property and JPA Entity Property of type collection that does not use lazy fetching.\n\nIt provides the following information:\n Hibernate Entity Property Full Name or JPA Entity Property Full Name\n<hibernate-mapping >\n  \n  <class name=\"A\" table =\"A\"> \n    <id name=\"id\">\n      <generator class=\"increment\"/>\n    </id>\n\n    // VIOLATION \n    <set name=\"b_items\" lazy=\"false\" table =\"B\"> \n      <key column=\"B_ID\"/>\n      <one-to-many class=\"B\"/>\n    </array>\n  </class>\n\n</hibernate-mapping>\n\nSample-2 Using annotations\n\n@Entity\n@Table(name = \"USER\")\npublic class UserLazy implements Serializable { \n    @Id\n    @GeneratedValue\n    @Column(name = \"USER_ID\")\n    private Long userId;\n \n    @OneToMany(fetch = FetchType.EAGER, mappedBy = \"user\")  //VIOLATION\n    private Set<OrderDetail> orderDetail = new HashSet();\n    //standard getters and setters\n}\nNumber of Hibernate entity properties or JPA entity properties of type collection", "urls": ["https://thoughts-on-java.org/entity-mappings-introduction-jpa-fetchtypes/", "https://howtodoinjava.com/hibernate/lazy-loading-in-hibernate/"]}, "7440": {"text": "Method overridden\nThis rule reports \n- Methods in an inheritance tree that have the same signature but whose name differs only by capitalization \n- Methods that have the same name but are overridden with a different signature (this signature doesn't exist in the super class) \n\nFollowing restrictions are considered : \n- Where the class implements an interface, if one method with the same signature exists in the class then no violation will be reported even if other methods exist with different signatures.\n\n- Where the class extends another class, a violation is reported for a method only when the number of parameters are the same and one of the parameters of the signature of the child class method inherits from a parameter in the same place as the parent class method with the same name.\nAvoid having suspicious similar method names or signatures in an inheritance tree\nWhen programming it is very easy to make a mistake when naming a method to override or in its signature. This may occur when writing the inherited class, but also when changing the signature of the basic class to add a new parameter or when changing the type of a parameter. One of the more typical examples is the overriding of equals methods with an argument type that is different from the Object class.\nhttps://dzone.com/articles/all-about-overriding-in-java\nhttps://www.java67.com/2012/09/what-is-rules-of-overloading-and-overriding-in-java.html\nFix the name of the method or the signature and if you use JSE 5.0 or later add the @Override annotation to inform the compiler that the method is meant to override a method declared in a superclass. If the method marked with @Override fails to correctly override a method in one of its superclasses, the compiler generates an error.\nclass Example {\n   int firstMethod (String str) {...}\n   void secondMethod (int value, boolean b) {...}\n}\n\nclass ExampleExtended extends Example{\n   @Override     // only for JSE 5 or later\n   int firstMethod (String str) {...}  // FIXED\n\n   @Override     // only for JSE 5 or later\n   void secondMethod (int value, boolean b) {...} // FIXED\n}\nThis report lists all methods that override a similar method name or signature. It provides the following information:\n  - Method full name\n  - Method overridden\n\n\nTotal Population - Number of methods that override a method from a superclass or\n                    + Number of methods having suspicious names\nclass Example {\n   int firstMethod (String str) {...}\n   void secondMethod (int value, boolean b) {...}\n}\n\nclass ExampleExtended extends Example{\n   int firstmethod (String str) {...}  // VIOLATION because of 'm' that is not in uppercase as the parent class method\n   void secondMethod (int value) {...} // VIOLATION\n}\nMethods that override a method from a superclass and Methods having suspicious names", "urls": ["https://dzone.com/articles/all-about-overriding-in-java", "https://www.java67.com/2012/09/what-is-rules-of-overloading-and-overriding-in-java.html"]}, "7154": {"text": "Field name\nStruts action classes are not thread-safe. You should not place any fields which are not static final in the class.\nThis rule reports fields that are not static final in classes that inherit from the class org.apache.struts.action.Action\nStruts1: Avoid Struts Fields in Action Classes that are not final static\nAvoid instance/non final static field in Action Class\n- Instance and static field should not be used in an Action class to store information related to the state of a particular request.\nThe same instance of an Action class can be shared among multiple simultaneous requests through multi-threading\n- Instance/static field may, however, be used to share global resources across requests for the same action.\nThe use of fields within an Action class creates a security breach as this object is shared among multiple sessions and thus can lead to confidential data leaks\nhttps://cwiki.apache.org/confluence/display/STRUTS1/StrutsWhyOnlyOneInstanceOfActionClass\nChange the design of your Action class implementation if the field is not used to share global resources across requests for the same action. You should use local variables inside your methods, and pass whatever data you need to other methods in the class via parameters.  Because local variables and method parameters exist once per *thread* instead of once per *instance*, so there is no problem in using them to store the state for a particular request.\nPublic class BaseApplicationAction extends Action\n{\n// FIXED\npublic ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception\n[...]\n}\nThis report lists all fields which are not final static in Action classes:\nIt provides the following information:\n - Action Class\n - Field name\nPublic class BaseApplicationAction extends Action\n{\nstatic int StaticField; // VIOLATION\nlong Id;                     // VIOLATION\n\npublic ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception\n[...]\n}\nNumber of fields in Action classes", "urls": ["https://cwiki.apache.org/confluence/display/STRUTS1/StrutsWhyOnlyOneInstanceOfActionClass"]}, "7140": {"text": "JSP page name\nThe code at one architectural layer invokes code that resides at a deeper layer than the adjacent layer, i.e., the invocation skips at least one layer, and the invoked code is not part of a vertical utility layer that can be referenced from any horizontal layer\n\nThis rule checks all action class (and parent classes) that are referenced in the struts-config.xml through the tag 'action-mapping' (in struts 1.x) or in struts.xml and its included files through the tag 'action' (in struts 2.x), and artifacts that refers to JSP pages will be reported.\nStruts Action artifacts should not directly call a JSP page\n- The Action classes are almost totally independent of the names of the presentation pages. The pages can be renamed (for example) during a redesign, with negligible impact on the Action classes themselves. If the names of the \"next\" pages were hard coded into the Action classes, all of these classes would also need to be modified.\n- If Struts tags are used, then if a reference to a JSP page is directly made,  the behaviour of the Struts tags may become unpredictable. This because the ActionServlet or FilterDispatcher in Struts intercepts the request and provides appropriate attributes such as Message Resource Bundles and also FormBeans.\n\nThe code at one architectural layer invokes code that resides at a deeper layer than the adjacent layer, i.e., the invocation skips at least one layer, and the invoked code is not part of a vertical utility layer that can be referenced from any horizontal layer.\nUse the action mapping table in struts configuration file.\n----> TestAction.java:\npublic class TestAction extends Action {\n  public ActionForward execute(\n    ActionMapping mapping,\n    ActionForm form,\n    HttpServletRequest request,\n    HttpServletResponse response) throws Exception {\n    return mapping.findForward(\"mypage\"); // FIXED\n  }\n}\n\n----> struts-config.xml:\n  <action\n      path=\"/mypage\" type=\"com.cast.TestAction\">\n      <forward name=\"mypage\" path=\"/pages/myPage.jsp\"/>\n   </action>\nThis report lists all Action artifacts calling a JSP pages.\nIt provides the following information:\n- Artifact full name\n- JSP page name\npublic class TestAction extends Action {\n  public ActionForward execute(\n    ActionMapping mapping,\n    ActionForm form,\n    HttpServletRequest request,\n    HttpServletResponse response) throws Exception {\n    return new ActionForward(\"/myPage.jsp\"); // VIOLATION\n  }\n}\nNumber of artifacts of classes and parent classes that are referenced as an action in the XML configuration file(s)", "urls": []}, "7720": {"text": "Number of EJB\nThis reports a violation when the number of EJB beans ( Entity Java Bean, Session Java Bean , Message Driven Java Bean) defined in the application (ejb-jar.xml or annotation) is greater than 500. \nThis number can be changed as will through the threshold parameter.\n\nThe consequences of having too many beans are typically increased time and complexity during development, and suboptimal system functioning.\nDEPRECATED: Avoid too many EJB beans\nThis reports a violation when the number of EJB is greater than 500 Or the threshold.\nIt provides the following information:\n - Application\n - Number of EJB\nWhen too many EJB beans are created, the application performance can be poor because most of the functionalities will be run through a session (which means that the EJB container intercepts and processes many more method calls). Also, the application server itself may not perform as well because of the additional resources required to deploy and pool instances for many sessions.\nIn addition, there is more development effort due to all the session-related artifacts.\nWiley - J2EE AntiPatterns (ISBN: 0-471-14615-3) P 366\nReview the design of your application to decrease this number.\nThere are a large number of sessions defined, for example more than 50. A typical enterprise application can expect at most 20 to 30 sessions.\n!", "urls": []}, "7438": {"text": "The implementation of the singleton pattern may not be thread-safe: If several calls were made into this method from a multi-threaded program, you could end up creating multiple instances of the class, and also mess up seriously since the system expects to have only one instance.\n\nThe problem takes place where you check if the instance is null.  \nThis rule reports singleton that initialize the static field that refer to the single instance in a non synchronized method.\n\nA singleton is defined as:\n- a class with a static member with the same type or parent type (extended or implemented) as the class\n- a static method that refers the instance and return an object of same type or a parent type (extended or implemented)\n- a class that has only private constructors\nAvoid non thread safe singleton\nThe code contains a function or method that operates in a multi-threaded environment but owns an unsafe non-final static storable or member data element. This issue can prevent the software from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n\nThe software uses the singleton pattern when creating a resource within a multithreaded environment that may not be thread-safe.\nhttp://tekpool.wordpress.com/2006/10/27/singleton-pattern-part-2-thread-safe-implemenation/\nhttps://javarevisited.blogspot.com/2014/05/double-checked-locking-on-singleton-in-java.html\nTo remediate to this issue (in case of multi-threaded environment), there is two solutions:\n- Declare the field that hold the unique instance as static final and initialize it in the declaration\n- Synchronize the method that initialize the field\n1/ declare a static final field\nclass Singleton\n{\n  private static final Singleton instance = new Singleton(); // FIXED\n  private Singleton() {}\n  public static Singleton getInstance() { \n    return instance;\n  }\n}\n\n2/ synchronize the method\nclass Singleton\n{\n  private static Singleton instance;\n  private Singleton() {}\n  public static synchronized Singleton getInstance() { \n    if (instance == null)              \n      instance = new Singleton();\n    return instance;\n  }\n\n#3 Using Enum\n\npublic enum Singleton{\n    INSTANCE;\n \n    public void show(){\n        System.out.println(\"Singleton using Enum in Java\");\n    }\n}\n//You can access this Singleton as Singleton.INSTANCE and call any method like below\nSingleton.INSTANCE.show()\n\n#4. Double checked Locking:\nIt is throwing false violation in this case, it is remediation , should not be considered as a violation.\nPlease check https://jira.castsoftware.com/browse/JFAMILY-1716 for false violation\n\nclass DoubleCheckedLockingSingleton {\n\n    private static volatile DoubleCheckedLockingSingleton instance;\n\n    private DoubleCheckedLockingSingleton() {\n    }\n\n    public static DoubleCheckedLockingSingleton getInstance() {\n        if (instance == null) {\n            synchronized (DoubleCheckedLockingSingleton.class) {\n                if (instance == null) {\n                    instance = new DoubleCheckedLockingSingleton();\n                    System.out.println(\"Instance Created\");\n                }\n            }\n\n        }\n        return instance;\n    }\n\n}\nThe metric will list all singleton classes that are not thread safe.\nclass Singleton\n{\n  private static Singleton instance;\n  private Singleton() {}\n  public static Singleton getInstance() { \n    if (instance == null)                    // VIOLATION\n      instance = new Singleton();\n    return instance;\n  }\n}\nNumber of singleton classes (as defined in the definition)", "urls": ["http://tekpool.wordpress.com/2006/10/27/singleton-pattern-part-2-thread-safe-implemenation/", "https://javarevisited.blogspot.com/2014/05/double-checked-locking-on-singleton-in-java.html", "https://jira.castsoftware.com/browse/JFAMILY-1716"]}, "7416": {"text": "Number of violation occurrences\nThis metric reports all forms with fields that are not validated. Forms taken into account are forms defined as form-bean in the struts-config.xml (it can be a regular form bean or a dynamic form bean).\n\nNote that: \n1- In the case where the form is shared among multiple actions, the validation declaration of the form will be associated to the action.\nNote that in a case of a dynamic form-bean, the fields are declared in the struts-config.xml while the fields of regular form-bean are defined in the implementation class itself and deduced from the setters of the class.\n\n2- When the form bean is associated to several form validator. In this case, a field will be considered as validated when all form validator validate this field. This case may happen when the validator form is associated to action mapping or when internationalization is used.\n\n3- When a form bean is not associated to any validator form all its fields or setter methods will be reported.\n\n\nThis rule is only for Struts1 based application.\nStruts1: Avoid Action Form Field without Validator\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nInput validation is required to secure an application. Moreover, the web interface is exposed to anyone. Non validating input may allow injecting arbitrary web script, HTML, SQL... Consequences can be severe, like erasing the content of a database.\nOnly one invalidated input can be exploited by an attacker.\n\nNote that unused fields should be constrained so that they can only be empty or undefined. If unused fields are not validated, shared business logic in an action may allow attackers to bypass the validation checks that are performed for other uses of the form.\nhttp://cwe.mitre.org/data/definitions/105.html\nhttps://www.owasp.org/index.php/Improper_Data_Validation#Struts:_Form_Field_Without_Validator\nValidate each field of a form. When a form is shared among different action, you have to use the type org.apache.struts.validator.DynaValidatorActionForm for your Form Bean definition in the struts-config.xml file to be able to define a specific validation for each action.\n----> validation.xml:\n\n<form-validation>\n  <formset>\n    <form name=\"logonForm\">\n      <field property=\"username\" \n            depends=\"required\">\n        <arg0 key=\"prompt.username\"/>\n      </field>\n      <field property=\"password\" // FIXED\n            depends=\"required\">\n        <arg0 key=\"prompt.password\"/>\n      </field>\n    </form>\n  </formset>\n</form-validation>\n====>  For concrete Form Bean\n\n--> logonForm.java (for concrete Form Bean) :\npublic class LogonForm extends ValidatorForm {\n  private String username;\n  private String password;\n  \n  public String getUsername() {\n    return username;\n  }\n  \n  public void setUsername(String username) {\n    this.username = username;\n  }\n\n  public String getPassword() {\n    return password;\n  }\n\npublic void setPassword(String password) {\n    this.password = password;\n  }\n}\n\n--> struts-config.xml (for concrete Form Bean)\n<form-beans>\n  <form-bean name=\"logonForm\"\n            type=\"com.cast.struts.sample.LogonForm\"/>\n</form-beans>\n\n====>  for dynamic Form Bean\n--> struts-config.xml (for dynamic Form Bean)\n<form-beans>\n  <form-bean name=\"logonForm\"\n            type=\"org.apache\n.struts.validator.DynaValidatorForm\">\n    <form-property name=\"username\"\n            type=\"java.lang.String\"/>\n    <form-property name=\"password\"\n            type=\"java.lang.String\"/>\n  </form-bean>\n</form-beans>\n\n====>  for both dynamic and concrete Form Bean\n\n--> validation.xml:\n\n<form-validation>\n  <formset>\n    <form name=\"logonForm\"> // VIOLATION: password field is not validated\n      <field property=\"username\" \n            depends=\"required\">\n        <arg0 key=\"prompt.username\"/>\n      </field>\n    </form>\n  </formset>\n</form-validation>\nNumber of form fields or Java setter methods, when defined with struts or 0 if no object of type \"Struts Configuration File\" is present", "urls": ["http://cwe.mitre.org/data/definitions/105.html", "https://www.owasp.org/index.php/Improper_Data_Validation#Struts:_Form_Field_Without_Validator"]}, "7492": {"text": "Number of many-to-many association\nThis rule reports all Hibernate or JPA Entities that use many-to-many association.\nAvoid Hibernate and JPA Entities using many-to-many association.\nOne-to-many associations are easily the most important kind of association. In fact, its usage is discouraged when a simple bidirectional many-to-one/one-to-many will do the job. In particular, a many-to-many association may always be represented as two many-to-one associations to an intervening class. This model is usually more easily extensible. In a real system, you may not have a many-to-many association. Usually there is almost always other information that must be attached to each link between associated instances (such as the date and time when an item was added to a category) and that the best way to represent this information is via an intermediate association class.\n\nMoreover, changing the definition of a primary key and all foreign keys that refer to it is a frustrating task.\nHibernate in Action (ISBN 1932394-15-X) p 220\nIn Hibernate, you can map the association class as an entity and map two one-to-many associations for either side.\nList all Hibernate or JPA Entities that use many-to-many association.\n\nIt provides the following information:\n - Hibernate or JPA Entity Full Name\n - Number of many-to-many association\n<class name=\"A\" table=\"A\"> \n    ...  \n    <set name=\"B\" table=\"B\">  \n        <key column=\"A_ID\"/> \n        <many-to-many column=\"B_ID\" class=\"B\"/> // VIOLATION\n    </set> \n</class>\nNumber of hibernate or JPA entity that are associated to other entity through one-to-many, many-to-one, one-to-one and many-to-many", "urls": []}, "4576": {"text": "Each private field should have a setter and a getter except final static fields. \n\n\nAccessors are identified using the following java bean naming conventions: \"set\" and \"get\" followed by the name of the field with the first char in uppercase (case sensitive). For Boolean fields, the getter can also be named \"is\" followed by the name of the field. \n\nMethods not using this naming convention are not considered as accessors.\nDEPRECATED: Provide accessors to Private Fields\nThis report lists all Private Fields that do not have a setter and a getter. It provides the following information: Field full name\nTo respect OO encapsulation concepts, private fields should always be accessed through accessors. \n\nThe only exception is injected fields of classes which are managed by a framework (CDI, JSF). In that case, a setter is not required, since the field content will be set directly by the injection framework.\nhttp://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html\nJavaBeans(TM) Specification 1.01 Final Release - paragraph 8.3 Design Patterns for Properties p 55\nWrite a getter and setter to each private field\nNumber of private java class fields.", "urls": ["http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html"]}, "7494": {"text": "This rule reports all Hibernate or JPA persistent class method's equals() and hashCode() that directly access its own fields without using getter methods.\nWe consider also the case where equals and hashCode are implemented on an inherited class of the persistent class (this can happen when inherited fields are persistent).\nPersistent class method's equals() and hashCode() must access its fields through getter methods\nThis is important, since the object instance passed as other might be a proxy object, not the actual instance that holds the persistent state. This is the case when there are lazy associations between classes. This is one point where Hibernate is not completely transparent, but it's good practice to use accessor methods instead of direct instance variable access: when tuning the performance of the application, a lazy association might be required and the issue can occur.\n\nThis potential issue raises a ClassCastException and can cause the application to become unstable.\nHibernate in Action (ISBN 1932394-15-X) p 125, Java Persistence with Hibernate (ISBN 1-932394-88-5) p 400, The Java Persistence API page 400 - ISBN 1-932394-88-5\nUse the getter instead.\npublic class PersitentSample implements Serializable {\n   \n     private Long id;\n     private String field;\n\n   \n    public Long getId() {\n        return id;\n    }\n\n    private void setId(Long id) {\n        this.id = id;\n    }\n    \n    public String getField() {\n        return field;\n    }\n    \n    public void setField(String field) {\n        this.field = field;\n    }\n               \n    public boolean equals(Object obj) {\n         if (this==obj)\n            return true;\n        if (obj==null)\n            return false;\n        if (obj.getClass() != this.getClass())\n            return false;\n        final PersitentSample o = (PersitentSample) obj;\n        return this.getField().equals(o.getField());  // FIXED\n    }\n   \n    public int hashCode() {\n        return getField().hashCode();                    // FIXED\n    }\n}\nList all equals or hashCode methods of persistent classes that rely on the fields (persistent or not). It provides the following information: Method Full Name\npublic class PersitentSample implements Serializable {\n   \n     private Long id;\n     private String field;\n\n   \n    public Long getId() {\n        return id;\n    }\n\n    private void setId(Long id) {\n        this.id = id;\n    }\n    \n    public String getField() {\n        return field;\n    }\n    \n    public void setField(String field) {\n        this.field = field;\n    }\n               \n    public boolean equals(Object obj) {\n         if (this==obj)\n            return true;\n        if (id==null)\n            return false;\n        if (obj.getClass() != this.getClass()) return false;\n        final PersitentSample o = (PersitentSample) obj;\n        return this.field.equals(o.getField());  // VIOLATION\n    }\n   \n    public int hashCode() {\n        return field.hashCode();                     // VIOLATION\n    }\n}\nNumber of equals() and hashCode() methods implemented by Hibernate or JPA persistent classes or by classes that reference persistent fields.", "urls": []}, "7372": {"text": "When an application does not use an input validation framework such as the Struts Validator, there is a greater risk of introducing weaknesses related to insufficient input validation.\n\nThis metric reports whether or not the struts Validator plugin has been enabled in the struts-config.xml. \nNote that in the case where a several struts configuration files belong to the same module, only one plugin declaration is needed. When one declaration exist, none of these struts configuration files will be reported.\nStruts 1: Enable Struts Validator plugin\nInput validation is required to secure an application. Moreover, the web interface is exposed to anyone. Non validating input may allow injecting arbitrary web script, HTML, SQL... Consequences can be severe, like erasing the content of a database.\nhttp://cwe.mitre.org/data/definitions/106.html\nUpdate your application's struts-config.xml file with the Validator plugin declaration.\nAdd the following lines in your application's struts-config.xml file:\n\n<!-- Validator Configuration -->\n<plug-in className=\"org.apache.struts.validator.ValidatorPlugIn\">\n  <set-property property=\"pathnames\"               value=\"/technology/WEB-INF/validator-rules.xml, /WEB-INF/validation.xml\"/>\n</plug-in>\n\nUpon initialization, the plug-in loads the comma-delimited list of Validator config files specified by the pathnames property. Each config file's path should be specified by use of a Web application-relative path.\nReport the list of struts configuration file that does not define the struts validator plugin.\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE struts-config PUBLIC \"-//Apache Software Foundation//DTD Struts \nConfiguration 1.3//EN\" \"http://struts.apache.org/dtds/struts-config_1_3.dtd\">\n<struts-config>\n    <form-beans>\n        <form-bean name=\"loginForm\" type=\"form.LoginForm\" />\n        <form-bean name=\"adminForm\" type=\"form.AdminForm\"></form-bean>\n    </form-beans>\n    <action-mappings>\n        <action input=\"/login.jsp\" name=\"loginForm\" path=\"/login\"\n             type=\"action.LoginAction\" scope=\"session\" >\n            <forward name=\"successStudent\" path=\"/student.do\" redirect=\"true\" />\n        </action>\n        <action input=\"/admin.jsp\" name=\"adminForm\" path=\"/admin\"  type=\"action.AdminAction\">\n            <forward name=\"success\" path=\"/admin.jsp\"></forward>\n        </action>\n       \n    </action-mappings>\n    <message-resources parameter=\"action.ApplicationResources\" />\n\n</struts-config>\nNumber of struts configuration files", "urls": ["http://cwe.mitre.org/data/definitions/106.html", "http://struts.apache.org/dtds/struts-config_1_3.dtd"]}, "7152": {"text": "Java servlets often store information associated with each client that connects to them. Using member fields in the javax.servlet.http.HttpServlet to store information specific to individual clients is a common, simple practice.\nBut all servlet fields should be static final, this approach guarantees thread-safety in the servlet.\nThis rule reports all servlet fields which are not static final \nAll Classes that extend HttpServlet at any level are considered as Servlets.\nAvoid Fields in Servlet Classes that are not final static\nThis report lists all non final static fields that belong to Servlet classes.\nIt provides the following information:\n  - Field full name\nServlets must be programmed in a thread-safe manner because the controller will share the same instance for multiple simultaneous requests. In addition to the servlet's threading model, if your intention is to store request-specific state and if your container provides clustering facilities, there's no guarantee that the same servlet instance will receive all the requests (from one user or all users) in a Web application.\n\nThe use of servlet fields that are not static final creates a security breach as this object is shared among multiple sessions and thus can lead to confidential data leaks.\nhttps://wiki.sei.cmu.edu/confluence/display/java/OBJ10-J.+Do+not+use+public+static+nonfinal+fields\nReview the Class design. Store global information in HttpSession, or use stateful session beans that are specifically targeted for this purpose. For temporary storage in a Servlet use local variables that are scoped within the doGet or doPost methods (or the service method).\npublic class SampleServlet extends HttpServlet {\n  \n  private static final String lastAddr = \"nobody@nowhere.com\"; // Fixed \n  \n  public void doGet(HttpServletRequest request, HttpServletResponse response)\n    throws IOException, ServletException {\n    response.setContentType(\"text/html\");\n    PrintWriter out = response.getWriter();\n    out.println(\"<html>\");\npublic class SampleServlet extends HttpServlet {\n \n  private String lastAddr = \"nobody@nowhere.com\"; // Violation \n \n  public void doGet(HttpServletRequest request, HttpServletResponse response)\n    throws IOException, ServletException {\n    response.setContentType(\"text/html\");\n    PrintWriter out = response.getWriter();\n    out.println(\"<html>\");\nNumber of fields of all classes that extend HttpServlet at any level", "urls": ["https://wiki.sei.cmu.edu/confluence/display/java/OBJ10-J.+Do+not+use+public+static+nonfinal+fields"]}, "4570": {"text": "Class Variables with Public, Protected or Package access type should be Final. Class Variables are Static Fields. Package access types taken into account are Non Public, Non Protected and Non Private.\nAvoid declaring Non Final Class Variables with Public, Protected or Package access type\nThis report lists all Non Final Class Variables with Public or Package access type. It provides the following information: Field full name\nIf a field is non-final and public, it can be changed once the value is set by any function that has access to the class which contains the field. This could lead to a vulnerability if other parts of the program make assumptions about the contents of that field.\n\nFor security reasons, if a Class Variable has Public, Protected or Package visibility, it should be declared Final to avoid being updated without Class control. Also for robustness reasons in a multi-threaded environment, leaving non-protected access to non-final class variables may lead to unpredictable behavior where the state of the class/instance is changed by another thread.\nhttps://wiki.sei.cmu.edu/confluence/display/java/OBJ10-J.+Do+not+use+public+static+nonfinal+fields\nReview the Field declaration to add the relevant access type.\nRemediation for Sample 1 : \nThe solution declares the FuncLoader static field final and treats it as a constant:\n\npublic static final FuncLoader m_functions;\n// Initialize m_functions in a static initialization block\n\nFields declared static and final are also safe for multithreaded use\nSample 1: \nThis sample declares a function table containing a public static field.\n\npackage org.apache.xpath.compiler;\n \npublic class FunctionTable {\n  public static FuncLoader m_functions;\n}\n\nAn attacker can replace the function table as follows:\n\nFunctionTable.m_functions = new_table;\nReplacing the function table gives the attacker access to XPathContext, which is used to set the reference node for evaluating XPath expressions. Manipulating XPathContext can cause XML fields to be modified in inconsistent ways, resulting in unexpected behavior.\nNumber of Java attributes", "urls": ["https://wiki.sei.cmu.edu/confluence/display/java/OBJ10-J.+Do+not+use+public+static+nonfinal+fields"]}, "7250": {"text": "Number of violation occurrences\nThis rule reports all Java methods and members doing initialization with String object\nAvoid String initialization with String object (created using the 'new' keyword)\nWhen initializing String with a literal value, it is faster to create it with a String literal than a String object.\nhttps://www.java67.com/2014/08/difference-between-string-literal-and-new-String-object-Java.html\nInitialize it with the literal.\nString s = \"hello\"; // FIXED\nThis report lists all methods initialized with a String object .\nIt provides the following information:\n\nMethod full name\nString s = new String(\"hello\"); // VIOLATION\nNumber of Java artifacts", "urls": ["https://www.java67.com/2014/08/difference-between-string-literal-and-new-String-object-Java.html"]}, "7562": {"text": "In practice, static collection classes, such as HashMap and Vector can cause memory leak. Static collections are likely to cause memory leaks because static variables remain in memory as long as the application runs, regardless of its object creation and destruction. So because their life cycle is the application duration, the objects that they reference will be kept in memory until the application end.\n\nThis rule reports static field defined as a class or interface that implements:\n\n  - java.util.Collection or java.util.Collection<E>\n  or\n  - java.util.Map or java.util.Map<K,V> except when:\n\n       - it is the class or a subclass of java.util.WeakHashMap or java.util.WeakHashMap<K,V>\n       - the field is defined as an interface and is initialized with an instance of the class or a subclass of java.util.WeakHashMap\n       or java.util.WeakHashMap<K,V>.\n       - if collection.clear() or Map.clear() is used.\nAvoid static Field of type collection\nIn a production environment, memory leaks can force organizations to add more memory and hardware resources. They can even cause an application to crash unexpectedly. In theory, the garbage collector is responsible to manage memory and should avoid these issues.\n\nProgramming errors can prevent garbage collection of objects that are no longer relevant to program operation. The garbage collector collects only unreachable objects; consequently, the presence of reachable objects that remain unused indicates memory mismanagement. Consumption of all available heap space can cause an OutOfMemoryError, which usually results in program termination.\n\nExcessive memory leaks can lead to memory exhaustion and denial of service (DoS) and must be avoided\nhttps://wiki.sei.cmu.edu/confluence/display/java/MSC04-J.+Do+not+leak+memory\nhttps://cwe.mitre.org/data/definitions/1091.html\nhttps://cwe.mitre.org/data/definitions/401.html\nYou can either check that objects added in the collection are removed when required or use weak references that will leverage the garbage collector's ability to determine reachability of referenced objects for you.\nRemeadiation for Sample 1:\nPrefer using standard language semantics where possible. This compliant solution uses the vector.clear() method, which removes all elements:\n\npublic void useVector(int count) { \n  try {\n    for (int n = 0; n < count; n++) {\n      vector.add(Integer.toString(n));\n    }\n    // ...\n  } finally {\n    vector.clear(); // Clear the vector\n  }\n}\n\n\n\n\nRemeadiation for Sample 2: \nUse weak references to allow timely garbage collection:\n\n// ...\nprivate Map<SSLSocket, InetAddress> m = Collections.synchronizedMap(\n  new WeakHashMap<SSLSocket, InetAddress>()\n);\nThis report lists all static field defined as collection (class or interface).\nIt provides the following information:\n  Field full name\nSample 1: in this sampe the usage of vector object lead to memory leaks: The condition for removing the vector element is mistakenly written as n > 0 instead of n >= 0. Consequently, the method fails to remove one element per invocation and quickly exhausts the available heap space.\n\npublic class Leak {\n  static Vector vector = new Vector();\n \n  public void useVector(int count) {   \n    for (int n = 0; n < count; n++) {\n      vector.add(Integer.toString(n));\n    }\n    // ...\n    for (int n = count - 1; n > 0; n--) { // Free the memory\n      vector.removeElementAt(n);\n    }  \n  }\n \n  public static void main(String[] args) throws IOException {\n    Leak le = new Leak();\n    int i = 1;\n    while (true) {\n      System.out.println(\"Iteration: \" + i);\n      le.useVector(1);\n      i++;\n    }\n  }\n}\n\n-----------------\nSample 2 \nIn this sample, a common variation of the obsolete object fallacy is the unintentional retention of objects in collections such as maps: The server maintains temporary metadata about all committed secure connections:\n\nclass HashMetaData {\n  private Map<SSLSocket, InetAddress> m = Collections.synchronizedMap(\n      new HashMap<SSLSocket, InetAddress>());\n \n  public void storeTempConnection(SSLSocket sock, InetAddress ip) {\n    m.put(sock, ip); \n  }\n \n  public void removeTempConnection(SSLSocket sock) {\n    m.remove(sock); \n  }\n}\nNumber of static field defined as collection (class or interface), java.util.WeakHashMap or java.util.WeakHashMap<K,V>", "urls": ["https://wiki.sei.cmu.edu/confluence/display/java/MSC04-J.+Do+not+leak+memory", "https://cwe.mitre.org/data/definitions/1091.html", "https://cwe.mitre.org/data/definitions/401.html"]}, "4566": {"text": "Instance Variables should have an access type defined (Public, Private or Protected). Instance Variables are Non Static Fields.\nAvoid declaring Instance Variables without defined access type\nThis report lists all Instance Variables without defined access types. It provides the following information: Field full name\nFor security reasons, Instance Variables should always have an access type defined. When no access type is defined, the visibility of the variable is at the Package level which means that it may be accessed from any other class in the same package as the declaring class.\nProvide required access type to the Instance Variable.\nclass Page {\npublic String pageName;\n// instance variable with public access\nprivate int pageNumber;\n// instance variable with private access\n}\nclass Page {\n// instance variabled without access type \nString pageName;\nint pageNumber;\n\n}\nNumber of Java attributes", "urls": []}, "4572": {"text": "If the instance variable declared as final, then we have to perform initialization explicitly whether we are using it or not and JVM won\u2019t provide any default value for the final instance variable.\nDEPRECATED : Avoid declaring Final Instance Variables that are not initialized\nIf a Final Instance Variable is not dynamically initialized, its value will be the same for all Instances and need not be an Instance Variable. This final instance variable requires memory for each new instantiation while it could be declared as static and require memory only once for all instances of the class.\nInitialization before constructor completion \n\nclass Test { \n    final int x = 10; \n    public static void main(String[] args) \n    { \n        Test t = new Test(); \n        System.out.println(t.x); \n    } \n} \nOutput: 10\n---------------------------------------------------------\n\nWe can also initialize a final instance variable inside a non-static or instance block also.\n\nclass Test { \n    final int x; \n    { \n        x = 10; \n    } \n    public static void main(String[] args) \n    { \n        Test t = new Test(); \n        System.out.println(t.x); \n    } \n} \nOutput: 10\n-------------------------\nInside default constructor we can also initialize a final instance variable.\n\nclass Test { \n    final int x; \n    Test() \n    { \n        x = 10; \n    } \n    public static void main(String[] args) \n    { \n        Test t = new Test(); \n        System.out.println(t.x); \n    } \n} \nOutput: 10\n----------------------------------------------\nThe above mentioned are the only possible places to perform initialization for final instance variable. If we try to perform initialization anywhere else then we will get compile time error.\n\n\n\n// Declare final instance variable within any static blocks \nclass Test { \n    final int x; \n    public static void main(String[] args) \n    { \n        x = 10; \n        Test t = new Test(); \n        System.out.println(t.x); \n    } \n} \nOutput: error: non-static variable x cannot be referenced from a static context\n\n\n// Declare or initialize final instance variable within any methods \nclass Test { \n    final int x; \n    public void m() \n    { \n        x = 10; \n    } \n} \nOutput: error: cannot assign a value to final variable x\nThis report lists all Final Instance Variables, except those that are dynamically initialized. It provides the following information: Field full name\nclass Test { \n    final int x; \n    public static void main(String[] args) \n    { \n        Test t = new Test(); \n        System.out.println(t.x); \n    } \n} \n\nOutput:\n\nerror: variable x not initialized in the default constructor\nNumber of Java attributes", "urls": []}, "7242": {"text": "Parent Class full name\nAll Action Classes should inherit from a single Class, inheriting from the Struts Action Class (org.apache.struts.action.Action). \nWhen a class inherit from an action class, all other action class must inherit from the same one. This base class must be abstract or have an abstract method.\nStruts1: Avoid implementing Action Classes inheriting directly from Struts Action\nIt is a good practice to extend the struts Action class, and all specific Actions should inherit from it. With such inheritance tree, the basic action class (those inheriting from Struts Action class) implements the methods shared by all the Action class to avoid code redundancy.\nhttp://www.sitepoint.com/article/struts-first-steps/2\nHave Action Class inherit from one single extension of Struts Action Class that is abstract or have an abstract method.\nPublic  class MyBaseAction extends Action {\n   public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest  request, HttpServletResponse response) throws Exception {\n      //Call all common methods\n      commonTasks();\n      return executeSpecificTask(mapping,form,\n                                                   request,response);\n      }\n\n     private void commonTasks() {\n     //Code for common tasks\n    }\n\n   //Provide implementation of this method in sub-classes\n   public abstract ActionForward executeSpecificTask (ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception;\n}\n\nPublic  class MyAction extends MyBaseAction { // FIXED\n    public ActionForward executeSpecificTask (ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n      // some code\n   }\n}\nThis report lists all Action Classes inheriting from different Class.\nIt provides the following information:\n - Class full name\n - parent Class full name\nPublic  class MyAction extends Action { // VIOLATION\n   public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest  request, HttpServletResponse response) throws Exception {\n      // Some code\n   }\n}\nNumber of action classes (inherit from org.apache.struts.action.Action)", "urls": ["http://www.sitepoint.com/article/struts-first-steps/2"]}, "8042": {"text": "An unused validation form indicates that validation logic is not up-to-date.\nThis rule reports all unused form validator not referencing java class.\nStruts 2: Avoid unused validation form\nWhen a form validation file is unused, this indicate that the validation logic is not properly maintained and can result in a weakness.\nInput validation is required to secure an application. Moreover, the web interface is exposed to anyone. Non validating input may allow injecting arbitrary web script, HTML, SQL etc. Consequences can be severe, like erasing the content of a database.\nhttp://cwe.mitre.org/data/definitions/107.html\nUpdate the validation.xml's entries according to the form used in your application.\n\nUpdate the \"ActionClass\"-validation.xml's entries according to java classes used in your application and review the validation logic of the validation form.\nRemove User-validation.xml file or move it in a location where the User.java file exist if it has a meaning.\nThis report lists all unused validation forms name. It provides the following information:\n  Form Validation File Full Name\nUser-validation.xml file is in a folder where no User.java file is existing\nNumber of validation forms", "urls": ["http://cwe.mitre.org/data/definitions/107.html"]}, "8038": {"text": "Validation fields that do not appear in forms they are associated with indicate that the validation logic is out of date.\n\nThis rule reports validator form with all their validator form field that does not reference a Java class field.\nStruts 2: Avoid Struts Validator field without Form Field\nWhen a validation form field is not associated to java class field, this indicate that the validation logic is not properly maintained and can result in a weakness.\n\nIt is easy for developers to forget to update validation logic when they make changes to an ActionForm class. One indication that validation logic is not being properly maintained is inconsistencies between the action form and the validation form.\n\nAlthough J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.\nhttp://cwe.mitre.org/data/definitions/110.html\nUpdate the \"ActionClass\"-validation.xml's entries according to java classes used in your application and review the validation logic of the validation form.\nRegister-validation.xml\n<validators>\n  <field name=\"username\">\n      <field-validator type=\"requiredstring\">\n           <message >Username is required.</message>\n      </field-validator>\n      <field-validator type=\"stringlength\">\n         <param name=\"maxLength\">8</param>\n         <param name=\"minLength\">5</param>\n         <message>While ${username} is a nice name, a valid username must be between ${minLength} and ${maxLength} characters long. </message>\n     </field-validator>\n  </field> /* FIXED: remove the validator field portfolioName */\n   <field name=\"email\">\n      <field-validator type=\"requiredstring\">\n          <message>You must enter a value for email.</message>\n      </field-validator>\n       <field-validator type=\"email\">\n         <message key=\"email.invalid\"/>\n      </field-validator>\n   </field>\n  <validator type=\"expression\">\n      <param name=\"expression\">username != password</param>\n      <message>Username and password can't be the same.</message>\n  </validator>\n</validators>\nThis report lists all validator form fields that do not reference a java class field. It provides the following information:\n  Validation Form Field\npublic class Register extends ActionSupport {\n  private String username;\n  private String password; \n  private String firstName;\n  private String lastName;\n  private String email;\n  private boolean receiveJunkMail;\n\n  public String execute(){\n    User user = new User();\n    user.setPassword( getPassword() );\n    user.setUsername( getUsername() );\n    user.setFirstName( getFirstName());\n    user.setLastName( getLastName() );\n    user.setEmail(getEmail());\n\n    System.out.println(\"junkmail = \" + isReceiveJunkMail());\n\n    return SUCCESS;\n  }\n}\n\nRegister-validation.xml\n<validators>\n  <field name=\"username\">\n      <field-validator type=\"requiredstring\">\n           <message >Username is required.</message>\n      </field-validator>\n      <field-validator type=\"stringlength\">\n         <param name=\"maxLength\">8</param>\n         <param name=\"minLength\">5</param>\n         <message>While ${username} is a nice name, a valid username must be between ${minLength} and ${maxLength} characters long. </message>\n     </field-validator>\n  </field> /* VIOLATION: the portfolioName is not associated to any Register class field */\n  <field name=\"portfolioName\">\n      <field-validator type=\"requiredstring\">\n         <message key=\"portfolioName.required\"/>\n     </field-validator>\n  </field>\n   <field name=\"email\">\n      <field-validator type=\"requiredstring\">\n          <message>You must enter a value for email.</message>\n      </field-validator>\n       <field-validator type=\"email\">\n         <message key=\"email.invalid\"/>\n      </field-validator>\n   </field>\n  <validator type=\"expression\">\n      <param name=\"expression\">username != password</param>\n      <message>Username and password can't be the same.</message>\n  </validator>\n</validators>\nTotal Number of Validation Form Fields", "urls": ["http://cwe.mitre.org/data/definitions/110.html"]}, "7704": {"text": "Non final static fields\nAn enterprise bean must not use read/write static fields. Using read-only static fields is allowed. Therefore, it is recommended that all static fields in the enterprise bean class be declared as final.\n\n\nThis rule reports all enterprise beans (session, message and entity) that have non final static fields even if these static fields are held by a class in its inheritance tree.\nAll static fields in the enterprise bean class should be declared as final\nAn object contains a public static field that is not marked final, which might allow it to be modified in unexpected ways.\nThis rule is required to ensure consistent runtime semantics because while some EJB containers may use a single JVM to execute all enterprise bean's instances, others may distribute the instances across\nmultiple JVMs.\nJSR-220 Enterprise Java Beans 3.0 Final Release (ejbcore) page 545\nhttps://www.oracle.com/technetwork/java/restrictions-142267.html\nDeclare these static fields as final or review your design.\nSession:\n\n@Stateful\npublic class MyBean implements MyRemoteBean {\n   private static final String myName = \"MyBean\"; // FIXED\n    ...\n    public int aMethod() {\n        ...\n    }\n   ...\n}\n\nMessage:\n\n@MessageDriven(mappedName = \"jms/TestQueue\")\npublic class TestMessageDrivenBean implements MessageListener {\n    private static final String queue_name = \"Queue\"\n\n    public void onMessage(Message message) {\n        ....\n        }\n}\n\nEntity:\n\npublic class Customer implements Serializable {\n    private static final long serialVersionUID = 1L;\n    .....\n}\nThis report lists all java enterprise classes that have non final static fields.\nIt provides the following information:\n - Class full name\n - list of non final static fields\nSession:\n\n@Stateful\npublic class MyBean implements MyRemoteBean {\n   private static String myName = \"MyBean\"; // VIOLATION\n    ...\n    public int aMethod() {\n        ...\n    }\n   ...\n}\n\nMessage:\n\n@MessageDriven(mappedName = \"jms/TestQueue\")\npublic class TestMessageDrivenBean implements MessageListener {\n    private static String queue_name = \"Queue\"\n\n    public void onMessage(Message message) {\n        ....\n        }\n}\n\nEntity:\n\npublic class Customer implements Serializable {\n    private static long serialVersionUID = 1L;\n    .....\n}\nNumber of enterprise beans (session, message and entity)", "urls": ["https://www.oracle.com/technetwork/java/restrictions-142267.html"]}, "7700": {"text": "Servlet Class Name\nFor Struts based application, this rule reports all Servlet that inherit from javax.servlet.http.HttpServlet but not from org.apache.struts.action.ActionServlet class.\nStruts1: Only Struts HTTP Servlet should be used for Struts based application\nWhen Struts framework is used, it must be used for every page in the application to avoid mixing different technologies and creating an application difficult to maintain and be the source of a lack of robustness.\nAdapt the struts application to use front controller servlet (which is Action Servlet) for all HTTP requests as following one: \nThe remediation can be :\n<servlet>\n    <servlet-name>action</servlet-name>\n    <servlet-class>\n      org.apache.struts.action.ActionServlet\n    </servlet-class>\n    <init-param>\n      <param-name>config</param-name>\n      <param-value>/WEB-INF/conf/struts-config.xml</param-value>\n    </init-param>\n  <servlet>\n<servlet>\n    <servlet-name>action</servlet-name>\n    <servlet-class>\n      org.apache.struts.action.ActionServlet\n    </servlet-class>\n    <init-param>\n      <param-name>config</param-name>\n      <param-value>/WEB-INF/conf/struts-config.xml</param-value>\n    </init-param>\n<servlet>\nThis report lists all HTTP Servlets that don't inherit from Struts action Servlet.\nIt provides the following information:\n  Servlet Full Name, Servlet Class Name\n---> web.xml\n\n<!-- Struts Action Servlet -->\n  <servlet>\n    <servlet-name>action</servlet-name>\n    <servlet-class>\n      org.apache.struts.action.ActionServlet\n    </servlet-class>\n    <init-param>\n      <param-name>config</param-name>\n      <param-value>/WEB-INF/conf/struts-config.xml</param-value>\n    </init-param>\n  <servlet>\n\n  <servlet>\n    <servlet-name>AnotherServlet</servlet-name>\n    <servlet-class>\n      // doesn't inherit from org.apache.struts.action.ActionServlet\n      // but inherits from javax.servlet.http.HttpServlet\n      com.cast.AnotherServlet // VIOLATION:    \n   </servlet-class>\n  </servlet>\nNumber of Servlets that inherit from javax.servlet.http.HttpServlet when org.apache.struts.action.ActionServlet is used", "urls": []}, "7382": {"text": "Form Field Name\nValidation fields that do not appear in forms they are associated with indicate that the validation logic is out of date.\n\nThis rule reports all validation forms that contain field property which has no field reference in associated java class\nNote that it can be related to a form name or an action name (in the case of a form shared among different actions)\nStruts1: Avoid Struts Validator field without Form Field\nIt is easy for developers to forget to update validation logic when they make changes to an ActionForm class. One indication that validation logic is not being properly maintained is inconsistencies between the action form and the validation form.\n\nAlthough JEE applications are not generally susceptible to memory corruption attacks, if a JEE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the JEE application to launch a buffer overflow attack.\nhttp://cwe.mitre.org/data/definitions/110.html\nUpdate the validation.xml's entries according to the form used in your application and review the validation logic of the form.\n----> validation.xml:\n\n<form-validation>\n  <formset>\n    <form name=\"logonForm\">\n      <field property=\"username\" \n            depends=\"required\">\n        <arg0 key=\"prompt.username\"/>\n      </field>\n      <field property=\"password\" \n            depends=\"required\">\n        <arg0 key=\"prompt.password\"/>\n      </field>\n     // FIXED: passphrase has been removed\n    </form>\n  </formset>\n</form-validation>\nThis report lists all validator form with fields that are not related to a form bean field. It provides the following information:\n  - Validation Form\n  - Form Field\n====>  For concrete Form Bean\n\n--> logonForm.java (for concrete Form Bean) :\npublic class LogonForm extends ValidatorForm {\n  private String username;\n  private String password;\n  \n  public String getUsername() {\n    return username;\n  }\n  \n  public void setUsername(String username) {\n    this.username = username;\n  }\n\n  public String getPassword() {\n    return password;\n  }\n\npublic void setPassword(String password) {\n    this.password = password;\n  }\n}\n\n--> struts-config.xml (for concrete Form Bean)\n<form-beans>\n  <form-bean name=\"logonForm\"\n            type=\"com.cast.struts.sample.LogonForm\"/>\n</form-beans>\n\n====>  for dynamic Form Bean\n\n--> struts-config.xml (for dynamic Form Bean)\n<form-beans>\n  <form-bean name=\"logonForm\"\n            type=\"org.apache\n.struts.validator.DynaValidatorForm\">\n    <form-property name=\"username\"\n            type=\"java.lang.String\"/>\n    <form-property name=\"password\"\n            type=\"java.lang.String\"/>\n  </form-bean>\n</form-beans>\n\n====>  for both dynamic and concrete Form Bean\n\n----> validation.xml:\n\n<form-validation>\n  <formset>\n    <form name=\"logonForm\"> \n      <field property=\"username\" \n            depends=\"required\">\n        <arg0 key=\"prompt.username\"/>\n      </field>\n      <field property=\"password\"\n            depends=\"required\">\n        <arg0 key=\"prompt.password\"/>\n      </field>\n      <field property=\"passphrase\" // VIOLATION\n            depends=\"required\">\n        <arg0 key=\"prompt.passphrase\"/>\n      </field>\n    </form>\n  </formset>\n</form-validation>\nNumber of Validation Forms", "urls": ["http://cwe.mitre.org/data/definitions/110.html"]}, "7380": {"text": "An unused validation form indicates that validation logic is not up-to-date.\nThis rule reports all unused form validator not referencing java class. \nNote that it can be the form name or the action name (in the case of a form shared among different actions)\nStruts 1: Avoid unused validation form\nIt is easy for developers to forget to update validation logic when they remove or rename action form mappings. One indication that validation logic is not being properly maintained is the presence of an unused validation form.\nhttp://cwe.mitre.org/data/definitions/107.html\nUpdate the validation.xml's entries according to the form used in your application.\n----> validation.xml:\n<form-validation>\n  <formset> // FIXED\n    <form name=\"logonForm\">\n      <field property=\"username\" \n            depends=\"required\">\n        <arg0 key=\"prompt.username\"/>\n      </field>\n    </form>\n  </formset>\n</form-validation>\nThis report lists all unused validation forms name. It provides the following information:\n  Form Validation Full Name\n----> struts-config.xml:\n<action-mapping>\n  <action path=\"/logon\"\n         type=\"com.cast.struts.sample.LogonAction\"\n         name=\"logonForm\"/>\n</action-mapping>\n\n<form-beans>\n  <form-bean name=\"logonForm\"\n            type=\"com.cast.struts.sample.LogonForm\"/>\n</form-beans>\n\n----> validation.xml:\n\n<form-validation>\n  <formset>\n    <form name=\"logonForm\">\n      <field property=\"username\" \n            depends=\"required\">\n        <arg0 key=\"prompt.username\"/>\n      </field>\n    </form>\n   <form name=\"addressForm\"> // VIOLATION: this form or action-mapping doesn't exist\n      ...\n   </form>\n  </formset>\n</form-validation>\nNumber of validation forms", "urls": ["http://cwe.mitre.org/data/definitions/107.html"]}, "7238": {"text": "Called Page name\nPages should not directly call other Pages through jsp:forward, jsp:include, logic:forward, logic:redirect,  core:redirect (JSTL) or pageContext.forward() or pageContext.sendRedirect().\n\nNote that referencing other pages through the directive errorPage or a static include are not reported as a violation.\nAvoid calls between JSP Page for application using Struts framework\nA good implementation of an MVC model means no calls from one Page to another. In addition, the user's permissions that go to the target JSP page cannot be checked (if applicable).\nTo avoid these issues, always go from one JSP page to another through an Action class and action-mappings (in case of struts 1.x) or action (in case of struts 2.x).\nSample.jsp\n<%\n    response.sendRedirect(\"Example.do\"); // FIXED\n%>\n\n<%\n    pageContext.forward( \"Example.do\" ); // FIXED\n%>\n\n<jsp:forward page= 'Example.do' /> // FIXED\n\n// implement the flow into the struts-config.xml file:\n\n<action path=\"/Example\"\ntype=\"strutsSample.SampleAction\">\n<forward name=\"success\" path=\"/myPage.jsp\"/>\n</action>\n\n// And in the action class:\npublic class SampleAction extends Action {\npublic ActionForward execute(\nActionMapping mapping,\nActionForm form,\nHttpServletRequest request,\nHttpServletResponse response)\nthrows Exception {\nreturn mapping.findForward(\"success\");\n}\n}\nThis report lists all Pages calling another Page\nIt provides the following information:\n - Page full name\n - Called Page name\n// Sample.jsp\n<%\n    response.sendRedirect(\"myPage.jsp\"); // VIOLATION\n%>\n\n<%\n    pageContext.forward( \"myPage.jsp\" ); // VIOLATION\n%>\n\n<jsp:forward page= 'myPage.jsp' /> // VIOLATION\nNumber of JSP pages", "urls": []}, "7726": {"text": "The package that reference the database\nIn struts based application, the data access layer must be distinct from the business layer.\n\nThis rule finds all Action Classes (and parent classes) list artifacts that call classes (&anonymous classes) and Lambda referenced in a package that reference directly the database or reference JPA or Hibernate Entities.\n\n\nThe Action Classes considered by this rule are ones referenced in the struts-config.xml through the tag 'action-mapping' (in struts 1.x) or in struts.xml and its included files through the tag 'action' (in struts 2.x)\nAvoid Struts Action Classes that call packages having direct access to database\nStruts is a Framework for building Model-View-Controller 2 Web applications. This model is the Blueprints recommended architectural design pattern for interactive applications. The logical separation between presentation layer, the business logic layer, and the data access layer is basically an architectural way to minimize the amount of additional work necessary to add features to any layer that can be consumed by another layer.\nIt separates design concerns (data persistence and behavior, presentation, and control), decreasing code duplication, centralizing control, and making the application more easily modifiable. MVC 2 also helps developers with different skill sets to focus on their core skills and collaborate through clearly defined interfaces.\nReview the design in order to separate the model from the data access layer.\npublic class JEEAMDA003_1_2_DN_SHOW extends Action {\n\n    public ActionForward execute(ActionMapping mapping, ActionForm form,\n            HttpServletRequest request, HttpServletResponse response) {\n        User userForm = (User) form;\n        String user = userForm.getUserId();\n        String password = userForm.getPassword();\n        if (user.equals(\"admin\") && password.equals(\"admin\"))\n            return mapping.findForward(\"success\");\n        ActionMessages errors = new ActionMessages();\n        ActionMessage error = new ActionMessage(\"login.failed\");\n        errors.add(\"error\", error);\n        saveErrors(request, (ActionErrors) errors);\n        return mapping.findForward(\"failure\");\n    }\n\n}\nThis report lists all Action Classes that call a package that reference database or reference JPA or Hibernate Entities.\nIt provides the following information:\n Artifact full name, the package that reference the database\npublic class JEEAMDA003_1_6_SHOW extends Action {\n    \n    public ActionForward execute(ActionMapping mapping, ActionForm form,\n            HttpServletRequest request, HttpServletResponse response) {\n        User user = (User) form;\n\n        try{\n            UserManager.getInstance().saveUser(user); // Violation \n        }catch(SQLException sqle)\n        {\n            ActionMessages errors = new ActionMessages();\n            ActionMessage error = new ActionMessage(\"error.generic\",sqle.getMessage());\n            errors.add(\"error\",error);\n            saveErrors(request,(ActionErrors) errors);\n        }\n        return mapping.findForward(\"success\");\n    }\n\n}\nNumber of Action Classes and parent classes that are referenced as an action in the XML configuration file(s)", "urls": []}, "7134": {"text": "Global forward full name\nThis report lists all local forward that have the same name as global forward.\nDEPRECATED: Avoid having Struts local forward with same name as Struts  global forward\nIt provides the following information:\n - local forward full name\n - global forward full name\nIn Struts, for better readability and to avoid unexpected behaviour, it is recommended to have a unique name as entry point.\nDon't have local forward with same name as global forward\n<action-mappings type=\"org.apache.struts.action.ActionMapping\">\n    <action path=\"/login\" parameter=\"\" input=\"/index.jsp\" scope=\"request\"\n      name=\"loginForm\" type=\"com.jmd.test.struts.controleur.LoginAction\">\n      <forward name=\"success\" path=\"/welcome.jsp\" redirect=\"false\" />\n      <forward name=\"error\" path=\"/index.jsp\" redirect=\"false\" />\n    </action>\n  </action-mappings>\n<action-mappings type=\"org.apache.struts.action.ActionMapping\">\n    <action path=\"/login\" parameter=\"\" input=\"/index.jsp\" scope=\"request\"\n      name=\"loginForm\" type=\"com.jmd.test.struts.controleur.LoginAction\">\n      <global-forward name=\"success\" path=\"/welcomeglobal.jsp\" redirect=\"false\" />\n      <forward name=\"success\" path=\"/welcome.jsp\" redirect=\"false\" />\n      <forward name=\"error\" path=\"/index.jsp\" redirect=\"false\" />\n    </action>\n  </action-mappings>\nNumber of Local Forwards", "urls": []}, "7640": {"text": "This rule reports violation for all methods and constructors containing a catch block that refer to the assert instruction.\nAvoid using catch blocks with assertion\nThis report lists all Methods that refer to the assert instruction.It provides the following information: Method full name\nAssertions are not meant to replace checking method parameters or program state and throwing informative exceptions when facing an exceptional situation. The program logic or the error handling logic shouldn't rely on them.\n\nThe purpose of an assertion is to force a program to fail when a simple self-diagnosis shows there's something wrong with the program itself. Assertions may help a programmer in finding bugs and avoiding them in the first place. Since all programming and debugging should be done in a development environment rather than in a production environment, assertions are usually disabled in production environments.\nhttps://airbrake.io/blog/java-exception-handling/assertionerror-java\nThe exception must be handled correctly according to its type.\ntry {\n   Date defaultDate=format.parse(DEFAULT_DATE_STRING);\n...\n} catch( ParseException pexc ) {\n  // This must never happen!\n     throw myException(\"bad init value\", pexc); // FIXED\n}\ntry {\n   Date defaultDate=format.parse(DEFAULT_DATE_STRING);\n...\n} catch( ParseException pexc ) {\n  // This must never happen!\n  assert false : \"bad init value\"; // VIOLATION\n}\nNumber of methods and constructors that have code (not abstracts or from interfaces) containing a catch block", "urls": ["https://airbrake.io/blog/java-exception-handling/assertionerror-java"]}, "7654": {"text": "Associated table name\nAn entity models a database table\nThis rule checks if used database tables are associated to more than one Hibernate Entity. If yes, a violation is reported except for \n- Entities that belong to the same hierarchy and that are stored into a single table using the table-per-class-hierarchy strategy (also know as SINGLE_TABLE in JPA) \nand \n- Entities that are stored into several tables using table-per-sub-class strategy (also know as JOINED in JPA).\n\nNote that in the case where two hierarchy are associated to the same table, only the root Entity will be reported, not all the hierarchy.\nAvoid database tables associated to more than one Hibernate Entity\nList all Entities that reference the same table.\nIt provides the following information:\n- Entity Full Name \n- table name\nOne main source of data corruption within applications comes from lack of compliance to data modification rules defined for an application. These rules are usually related to the use of specific procedures for update/insert/delete, a specific API or a data layer that is fully tested to maintain data integrity. The creation of new, different update/insert/delete procedures and functions that do not make use the existing tested code is at origin of many data corruption cases.\nIn the case of Hibernate, having different mapping files associated with the same table is a source of such data corruption.\nhttps://docs.jboss.org/hibernate/stable/orm/userguide/html_single/Hibernate_User_Guide.html#entity\nReview your design and decide which Entity must manage the table.\ncreate table Contact (\n    id integer not null,\n    first varchar(255),\n    last varchar(255),\n    middle varchar(255),\n    notes varchar(255),\n    starred boolean not null,\n    website varchar(255),\n    primary key (id)\n)\n\n\n@Entity(name = \"Contact\")    //FIXED:Single class should be associated to a table.\npublic static class Contact {\n\n    @Id\n    private Integer id;\n\n    private Name name;\n\n    private String notes;\n\n    private URL website;\n\n    private boolean starred;\n\n    //Getters and setters are omitted for brevity\n}\n// VIOLATION: table A is referenced by two Entities\n---> a.hbm.xml\n<class name=\"A\" table=\"A\"> \n    ...  \n</class>\n\n---> b.hbm.xml\n<class name=\"B\" table=\"A\"> \n    ...  \n</class>\n\n------------------------------------------------------------------------------------------\n\ncreate table Contact (\n    id integer not null,\n    first varchar(255),\n    last varchar(255),\n    middle varchar(255),\n    notes varchar(255),\n    starred boolean not null,\n    website varchar(255),\n    primary key (id)\n)\n@Entity(name = \"Contact\")\npublic static class Contact {\n\n    @Id\n    private Integer id;\n\n    private Name name;\n\n    private String notes;\n\n    private URL website;\n\n    private boolean starred;\n\n    //Getters and setters are omitted for brevity\n}\n\n\n@Entity(name = \"Contact\")    //VIOLATION\npublic static class TempContact {\n\n    @Id\n    private Integer id;\n\n    private Name name;\n\n    private String notes;\n\n    private URL website;\n\n    private boolean starred;\n\n    //Getters and setters are omitted for brevity\n}\nNumber of entities", "urls": ["https://docs.jboss.org/hibernate/stable/orm/userguide/html_single/Hibernate_User_Guide.html#entity"]}, "4676": {"text": "When enforcing the utilization of JavaDoc Comments to document an application, the @throws/@exception tags should be used to document the exceptions being thrown by a given Method. \nThe @exception tag is a synonym for @throws.\n\nThis rule raises a violation when none of the recommended tags (@throws/@exception) is used\nPublic Methods must have appropriate JavaDoc @throws/@exception tags\nThere is no dispute that Javadoc comments contribute to a developer's understanding and help a developer write reliable applications more quickly. Without documenting exception thrown, it is difficult for anyone else than the author to guess its purpose and consequences except by looking at the code that is throwing it.\nhttps://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html#throws\nhttps://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html#exception\nAdd a @throws or @exception tag with a description for each method.\n#Remediation Sample with @throws tag: \n/**\n * @throws IOException  If an input or output \n *                      exception occurred\n */\npublic void f() throws IOException {\n    // body\n}\n\n#Remediation Sample with @exception tag: \n/**\n* @exception StringIndexOutOfRangeException\n* if the index is not in the range <code>0</code>\n*  to <code>length()-1</code>.\n     \n*/\npublic char charAt(int index) {\n       ...\n    }\nThis report lists all Methods not having the appropriate @throws or @exception JavaDoc comments.\nThis report provides the following information:\n Method full name\npublic void f() throws IOException {\n    // body\n}\nNumber of methods that throw exceptions", "urls": ["https://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html#throws", "https://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html#exception"]}, "7650": {"text": "Every field of a serializable class must be either serializable or transient\n\nThis rule reports a violation if a Serializable class (implement java.io.Serializable or inherit from a class that is serializable) has a field that is \n- not Serializable (do not implement java.io.Serializable or inherit from a class that is serializable)\n- non-static \n- non transient fields \n- and not Java primitives type.\n\nNote that in the case of a field declared with an interface, this field is considered as serializable when the concrete class used to initialized this field is serializable. This quality rule will take into account cases where the field is initialized in the declaration, not the cases where the field is initialized later in a method.\nAll types of a serializable Class must be serializable\nReport all fields of Serializable classes that are not serializable, not transient, non-static and not primitive.\n\nIt provides the following information:\n  Full Field Name\nDeclaring non-transient fields of non-serializable type inside of a serializable class will result in an exception thrown during the serialization.\n\nThis issue can prevent the software from running reliably, e.g. by triggering an exeption. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\nhttps://cwe.mitre.org/data/definitions/1066.html\n8.2.42 ASCQM Ban Non-Serializable Elements in Serializable Objects : https://www.omg.org/spec/ASCQM/1.0/Beta2/PDF\nMake the field type serializable or transient.\n---> 1st solution\npublic static  final class  SomeType implements Serializable {} // FIXED\n\npublic class SerializableField implements Serializable {\n    private String str;\n    private SomeType field;\n}\n\n---> 2nd solution\npublic static  final class  SomeType {} \n\npublic class SerializableField implements Serializable {\n    private String str;\n    private transient SomeType field; // FIXED\n}\npublic static  final class  SomeType {}\n\npublic class SerializableField implements Serializable {\n    private String str;\n    private SomeType field; // VIOLATION\n}\nNumber of non-static, non-transient and not primitive fields of classes that implement Serializable", "urls": ["https://cwe.mitre.org/data/definitions/1066.html", "https://www.omg.org/spec/ASCQM/1.0/Beta2/PDF"]}, "7240": {"text": "Find all Action Classes (inherit from org.apache.struts.action.Action class) that call other classes than Business Classes specified by a parameter.\nDEPRECATED: Struts Action Classes should only call Business Classes\nThis report lists all call from Action Classes to non Business packages (X)\nIt provides the following information:\n Action method full name\nStruts is a Framework for building Model-View-Controller 2 Web applications. This model is the Blueprints recommended architectural design pattern for interactive applications. It separates design concerns (data persistence and behavior, presentation, and control), decreasing code duplication, centralizing control, and making the application more easily modifiable. MVC 2 also helps developers with different skill sets to focus on their core skills and collaborate through clearly defined interfaces.\nReview the design of the classes to follow this principle.\ncall the business package that will call this package\n// If the package is BusinessPackage.*\n\nimport org.apache.struts.action.Action;\n\nPublic class BaseApplicationAction extends Action\n{\n   public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n   NotBusinessPackage.SomeClass notTheBusiness; // VIOLATION\n   }\n}\nNumber of Action Classes", "urls": []}, "7648": {"text": "finalize() method in Java should be only called by garbage collector thread before reclaiming the memory allocated to the object.\n\nThis rule reports violation when detecting an explicit call to finalize() except call to super.finalize() from a finalize() method.\nAvoid an explicit call to finalize()\nThe metric will list all methods that call a finalize method (filter by method signature void finalise() ) \n\nIt provides the following information:\n Method full name\nWhile the Java Language Specification allows an object's finalize() method to be called from outside the finalizer, doing so is usually a bad idea. For example, calling finalize() explicitly means that finalize() will be called more than once: the first time will be the explicit call and the last time will be the call that is made after the object is garbage collected.\nhttps://cwe.mitre.org/data/definitions/586.html\nhttps://howtodoinjava.com/java/basics/why-not-to-use-finalize-method-in-java/\nIf an explicit call to finalize method is required, there is two possible remediation: \n- If finalize method is used to release non-memory resources like file handles, sockets, database connections etc: you must not use this method to release these resources but create a specific method or release these resource in a finally block. Finalize() method is used only to release memory resources.\n- If it is used for memory resources, the Garbage collector will handle the invocation, so just remove the explicit call.\npublic class InvokeFinalize {\n    private MyClass mine = new MyClass();\n    ...\n    public meth () {\n       ... \n/ FIXED\n    }\n}\npublic class MyClass  {\n     ...\n      protected void finalize() throws Throwable {\n          // some code here\n         ......\n          super.finalize();\n     }\n} \n\npublic class InvokeFinalize {\n    private MyClass mine = new MyClass();\n    ...\n    public meth () {\n       ...\n        mine.finalize();  // VIOLATION\n    }\n}\nNumber of calls to finalize methods and super.finalize()", "urls": ["https://cwe.mitre.org/data/definitions/586.html", "https://howtodoinjava.com/java/basics/why-not-to-use-finalize-method-in-java/"]}, "7954": {"text": "Call path from the method that contains the loop to the method that does the concatenation\nThis rule reports all methods that call indirectly a method that uses string concatenation in loops (for, while, do while) at a depth level less than <depth level> will be reported.\n\nThe depth level is 50\nAvoid indirect String concatenation inside loops\nThis reports all methods that call indirectly string concatenation in loops.\nIt provides the following information:\nMethod full name that has the loop, the call path from the method that contains the loop to the method that does  the concatenation.\n\nNote that:\n1/ The the call paths may contain different paths while only one path is a violation. For example:\nvoid concatString(String name) {\n    String result = \" concat \";\n    result += name;  }\n\nvoid g() {concatString(\" String \");}\n\nvoid f() {\n       while (myCondition) { g ();}\n        g();\n        } \n\nwill report both path to g() while only one is a violation.\n\n2/ Several paths for the same method violating the rule are identified in the Metric Detail page by a sequence ID (in the Value column), this ID is dynamically set during each snapshot and the same path can have a different sequence ID in different snapshots. (the value column), this value can vary from a snapshot to another and is used just to distinguish the violations.\nString concatenation is not efficient because it creates a StringBuffer for each concatenation. When placed in an indirect loop, String concatenation  results in the creation and garbage collection of large numbers of temporary objects. This both consumes memory and can dramatically slow the program execution. \n\nThis issue can make the software perform more slowly. If an attacker can influence the number of iterations in the loop, then this performance problem might allow a denial of service by consuming more platform resources than intended.\n\nIt is recommended to create a StringBuffer before entering the loop, and append to it within the loop, thus reducing the overhead.\nhttps://cwe.mitre.org/data/definitions/1050.html\nIt is recommended to create a StringBuilder (if JDK >= 1.5 and not in thread environment) or StringBuffer before entering the loop, and append to it within the loop, thus reducing the overhead.\nRemediation for Sample 1\n\npublic class ConcatenationTest {\n  public void concatString(StringBuffer result, String name) {\n    result.append(name);\n  }\n}\n---------------------------------------------------------------\n\nRemediation for Sample 2\n\npublic class LoopTest {\n  static final int N = 18000000;\n  private ConcatenationTest ct = new ConcatenationTest();\n \n  public void myLoop() {\n    StringBuffer result = \"hello\";\n    String name = \"bob\";\n    for (int i = 1; i <= N; i++) {\n      ct.concatString(result, name); // FIXED\n    }\n  }\n}\n\n-------------------------------------------------------------\n\nRemediation#3\n\npublic class ConcatenationTest {\n  public void concatString(StringBuilder sb, String name) {\n    sb.append(name);\n  }\n}\n\npublic class LoopTest {\n  static final int N = 18000000;\n  private ConcatenationTest ct = new ConcatenationTest();\n \n  public void myLoop() {\n    StringBuilder result = \"hello\";\n    String name = \"bob\";\n    for (int i = 1; i <= N; i++) {\n      ct.concatString(result, name); // FIXED\n    }\n  }\n}\nSample 1\npublic class ConcatenationTest {\n\n  public String concatString(String name) {\n    String result = \"hello \";\n    result += name;\n   return result\n  }\n}\n---------------------------------------------------------\n\nSample 2\npublic class LoopTest {\n  static final int N = 18000000;\n  private ConcatenationTest ct = new ConcatenationTest();\n \n  public void myLoop(void) {\n    String name = \"bob\";\n    for (int i = 1; i <= N; i++) {\n      ct.concatString(name); // VIOLATION\n    }\n  }\n}\nNumber of methods calling at least one method inside a loop", "urls": ["https://cwe.mitre.org/data/definitions/1050.html"]}, "7190": {"text": "List all validate() methods that override the validate method of the following classes (at any depth in the inheritance tree):\norg.apache.struts.validator.ValidatorForm\norg.apache.struts.validator.ValidatorActionForm\norg.apache.struts.validator.DynaValidatorForm\norg.apache.struts.validator.DynaValidatorActionForm\n\nand that doesn't call super.validate()\n\nThis rule is applicable only for struts1\nStruts1: Validate() Method of Struts Validator form must call super.validate()\nThis report lists all validate() methods that violate this rule.\nIt provides the following information:\n Method Full Name\nStruts Validator can be extended to implement your own custom validation.\nWhen overriding the validate() method, call the ancestor validate()\nmethod, to ensure that any framework validations are triggered. In case the validation framework is disabled, you expose the application to any type of attacks based on invalid field input.\nhttp://cwe.mitre.org/documents/sources/SevenPerniciousKingdoms.pdf\nhttps://owasp.org/www-community/vulnerabilities/Improper_Data_Validation\nCall super.validate() in the validate() method.\npublic ActionErrors validate(\n      ActionMapping mapping,\n      HttpServletRequest request) {\n  ActionErrors errors = super.validate(mapping, request); // FIXED\n\n  if (errors==null) {\n     if (notGood(mapping,request)) {\n        // some code\n     }\n  // some code\n}\npublic ActionErrors validate(    // VIOLATION\n      ActionMapping mapping,\n      HttpServletRequest request) {\n  if (notGood(mapping,request)) \n    // some code\n  }\n// some code\n}\nNumber of non abstract methods that override the validate method (at any depth in the inheritance tree) of one of the class ValidatorForm, ValidatorActionForm, DynaValidatorForm, DynaValidatorActionForm", "urls": ["http://cwe.mitre.org/documents/sources/SevenPerniciousKingdoms.pdf", "https://owasp.org/www-community/vulnerabilities/Improper_Data_Validation"]}, "8102": {"text": "Number of violation occurrences\nThis quality rule reports all artifacts that contain hardcoded network resource\n\n- URLs (of the form file:///c:/Tmp/Folder/ or http://host.com/folder) \n- Paths (Windows absolute paths of the form c:\\Tmp\\Folder) \n- JDBC URL (of the form jdbc:oracle:thin:@//myhost:1521/orcl) \n- IP addresses (IPv4 format like 0.0.0.0 to 255.255.255.255) \n- JNDI lookup path\nAvoid hardcoded network resource names (JEE)\nList all artifacts that reference hard coded IP adresses, URL, paths\nIt provides the following information: \n - Artifact full name\nBuilt-in resource names cause problems when the target is moved. Avoid hardcoded network resources (e.g., IP addresses, URLs, etc.)\nThe software initializes data using hard-coded values that act as network resource identifiers.\nThis issue can prevent the software from running reliably, e.g. if it runs in an environment does not use the hard-coded network resource identifiers. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\nHard coding network resorces, server IP addresses, URL etc can expose the information to attackers. Anyone who has access to the class files can decompile them and discover the sensitive information.\nHard coding sensitive information also increases the need to manage and accommodate changes to the code\nASCRM 1.0, Automated Source Code Reliability Measure, Object Management Group.\nhttps://wiki.sei.cmu.edu/confluence/display/java/MSC03-J.+Never+hard+code+sensitive+information\nRetrieve the hardcoded IP adresses, URLs, paths from an external file located in a secure directory\nRemediation For Sample1: The compliant solution retrieves the server IP address from an external file located in a secure directory\nclass IPaddress {\n  public static void main(String[] args) throws IOException {\n    char[] ipAddress = new char[100];\n    int offset = 0;\n    int charsRead = 0;\n    BufferedReader br = null;\n    try {\n      br = new BufferedReader(new InputStreamReader(\n             new FileInputStream(\"serveripaddress.txt\")));\n      while ((charsRead = br.read(ipAddress, offset, ipAddress.length - offset))\n          != -1) {\n        offset += charsRead;\n        if (offset >= ipAddress.length) {\n          break;\n        }\n      }\n       \n      // ... Work with IP address\n \n    } finally {\n      Arrays.fill(ipAddress,  (byte) 0);\n      br.close();\n    }\n  }\n}\n---------------------------\nRemediation for Sample2: Using the Configuration object and use this parameter instead of the hard coded path: \n\npublic class Sample{\n  private Configuration config;\n  public Sample(Configuration myConfig) {\n    this.config = myConfig;\n  }\n  public Collection<User> listUsers() {\n    String listingFolder = config.getProperty(\"myApp.listingFolder\");\n    File userList = new File(listingFolder, \"users.txt\"); // Compliant\n    Collection<User> users = parse(userList);\n    return users;\n  }\n}\nSample1: This noncompliant code example includes a hard-coded server IP address in a constant String:\n\nclass IPaddress {\n  String ipAddress = new String(\"172.16.254.1\");\n  public static void main(String[] args) {\n    //...\n  }\n}\n\n---------------\nSample2: This noncompliant code example includes a hard-coded URIs\n\npublic class TEST_SAMPLE{\n  public Collection<User> listUsers() {\n    File popleList = new File(\"/home/login/RED/people.txt\"); \n    Collection<User> people = parse(peopleList);\n    return people;\n  }\n}\nNumber of Java Artifacts", "urls": ["http://host.com/folder)", "https://wiki.sei.cmu.edu/confluence/display/java/MSC03-J.+Never+hard+code+sensitive+information"]}, "7702": {"text": "An application should not have to configure a ConnectionProvider explicitly if using one of the Hibernate-provided implementations from third parties. \nHibernate will internally determine which ConnectionProvider to use based on the following algorithm:\n\nIf hibernate.connection.provider_class is set, it takes precedence\nelse if hibernate.connection.datasource is set \nelse if any setting prefixed by hibernate.c3p0. is set \nelse if any setting prefixed by hibernate.proxool. is set \nelse if any setting prefixed by hibernate.hikari. is set \nelse if any setting prefixed by hibernate.vibur. is set \nelse if any setting prefixed by hibernate.agroal. is set \n\n\n\nThis rule checks hibernate.properties or hibernate.cfg.xml file: \n\n- If hibernate.connection.provider_class is set, it will report a violation as it takes precedence over all Hibernate-provided implementations from any third party\n\n- If hibernate.connection.provider_class in not set but no other setting prefixed by hibernate.c3p0 or hibernate.proxool, hibernate.hikari, or hibernate.vibur  or hibernate.agroal can be found neither the setting for hibernate.connection.datasource : a violation will be reported also as no explicit configuration tu use Hibernate-provided implementations from third parties.\nHibernate-provided implementations from third parties should be used for connection pool\nThis report list the XML or .properties file that doesn't define a third party pool.\nIt provides the following information:\n File Full Name\nIt is very important to define a connection pool to increase database access performances.\nHibernate's own connection pooling algorithm is quite rudimentary. It is intended to help you get started and is not intended for use in a production system, or even for performance testing. You should use a third party pool for best performance and stability. \n\nJust replace the hibernate.connection.pool_size property with connection pool specific settings. This will turn off Hibernate's internal pool. For example, you might like to use c3p0.\nhttps://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#configurations\nhttps://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#database\n\n\nHibernate in Action (ISBN 1932394-15-X) p 45\nUse a third party connection pool like as : \n\n- Hibernate.connection.datasource is set \n- Hibernate.c3p0 \n- Hibernate.proxool \n- Hibernate.hikari\n- Hibernate.vibur  \n- Hibernate.agroal\n\nPlease see references for more details about configuration setting\n---> hibernate.cfg.xml\n...\n<hibernate-configuration>\n    <!-- a SessionFactory instance listed as /jndi/name -->\n    <session-factory\n        name=\"java:comp/env/hibernate/SessionFactory\">\n        <!-- properties -->\n        <property name=\"connection.datasource\">my/first/datasource</property> // FIXED\n     ...\n    </session-factory>\n</hibernate-configuration>\n\n---> or in hibernate.properties\n...\nhibernate.connection.datasource = my/first/datasource\n...\n---> hibernate.cfg.xml\n...\n<hibernate-configuration>\n    <session-factory name=\"java:comp/env/hibernate/SessionFactory\">\n       ...\n        <property name=\"connection.pool_size\">10</property> // VIOLATION\n...\n\n---> or in hibernate.properties\nhibernate.connection.pool_size = 10 // VIOLATION\nNumber of Hibernate configuration fields (including hibernate.properties)", "urls": ["https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#configurations", "https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#database"]}, "4618": {"text": "The rule reports all artifacts instantiating a Boolean object.\nAvoid instantiating a Boolean object\nThis report lists all java artifacts instantiating a Boolean\nIt provides the following information:\n Artifact full name\nInstantiating a Boolean object consumes memory and CPU but does not bring value.\n\nJava artifacts should not instantiate Booleans.\nExample of instantiation:\n'Boolean b = new Boolean();'\nhttp://www.programmr.com/blogs/two-things-every-java-developer-should-know-about-booleans\nUse Boolean.TRUE or Boolean.FALSE instead.\nBoolean b = Boolean.FALSE;\n\nor\n\nBoolean variable = Boolean.valueOf(false);\nBoolean b = new Boolean( false);\nNumber of Java artifacts", "urls": ["http://www.programmr.com/blogs/two-things-every-java-developer-should-know-about-booleans"]}, "7508": {"text": "Reports all getter of collection-typed persistent attributes that don't return the correct interface type (getter can be defined on the persistent class itself or an inherited class that references a persistent attribute). The type returned by a getter must be:\nFor Hibernate:\n  Interface                         Association            Attribute\n\n  java.util.Set                      set                         \n  java.util.SortedSet                set                      sort\n  java.util.List                     list\n  java.util.Collection          bag or idbag\n  java.util.Map                       map\n  java.util.SortedMap                 map                     sort\n\nFor JPA:\n  Interface                                                          Association\njava.util.Set or java.util.List                                  when @OrderBy is used\njava.util.Map                                                      when @MapKey is used (javax.persistence.MapKey)\njava.util.Collection, java.util.Set or java.util.List      when no @OrderBY and no @MapKey is used\nGetter of collection-typed persistent attributes should return the correct interface type\nList all methods that don't return the correct interface for collection-typed persistent attributes.\n\nIt provides the following information:\n- Method Full Name\nHibernate or JPA requires interfaces for collection-typed attributes. You must use java.util.Set rather than HashSet, for example. At runtime, Hibernate or JPA wraps the HashSet instance with an instance of one of Hibernate's own classes in order to support lazy collections. Hibernate uses its own implementations of the List, Map or Set interfaces.\n\nIf the getters are not used with the correct interface, you may encounter ClassCastException issues.\nHibernate in Action (ISBN 1932394-15-X) p 69\nThe Java Persistence API (ISBN 1-932394-88-5) page 116\nInstead of using a concrete class or the wrong interface, define the getter return type with the correct interface.\n----> A.java\n\npublic class A {\n  private Integer id;\n  private SortedSet<B> b_items;\n\n  ...\n\n  // FIXED\n  public SortedSet<B> getB_items() {\n    return b_items;\n  }\n  ...\n}\n----> a.hbm.xml\n\n<hibernate-mapping >\n  \n  <class name=\"A\" table =\"A\"> \n    <id name=\"id\">\n      <generator class=\"increment\"/>\n    </id>\n\n    <set name=\"b_items\" lazy=\"true\" table =\"B\" sort=\"natural\"> \n      <key column=\"B_ID\"/>\n      <one-to-many class=\"B\"/>\n    </array>\n  </class>\n\n  <class name=\"B\" table=\"B\" lazy=\"true\">\n    <id name=\"id\" column=\"B_ID\">\n      <generator class=\"increment\"/>\n    </id>\n  </class>\n\n</hibernate-mapping>\n\n----> A.java\npublic class A {\n  private Integer id;\n  private SortedSet<B> b_items;\n\n  ...\n\n  // VIOLATION\n  public TreeSet<B> getB_items() {\n    return b_items;\n  }\n  ...\n}\nNumber of getters associated to persistent collection-typed attributes", "urls": []}, "7196": {"text": "Number of time the '+' is called\nAll String Classes should resort to using \"StringBuilder\" or \"StringBuffer\" instead of \"+\" or \"concat()\" Method because \"StringBuilder\" or \"StringBuffer\" is better in performance than the latter. of performance issue. \n\nSince version 1.6, the Oracle JVM also automatically optimizes this pattern in most cases. However, other JVMs might not. So this quality rule is kept in the AIP quality model, albeit with a low weight. And an instance where \"+\" is used more than X times should be a violation. The value of X is set to 5.\nAvoid large number of String concatenation (JEE)\nThis report lists all methods calling more than X times the '+' method on String object.\nIt provides the following information:\n - Method full name\n - the number of time the '+' is called\nThe quickest way of concatenating String in Java is by using  concatenation operator (\"+\") or concat() and it works quite well if you just have to join one or two fixed size String, but if you have to join thousands of String or then performance of concatenation operator is not good. Main reason of performance drop is creation of lots of temporary String object due to immutability of String (each call for concatenation will result in a new String object being created) \n\nAnd String concatenation resolved at runtime is much slower than using StringBuffer/StringBuilder.\nhttp://www.precisejava.com/javaperf/j2se/StringAndStringBuffer.htm#Strings104 \nhttp://www.oracle.com/technetwork/java/javase/6u18-142093.html\nhttps://javapapers.com/java/java-string-vs-stringbuilder-vs-stringbuffer-concatenation-performance-micro-benchmark/\nUse StringBuffer and StringBuffer.append() method instead\nStringBuffer result = new StringBuffer(\"hello\");\nresult.append(\" John\");\nresult.append(\" Smith\");\nSample 1: \nString result = \"hello\";\nresult += \" John\";\nresult += \" Smith\"; // VIOLATION if the threshold is 3\n\n\nSample 2\n\nString myString = \"Both\".concat(\" fickle\")\n  .concat(\" dwarves\")\n  .concat(\" jinx\")\n  .concat(\" my\")\n  .concat(\" pig\")\n  .concat(\" quiz\");\n \nassertEquals(\"Both fickle dwarves jinx my pig quiz\", myString);\nNumber of non abstract Java artifacts", "urls": ["http://www.precisejava.com/javaperf/j2se/StringAndStringBuffer.htm#Strings104", "http://www.oracle.com/technetwork/java/javase/6u18-142093.html", "https://javapapers.com/java/java-string-vs-stringbuilder-vs-stringbuffer-concatenation-performance-micro-benchmark/"]}, "4704": {"text": "This report lists all java artifacts using the Vector type, either as a parameter, or as a local variable.\nAvoid using Vector\nThis report lists all java artifacts using the Vector type, either as a parameter, or as a local variable.\nIt provides the following information:\n - Artifact full name\nPerformance: Vector is synchronized and thread-safe and because of this, it is slightly slower than ArrayList.\nFunctionality: Vector synchronizes at the level of each individual operation. Generally a programmer likes to synchronize a whole sequence of operations. Synchronizing individual operations is both less safe and slower.\nVectors obsolete: Vectors are considered obsolete and unofficially deprecated in java. Also, vector synchronizes on each individual operation which is almost never done. Mostly java programmers prefer using ArrayList since they will probably synchronize the arrayList explicitly anyway if they need to do synchronization.\nhttps://www.techiedelight.com/why-vector-class-java-obsolete/\nWhen synchronization is not need, prefer List and Map implementations and when synchronization is needed use Collections.synchronizedList and CopyOnWriteArrayList.\nimport java.util.*; \n  \npublic class ArrayListDemo { \n    public static void main(String args[]) \n    { \n  \n        // Creating an empty Vector \n        ArrayList<Integer> arr_list = new ArrayList<Integer>(n); \n  \n        // Use add() method to add elements in the Vector \n        arr_list.add(\"10\"); \n        arr_list.add(\"20\"); \n        arr_list.add(\"30\"); \n        arr_list.add(\"40\"); \n        arr_list.add(\"50\"); \n  \n        // Displaying the Vector \n        System.out.println(\"ArrayList: \" + arr_list); \n  \n        // Fetching the specific element from the Vector \n        System.out.println(\"The element is: \"\n                           + arr_list.get(2)); \n    } \n}\nimport java.util.*; \n  \npublic class VectorDemo { \n    public static void main(String args[]) \n    { \n        Vector<String> vec_tor = new Vector<String>(); //Violation\n  \n        // Use add() method to add elements in the Vector \n        vec_tor.add(\"Geeks\"); \n        vec_tor.add(\"for\"); \n        vec_tor.add(\"Geeks\"); \n        vec_tor.add(\"10\"); \n        vec_tor.add(\"20\"); \n  \n        // Displaying the Vector \n        System.out.println(\"Vector: \" + vec_tor); \n  \n        // Fetching the specific element from the Vector \n        System.out.println(\"The element is: \"\n                           + vec_tor.get(2)); \n    } \n}\n------------------------------------------------\n....\nType type = field.getGenericType();\nif (type instanceof ParameterizedType) {\n    ParameterizedType ptype = (ParameterizedType) type;\nif(c.getSimpleName().equals(\"Vector\")){\n    Class pta = (Class) ptype.getActualTypeArguments()[0];\n    Vector<what to put here> v = (Vector)field.get(obj);\n    if(v == null){\n        v = new Vector<what to put here>();\n        field.set(obj, v);\n    }\n....\nNumber of Java objects", "urls": ["https://www.techiedelight.com/why-vector-class-java-obsolete/"]}, "7252": {"text": "Calling the super.finalize() in the \"finally\" block of 'finalize ()' method is highly recommended in case parent implementations must also dispose some system resources.\n\nThis rule reports finalize method with no try finally block or with no call to super.finalize() within the finally block.\nCall 'super.finalize ()' in the \"finally\" block of 'finalize ()' methods\nThis report lists all Methods  'finalize()' with no try finally block or with no call to super.finalize() within the finally block.\nIt provides the following information:\n Method full name\nThe Java Language Specification states that it is a good practice for a finalize() method to call super.finalize().\n\nThe finalize method is careful to call super.finalize from a finally block. All finalize methods should call super.finalize to ensure that any superclass finalize methods are invoked. Unlike superclass constructors that are invoked automatically, finalize methods must be chained manually. The super.finalize call is made from a finally block to ensure that it is called regardless of whether the call to the cleanup method generates an exception.\nhttps://cwe.mitre.org/data/definitions/568.html\nhttps://wiki.sei.cmu.edu/confluence/display/java/MET12-J.+Do+not+use+finalizers\nAdd a try finally block.\nclass Test\n{\n // ...\n  protected void finalize() throws Throwable  {\n    try {\n      cleanup();\n    } finally { \n      super.finalize();  // FIXED: the finalize method will\n                               // execute the superclass finalizer \n                               // before re-throwing the IOException\n                               // object.\n    }\n  }\nclass Test\n{\n // ...\n  protected void finalize() throws Throwable {\n    cleanup();\n    super.finalize(); // VIOLATION\n  }\n}\nNumber of finalize methods", "urls": ["https://cwe.mitre.org/data/definitions/568.html", "https://wiki.sei.cmu.edu/confluence/display/java/MET12-J.+Do+not+use+finalizers"]}, "4706": {"text": "Number of violation occurrences\nHashtable is synchronized, whereas HashMap is not. This makes HashMap better for non-threaded applications, as unsynchronized Objects typically perform better than synchronized ones.\nIn additional, Hashtable does not allow null keys or values. HashMap allows one null key and any number of null values.\n\nAlso when it comes to threaded applications both thread safety and Performance is better in ConcurrentHashMap when compared to Hashtable.\n\nThis rule reports java artifacts using the Hashtable type, either as a parameter, or as a local variable.\nAvoid using Hashtable\nThis report lists all java artifacts using the Hashtable type, either as a parameter, or as a local variable.\nIt provides the following information:\n - Artifact full name\nSince Hashtables are all synchronized - yet synchronization is usually not needed -, they are much slower than the various List and Map implementations.\nEven if Synchronization is necessary, there is a better alternative to Hashtable - ConcurrentHashMap.\nhttps://www.javatpoint.com/difference-between-hashmap-and-hashtable\nhttps://medium.com/@mr.anmolsehgal/hashtable-vs-hashmap-vs-concurrenthashmap-4aa0ff1eecc4\nWhen synchronization is not needed, prefer using new unsynchronized replacement: HashMap instead of Hashtable\nWe can also use ConcurrentHashmap instead, but just note that ConcurrentHashmap is only available from java 1.5\nimport java.util.*; \nimport java.lang.*; \nimport java.io.*; \nclass Ideone \n{ \n    public static void main(String args[]) \n    { \n          \n        //----------------hashmap-------------------------------- \n        HashMap<Integer,String> hm=new HashMap<Integer,String>(); \n        hm.put(100,\"Amit\"); \n        hm.put(104,\"Amit\");  // hash map allows duplicate values \n        hm.put(101,\"Vijay\"); \n        hm.put(102,\"Rahul\"); \n        System.out.println(\"-----------Hash map-----------\"); \n        for (Map.Entry m:hm.entrySet()) { \n            System.out.println(m.getKey()+\" \"+m.getValue()); \n        } \n    } \n}\nimport java.util.*; \nimport java.lang.*; \nimport java.io.*; \n\nclass Ideone \n{ \n    public static void main(String args[]) \n    { \n        //----------hashtable ------------------------- \n        Hashtable<Integer,String> ht=new Hashtable<Integer,String>(); \n        ht.put(101,\" ajay\"); \n        ht.put(101,\"Vijay\"); \n        ht.put(102,\"Ravi\"); \n        ht.put(103,\"Rahul\"); \n        System.out.println(\"-------------Hash table--------------\"); \n        for (Map.Entry m:ht.entrySet()) { \n            System.out.println(m.getKey()+\" \"+m.getValue()); \n        } \n  \n        \n    } \n}\nNumber of Java artifacts", "urls": ["https://www.javatpoint.com/difference-between-hashmap-and-hashtable", "https://medium.com/@mr.anmolsehgal/hashtable-vs-hashmap-vs-concurrenthashmap-4aa0ff1eecc4"]}, "7682": {"text": "A domain model represents the business entities used in a Java application. In a layered system architecture, the domain model is used to execute business logic in the business layer. The domain model implementation is such an important piece of code that it shouldn\u2019t depend on other Java APIs\n\nThis rule checks if there is any direct calls or indirect(via successive) calls from persistent classes' artifact to the methods of the following packages:\n\n- java.sql.*\n- javax.sql.*\n- javax.naming.* (include javax.naming.directory, javax.naming.event, javax.naming.ldap, javax.naming.spi)\n- javax.jms.*\n\n\nNote that we don't take into account method parameters and exception that belongs to these packages.\n\nThis list of pakages/APIs to exclude can be extended using via the rule's paramter.\nAvoid having Hibernate domain model depending on other Java APIs\nList all persistent classes' artifact that call other JAVA API.\n\nIt provides the following information:\n Artifact Full Name\nThe domain model implementation is usually a central, organizing component; it's reused heavily whenever you implement new application functionality. For this reason, you should be prepared to go to some lengths to ensure that concerns other than business aspects don't leak into the domain model implementation. The domain model should be concerned only with modeling the business domain. When these concerns start to appear in the domain model classes, we call this an example of leakage of concerns.\nFor example, code in the domain model shouldn't perform JNDI lookups or call the database via the JDBC API. This allows you to reuse the domain model implementation virtually anywhere. Most importantly, it makes it easy to unit test the domain model (in JUnit, for example) outside of any application server or other managed environment.\nHibernate in Action (ISBN 1932394-15-X) p 64\nMake these calls in another layers.\n----> a.hbm.xml\n<hibernate-mapping >\n  \n  <class name=\"A\" table=\"A\" lazy=\"true\">\n    <id name=\"id\" column=\"A_ID\">\n      <generator class=\"increment\"/>\n    </id>\n  </class>\n\n</hibernate-mapping>\n\n----> Java Files\npublic class A {\n  private Integer id;\n\n  public Integer getId() {\n   \n  }\n  ...\n}\n----> a.hbm.xml\n<hibernate-mapping >\n  \n  <class name=\"A\" table=\"A\" lazy=\"true\">\n    <id name=\"id\" column=\"A_ID\">\n      <generator class=\"increment\"/>\n    </id>\n  </class>\n\n</hibernate-mapping>\n\n----> Java Files\npublic class A {\n  private Integer id;\n   javax.naming.Context ctx;  // VIOLATION\n  ...\n  public void aMethod() {\n    // VIOLATION\n    AnObject a = (AnObject) ctx.lookup(\"AnObject\");\n  }\n  ...\n}\nNumber of persistent classes's artifacts", "urls": []}, "7496": {"text": "Using table-per-class-hierarchy should be used only for very simple simple case. Otherwise, \"table-per-subclass\" strategy is recommended\nIf we choose to go for table per subclass because, in future if we want to introduce the common column we can do it at one place but in case other start\u00e9gy as table per concrete class we have to do it in multiple tables.\n\n\nThis rule reports all persistent entities (Hibernate or JPA) that don't use table-per-subclass strategy for its subclasses when the maximum added attributes of subclasses is greater or equal to 3. This number is a thresholds that can be changed as will.\n\nThis verification is limited to the first level of entities inheritance tree. For example, if the entity inheritance tree contains an entity C that inherit from entity B, that inherit from entity A. only the number of fields of entity B will be analyzed, not those from entity C.\nUse table-per-subclass strategy when subclasses have many properties\nList all Hibernate and/or Entities that don't use joined-subclass for its subclasses when the maximum added attributes of subclasses exceed the threshold parameter.\n\nIt provides the following information:\n Hibernate or JPA Entity Full Name\nIf you require polymorphic associations or queries, and subclasses declare many properties (subclasses differ mainly by the data they hold), lean toward the table-per-subclass approach.\n\nBy default, choose table-per-class-hierarchy for simple problems. For more complex cases (or when you're overruled by a data modeler insisting upon the importance of nullability constraints), you should consider the table-per-subclass strategy. But at that point, ask yourself whether it might be better to remodel inheritance as delegation in the object model. Complex inheritance is often best avoided for all sorts of reasons unrelated to persistence or ORM.\nHibernate in Action (ISBN 1932394-15-X) p 105\nUse the table-per-subclass strategy to map the hierarchy.\n<class name=\"Animal\" table=\"ANIMAL\">\n    <id name=\"id\" type=\"long\" column=\"ANIMAL_ID\">\n        <generator class=\"native\"/>\n    </id>\n    <property name=\"amount\" column=\"AMOUNT\"/>\n\n    // FIXED table-per-subclass strategy is used\n    <joined-subclass name=\"Dog\" table=\"DOG\">\n        <key column=\"DOG_ID\"/>\n        <property name=\"race\" column=\"RACE\"/>\n    </joined-subclass>\n\n    <joined-subclass name=\"Cat\" table=\"CAT\">\n        <key column=\"CAT_ID\"/>\n        <property name=\"color\" column=\"COLOR\"/>\n        <property name=\"country\" column=\"COUNTRY\"/>\n        <property name=\"age\" column=\"AGE\"/>\n        <property name=\"owner\" column=\"OWNER\">\n    </joined-subclass>\n</class>\n\n\n------------------\nRemediation for Sample2 \n\npackage com.javatpoint.mypackage;  \nimport javax.persistence.*;  \n  \n@Entity  \n@Table(name = \"employee103\")  \n@Inheritance(strategy=InheritanceType.JOINED) // Fixed ad strategy is used\n  \npublic class Employee {  \n@Id  \n@GeneratedValue(strategy=GenerationType.AUTO)  \n      \n@Column(name = \"id\")  \nprivate int id;  \n  \n@Column(name = \"name\")  \nprivate String name;\nSample1 xml based:  animal.hbm.xml\n\n<class name=\"Animal\" table=\"ANIMAL\">\n    <id name=\"id\" type=\"long\" column=\"ANIMAL_ID\">\n        <generator class=\"native\"/>\n    </id>\n    <discriminator column=\"TYPE\" type=\"string\"/>\n    <property name=\"amount\" column=\"AMOUNT\"/>\n\n    // VIOLATION: one of the subclass attributes count \n    // is greater or equal to 3 and table-per-subclass\n    // strategy is not used\n\n    <subclass name=\"Dog\" discriminator-value=\"DOG\">\n        <property name=\"race\" column=\"RACE\"/>\n    </subclass>\n\n    <subclass name=\"Cat\" discriminator-value=\"CAT\">\n        <property name=\"color\" column=\"COLOR\"/>\n        <property name=\"country\" column=\"COUNTRY\"/>\n        <property name=\"age\" column=\"AGE\"/>\n        <property name=\"owner\" column=\"OWNER\">\n    </subclass>\n</class>\n-----------------------------------------------\n\nSample2 Annotation based\n\npackage com.javatpoint.mypackage;  \n  \nimport javax.persistence.*;  \n  \n@Entity  \n@Table(name=\"regularemployee103\")  \n@PrimaryKeyJoinColumn(name=\"ID\")   // VIOLATION as strategy is not used\npublic class Regular_Employee extends Employee{  \n      \n@Column(name=\"salary\")    \nprivate float salary;  \n  \n@Column(name=\"bonus\")     \nprivate int bonus;\nNumber of hibernate and/or JPA entities that are subclassed (subclass or joined-subclass) and that are not inheriting from another entity", "urls": []}, "7710": {"text": "This rule checks that Entity beans implement Serializable or they inherit from a serializable class. If not, it reports violation.\nAvoid non serializable Entity beans\nThis report lists all entity bean implementation classes that are not serializable.\n\nIt provides the following information:\n     Class Full Name\nWhen Entity bean instance is to be passed by value as a detached object (e.g., through a remote interface), the entity class must implement the Serializable interface.\nAlso, In some cases an OptimisticLockException will be thrown and wrapped by another exception, such as a RemoteException, when VM boundaries are crossed. Entities that may be referenced in wrapped exceptions should be Serializable so that marshalling will not fail.\n\nThis issue can prevent the software from running reliably, e.g. by triggering an exeption. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\nJSR 220: Enterprise JavaBeansTM,Version 3.0 - Java Persistence API : Requirements on the Entity Class page 17.\nImplement Serializable and verify that each its instance variables implement serializable unless they inherit from a class that is serializable, is a transient field or a Java primitives..\n@Entity\npublic class ABean implements Serializable { // FIXED\n    private String str;\n    private aClass field;\n\n}\n\n--------------------------------------\n@Entity\npublic class ABean extends Bbean { \n    private String str;\n    private aClass field; // FIXED\n\n}\n\npublic class Bbean implements serializable {\n \n}\n@Entity\npublic class ABean  { // VIOLATION\n    private String str;\n    private aClass field;\n}\n\n--------------------------------------\n@Entity\npublic class ABean extends Bbean { \n    private String str;\n    private aClass field;\n    // violation as this class extends a class which doesnt implement serializable \n\n}\n\npublic class Bbean {\n \n}\nNumber of entities", "urls": []}, "7444": {"text": "Session Bean Name\nThe application stores a non-serializable object as an HttpSession attribute, which can hurt reliability.\nThis rule reports classes that are not serialized (i.e. don't implement or inherit from the java.io.Serializable interface) and that are instantiated by beans stored in the session. This includes JSP beans and also JSF backing beans.\nAvoid Using Non-Serialized Beans with Session Scope\nReport all classes that don't implement (or inherit from) Serializable interface and that instantiated as session scope objects.\nIt provides the following information:\n  - Full Class Name\n  - Session Bean Name\nA JEE application can make use of multiple JVMs in order to improve application reliability and performance. In order to make the multiple JVMs appear as a single application to the end user, the JEE container can replicate an HttpSession object across multiple JVMs so that if one JVM becomes unavailable another can step in and take its place without disrupting the flow of the application. This is only possible if all session data is serializable, allowing the session to be duplicated between the JVMs.\nhttps://cwe.mitre.org/data/definitions/579.html\n\nhttps://www.tutorialspoint.com/jsp/jsp_java_beans.htm#:~:text=Selected%20Reading-,JSP%20%2D%20JavaBeans,default%2C%20no%2Dargument%20constructor.\n\nhttps://stackoverflow.com/questions/3142181/why-java-beans-have-to-be-serializable\nImplement serialization if your web container implements such mechanisms or ignore it in others cases.\n----> for JSF \n      myBean.java:\n// FIXED: the interface Serializable is implemented\npublic class MyBean implements Serializable {\n    // Properties\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n-----> for JSP\n// FIXED: the interface Serializable is implemented\npublic class SampleBean implements Serializable {\n     \n    private String param1;\n    private Date param2 = new Date();\n     \n    public String getParam1() {\n        return param1;\n    }\n    public void setParam1(String param1) {\n        this.param1 = param1;\n    }\n     \n    public Date getParam2() {\n        return param2;\n    }\n    public void setParam2(Date param2) {\n        this.param2 = param2;\n    }\n     \n    @Override\n    public String toString() {\n        return \"SampleBean [param1=\" + param1 + \", param2=\" + param2 + \"]\";\n    }\n \n}\nSample for JSF:\n----> faces-config.xml:\n<managed-bean>\n    <managed-bean-name>myBean</managed-bean-name>\n    <managed-bean-class>com.cast.MyBean</managed-bean-class>\n    <managed-bean-scope>session</managed-bean-scope>\n</managed-bean>\n\n----> myBean.java:\n// VIOLATION: the class associate to a backing bean \n// does not implement the interface Serializable\npublic class MyBean {\n    // Properties\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n----------------------------------------------------------\nfor JSP\n\n<%@ page language=\"java\" contentType=\"text/html;charset=UTF-8\" %>\n<%@ page import=\"com.javacodegeeks.snippets.enterprise.SampleBean\"%>\n \n<html>\n \n<head>\n    <title>Java Code Geeks Snippets - Use a Bean in JSP Page</title>\n</head>\n \n<body>\n \n    <jsp:useBean id=\"sampleBean\" class=\"com.javacodegeeks.snippets.enterprise.SampleBean\" scope=\"session\">\n        <%-- intialize bean properties --%>\n        <jsp:setProperty name=\"sampleBean\" property=\"param1\" value=\"value1\" />\n    </jsp:useBean>\n     \n    Sample Bean: <%= sampleBean %>\n     \n    param1: <jsp:getProperty name=\"sampleBean\" property=\"param1\" />\n    param2: <jsp:getProperty name=\"sampleBean\" property=\"param2\" />\n \n</body>\n\npublic class SampleBean { // Violation\n     \n    private String param1;\n    private Date param2 = new Date();\n     \n    public String getParam1() {\n        return param1;\n    }\n    public void setParam1(String param1) {\n        this.param1 = param1;\n    }\n     \n    public Date getParam2() {\n        return param2;\n    }\n    public void setParam2(Date param2) {\n        this.param2 = param2;\n    }\n     \n    @Override\n    public String toString() {\n        return \"SampleBean [param1=\" + param1 + \", param2=\" + param2 + \"]\";\n    }\n \n}\nNumber of beans in the session scope", "urls": ["https://cwe.mitre.org/data/definitions/579.html", "https://www.tutorialspoint.com/jsp/jsp_java_beans.htm#:~:text=Selected%20Reading-,JSP%20%2D%20JavaBeans,default%2C%20no%2Dargument%20constructor.", "https://stackoverflow.com/questions/3142181/why-java-beans-have-to-be-serializable"]}, "7942": {"text": "To avoid unpredictable behavior, this rule raises violation when an EJB artifact (Entity Java Bean , Session Java Bean ,Message Driven Java Bean) \n- is calling one of following methods 'wait()', 'notify()' and notifyAll() \nor \n- is defining method(s) with the 'synchronized' qualifier ( Note that for synchronized qualifier, we only check the keyword synchronized but we don't consider the case where there is a block synchronized in the method)\nAvoid EJBs using 'synchronized' qualifier, 'wait', 'notify' and 'notifyAll' Methods\nThis report lists all EJB artifact that use 'synchronized' keyword or call 'wait', 'notify' or 'notifyAll' methods.\nIt provides the following information:\n Artifact full name\nThe Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the program violates the following EJB guideline: \"An enterprise bean must not use thread synchronization primitives to synchronize execution of multiple instances.\" The specification justifies this requirement in the following way: \"This rule is required to ensure consistent runtime semantics because while some EJB containers may use a single JVM to execute all enterprise bean's instances, others may distribute the instances across multiple JVMs.\"\nAlso, calling 'wait', 'notify' and 'notifyAll' from EJB methods might corrupt the normal behavior of the application server as It is ambiguous which thread will wake up when notify() is called for exemple.\nhttps://cwe.mitre.org/data/definitions/574.html\nReview EJB design\n@Entity\npublic class Customer implements Serializable {\nprivate String id;\nprivate String firstName;\nprivate String lastName;\nprivate Address address;\npublic Customer() {...}\npublic Customer(String id, String firstName, String lastName) {...}\n\n@Id\npublic String getCustomerId() {...}\npublic  void setCustomerId(String id) {...}\npublic String getFirstName() {...}\npublic  void setFirstName(String firstName) {...}\npublic String getLastName() {...}\npublic  void setLastName(String lastName) {...}\n@OneToOne()\npublic Address getAddress() {...}\npublic void setAddress(Address address) {...}\n}\n@Entity\npublic class Customer implements Serializable {\nprivate String id;\nprivate String firstName;\nprivate String lastName;\nprivate Address address;\npublic Customer() {...}\npublic Customer(String id, String firstName, String lastName) {...}\n\n@Id\npublic String getCustomerId() {...}\npublic synchronized void setCustomerId(String id) {...}\npublic String getFirstName() {...}\npublic synchronized void setFirstName(String firstName) {...}\npublic String getLastName() {...}\npublic synchronized void setLastName(String lastName) {...}\n@OneToOne()\npublic Address getAddress() {...}\npublic synchronized void setAddress(Address address) {...}\n}\n\nThe use of synchronized methods violate the restriction of the EJB specification against the use synchronization primitives within EJBs. This may cause inconsistent behavior of the EJB when used within different EJB containers.\nNumber of EJB Artifacts", "urls": ["https://cwe.mitre.org/data/definitions/574.html"]}, "4678": {"text": "Undocumented Exceptions\nWhen enforcing the utilization of JavaDoc Comments to document an application, the @exception tags should be used to document the exceptions being thrown by a given Method. The number of exception thrown should match the number of @exception.\nIn JavaDoc, the @exception tag is deprecated and has been replaced by the @throws tag.\nDEPRECATED: Public Methods must have appropriate JavaDoc @exception tags\nThis report lists all Methods not having the appropriate @exception JavaDoc comments.\nThis report provides the following information:\n - Method full name\n - Undocumented Exceptions\nThere is no dispute that these comments contribute to a developer's understanding and help a developer write reliable applications more quickly. Without documenting exception thrown it is difficult for anyone else than the author to guess its purpose and consequences except by looking at the code that is throwing it.\nAdd a @exception with a description for each method.\nNumber of methods that throw exceptions", "urls": []}, "2260": {"text": "File directory\nAll script files (X) should be in a \"script\" directory, located in the web root.\nDEPRECATED: All script files should be in a specific directory\nThis report lists all script files (X) located outside the \"script\" directory. It provides the following information: File full name, File directory\nFor maintainability aspects, file organization must be respected.\nhttps://www.oracle.com/technical-resources/articles/javase/code-convention.html\nChange file location according to the recommended naming convention.\nNumber of JS Scripts", "urls": ["https://www.oracle.com/technical-resources/articles/javase/code-convention.html"]}, "7142": {"text": "Number of public methods\nClasses that inherit from org.apache.struts.action.Action with more than one public method will be listed. Exception to this rule: \n- all classes that inherit from org.apache.struts.action.DispatchAction that is specifically designed to group related actions into a single class and have more than one public method to handle each operation.\n- all Action class that are also Spring Beans: in this case, setter methods are excluded from the violations\nDEPRECATED: Action Classes should have only one public method\nThis report lists all Action Classes with more than one public method.\nIt provides the following information:\n - Action Class full name\n - public method number\nAction Classes should have only 1 public method, this eases struts usage (one function for one action).\nReview the architecture of the application  and have action Classes that have only 1 public method\nNumber of action classes, except those inheriting from dispatchaction", "urls": []}, "7712": {"text": "This rule report all the setter methods of a persistent class that set the primary key and NOT declared as private \n\nThe exceptions to this rule are where the identifier must be set by the application  ( Instead of set by Hibernate, another JPA implementation or by other provider). \n\nThe field is determined by the <id> element in the mapping document (in the hibernate mapping XML files or the orm.xml file of JPA) or the @Id annotation in JPA. \n\nThis field must be set by the application when:\n\n- the property: generator class is set to \"assigned\" \n- or when the annotation @GeneratedValue (javax.persistence.GeneratedValue) has not been set for the identifier field\n- or when the attribute generated-value has not been set for the identifier field in the orm.xml file\n\nExample: \n- hibernate standard\n<id name=\"username\" column=\"USERNAME\">\n      <generator class=\"assigned\"/>\n</id>\n\n- JPA annotation\n@Id\n// No @GeneratedValue declaration\nString username;\n\n- JPA with orm.xml file\n<id name=\"username\">\n    <column name=\"USERNAME\"/>\n    <!-- no generated-value declaration -->\n</id>\nAvoid public/protected setter for the generated identifier field\nList all setter methods of a persistent class that set the primary key and is not declared as private.\n\nIt provides the following information:\n Method full name\nA primary key value must never change after it's first assigned. Since it is a generated key, it is automatically set by Hibernate, another JPA implementation or by other provider.\nThe actual behavior when an application tries to modify the value of a primary key is not defined.\nHibernate in Action (ISBN 1932394-15-X) p 89\nJava Persistence with Hibernate (ISBN 1-932394-88-5) p 163\nThe Java Persistence API ( ISBN 1-932394-88-5) p 163, 416\nhttp://docs.jboss.org/hibernate/core/3.3/reference/en/html/tutorial.html#tutorial-firstapp-firstclass\nhttp://burtbeckwith.com/blog/?p=53\nUsually declare the setter method private\n------> Sample.java:\npublic class Sample {\n   private long id;\n...\n\n  private void setId(long id) { // FIXED\n     this.id = id;\n  }\n\n   public Long getId() {\n      return id;\n   }\n}\n------> sample.hbm.xml:\n...\n<class name=\"Sample\" table=\"SAMPLE\">\n           <id name=\"id\" column=\"id\" type=\"long\">\n                  <generator class=\"sequence\"/>\n           </id>\n           ...\n</class>\n\n------> Sample.java:\npublic class Sample {\n   private long id;\n...\n\n  public void setId(long id) { // VIOLATION\n     this.id = id;\n  }\n\n   public Long getId() {\n      return id;\n   }\n}\nNumber of setter methods of a persistent class that set the primary key", "urls": ["http://docs.jboss.org/hibernate/core/3.3/reference/en/html/tutorial.html#tutorial-firstapp-firstclass", "http://burtbeckwith.com/blog/?p=53"]}, "7500": {"text": "This rule reports all persistent (Hibernate & JPA) entities that don't use table-per-class-hierarchy strategy for its subclasses when the maximum added attributes of subclasses don't exceed 3. This number is a thresholds that can be changed as will.\n\nThis verification is limited to the first level of entities inheritance tree. For example, if the entity inheritance tree contains an entity C that inherit from entity B, that inherit from entity A. only the number of fields of entity B will be analyzed, not those from entity C.\nUse table-per-class-hierarchy when subclasses have few properties\nList all Hibernate and/or JPA Entities that don't use table-per-class-hierarchy strategy for its subclasses when the maximum added attributes of subclasses don't exceed the threshold parameter.\n\nIt provides the following information:\n Hibernate and/or JPA Entity Full Name\nIf you require polymorphic associations (an association to a superclass, hence to all classes in the hierarchy with dynamic resolution of the concrete class at runtime) or queries, and sub-classes declare relatively few properties (particularly if the main difference between subclasses is in their behavior), lean toward the table-per-class-hierarchy model.\nHibernate in Action (ISBN 1932394-15-X) p 105\n\nhttps://www.javatpoint.com/hibernate-table-per-concrete-class-using-annotation-tutorial-example\nUse the table-per-class-hierarchy strategy to map the hierarchy.\n<class name=\"Animal\" table=\"ANIMAL\">\n    <id name=\"id\" type=\"long\" column=\"ANIMAL_ID\">\n        <generator class=\"native\"/>\n    </id>\n    <discriminator column=\"TYPE\" type=\"string\"/>\n    <property name=\"amount\" column=\"AMOUNT\"/>\n\n    // FIXED: table-per-class-hierarchy strategy is used\n    <subclass name=\"Dog\" discriminator-value=\"DOG\">\n        <property name=\"race\" column=\"RACE\"/>\n    </subclass>\n\n    <subclass name=\"Cat\" discriminator-value=\"CAT\">\n        <property name=\"color\" column=\"COLOR\"/>\n    </subclass>\n</class>\n\n----------------------------------------------------------\nsample2:  Annotation Based\n\n@Entity  \n@Table(name = \"employee102\")  \n@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)  \n  \npublic class Employee {  \n@Id  \n@GeneratedValue(strategy=GenerationType.AUTO)  \n      \n@Column(name = \"id\")  \nprivate int id;  \n  \n@Column(name = \"name\")  \nprivate String name;  \n  \n//setters and getters  \n}\n----> sample1 xml based: animal.hbm.xml\n\n<class name=\"Animal\" table=\"ANIMAL\">\n    <id name=\"id\" type=\"long\" column=\"ANIMAL_ID\">\n        <generator class=\"native\"/>\n    </id>\n\n    <property name=\"amount\" column=\"AMOUNT\"/>\n\n     // VIOLATION none of the subclass attributes count \n     // is greater or equal to 3 and \n     // table-per-class-hierarchy strategy is not used\n\n    <joined-subclass name=\"Dog\" table=\"DOG\">\n        <key column=\"DOG_ID\"/>\n        <property name=\"race\" column=\"RACE\"/>\n    </joined-subclass>\n\n    <joined-subclass name=\"Cat\" table=\"CAT\">\n        <key column=\"CAT_ID\"/>\n        <property name=\"color\" column=\"COLOR\"/>\n    </joined-subclass>\n</class>\n\n-----------------------------------------------------\nsample2 - Annotation based\n\npackage com.javatpoint.mypackage;  \nimport javax.persistence.*;  \n  \n@Entity  \n@Table(name = \"employee103\")  \n@Inheritance(strategy=InheritanceType.JOINED) // Fixed ad strategy is used\n  \npublic class Employee {  \n@Id  \n@GeneratedValue(strategy=GenerationType.AUTO)  \n      \n@Column(name = \"id\")  \nprivate int id;  \n  \n@Column(name = \"name\")  \nprivate String name;\nNumber of hibernate and/or JPA entities that are subclassed (subclass or joined-subclass) and that are not inheriting from another entity", "urls": ["https://www.javatpoint.com/hibernate-table-per-concrete-class-using-annotation-tutorial-example"]}, "4694": {"text": "This rule reports all java artifacts that call java.lang.System.gc() and java.lang.Runtime.gc()\nAvoid using 'System.gc' and 'Runtime.gc'\nThis report lists all java artifacts using the 'java.lang.System.gc' Method.\nIt provides the following information:\n - Artifact full name\nThe garbage collector should not be used explicitly in the code. It is an automated process scheduled by the Java Runtime Environment. System.gc() triggers a full collection, which includes tracing all live objects in the heap and sweeping and compacting the old generation. Lot of time can be spent during this operation. In general, it is better to let the system decide when it needs to collect the heap, and whether or not to do a full collection.\nhttps://help.semmle.com/wiki/display/JAVA/Explicit+garbage+collection#:~:text=You%20should%20avoid%20making%20calls,that%20lead%20to%20decreased%20performance.\nEnsure to let the system decide when it needs to collect the heap, and whether or not to do a full collection\npublic class DemoApplication {\n \n    private static final Map<String, String> cache = new HashMap<String, String>();\n \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n \n        while (scanner.hasNext()) {\n            final String next = scanner.next();\n            if (\"fill\".equals(next)) {\n                for (int i = 0; i < 1000000; i++) { \n                    cache.put(randomUUID().toString(), randomUUID().toString()); \n                } \n            } else if (\"invalidate\".equals(next)) {\n                cache.clear();\n            } else if (\"gc\".equals(next)) {\n                 System.out.println(\"known\")\n            } else if (\"exit\".equals(next)) {\n                System.exit(0);\n            } else {\n                System.out.println(\"unknown\");\n            }\n        }\n    }\n}\npublic class DemoApplication {\n \n    private static final Map<String, String> cache = new HashMap<String, String>();\n \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n \n        while (scanner.hasNext()) {\n            final String next = scanner.next();\n            if (\"fill\".equals(next)) {\n                for (int i = 0; i < 1000000; i++) { \n                    cache.put(randomUUID().toString(), randomUUID().toString()); \n                } \n            } else if (\"invalidate\".equals(next)) {\n                Runtime.gc();\n            } else if (\"gc\".equals(next)) {\n                System.gc();\n            } else if (\"exit\".equals(next)) {\n                System.exit(0);\n            } else {\n                System.out.println(\"unknown\");\n            }\n        }\n    }\n}\n\n\nThe Java Language Specification does not guarantee that the JVM will start a GC when you call System.gc(). Most of JVM has a garbage collector that runs continuously, so a call to System.gc() won't do anything\nNumber of non abstract Java artifacts", "urls": ["https://help.semmle.com/wiki/display/JAVA/Explicit+garbage+collection#:~:text=You%20should%20avoid%20making%20calls,that%20lead%20to%20decreased%20performance."]}, "4718": {"text": "Number of Classes and Interfaces\nA Package should not have more than X and less than Y Public Classes/interfaces. The parameters X and Y, maximum number and minimum number can be customized at will.\nAvoid having package without enough Classes/Interfaces\nThis report lists all Packages having more than X and less than Y Public Classes or Interfaces.\nIt provides the following information:\n - Package full name\n - Number of Classes and Interfaces\nPackages must have a reasonable size when measured in number of Classes/interfaces.\nEnrich your package with other Classes/Interfaces or merge two similar packages into a bigger one.\nNumber of Java packages", "urls": []}, "4716": {"text": "Number of implemented interfaces\nThis rule reports Java Classes implementing more than X Interfaces\nAvoid Classes implementing too many Interfaces (JEE)\nThis report lists all Classes implementing more than X Interfaces\nIt provides the following information:\n - Class full name\n - Number of implemented interfaces\nClasses implementing more than X Interfaces are not a good practice in the application architecture.\nReview the design to reduce the number of implementations\npackage diag.arch004;\npublic class Ci_OK_2_3_i1\n{\n    public void myMethod()\n    {\n        \n    }\n    public class CInner_OK_2_3_i1 implements I01_20\n    {\n        public void myMethodI01_20()\n        {        \n        }  \n    }\n}\npackage diag.arch004;\npublic class Cs_OK_3_3_i6 implements I01_20,I02_20,I03_20,I04_20,I05_20,I06_20\n{\n    public void myMethod()\n    {\n        \n    }\n\n    public void myMethodI01_20()\n    {        \n    }\n\n    public void myMethodI02_20()\n    {\n    }\n\n    public void myMethodI03_20()\n    {\n    }\n\n    public void myMethodI04_20()\n    {\n    }\n\n    public void myMethodI05_20()\n    {\n    }\n\n    public void myMethodI06_20()\n    {\n    }\n}\nNumber of Java classes", "urls": []}, "7734": {"text": "Invoking a debug method in production must be preceded by a call to its corresponding isDebugEnabled method. If not, a violation will be reported by this rule.\n\nFollow, the list of debug and corresponding isDebugEnabled methods considered in this rule : \n- org.apache.log4j.Category.debug corresponding to org.apache.log4j.Category. isDebugEnabled().\n- org.apache.commons.logging.Log.debug corresponding to org.apache.commons.logging.Log.isDebugEnabled().\n- java.util.logging.Logger.finest corresponding to java.util.logging.Logger.isLoggable\n- org.slf4j.logger.debug corresponding to org.slf4j.logger.isDebugEnabled()\n\nPlease note that two thresholds permit to add a list of fully qualified debug methods and isDebugEnabled methods name. A debug method name in the list must have its corresponding isDebugEnabled name at the same index.\nAvoid using debug() method without calling isDebugEnabled() method\nThis report lists all methods that violate this rule.\nIt provides the following information:\n Method Full Name, the number of call to debug() without a call to  isDebugEnabled()\nWhile disabling debug logging level in production, it still impacts performance of your application because the method invocation involves the hidden cost of parameter construction.\n\nFor example: << cat.debug(\"Entry number: \" + i + \" is \" + String.valueOf(entry[i])) >> incurs the cost of constructing the message parameter that is converting both integer i and entry[i] to a String and concatenating intermediate strings, regardless of whether the message will be logged or not.\nhttp://burtbeckwith.com/blog/?cat=8\nAdd a if condition with a call to  isDebugEnabled() before calling any .debug().\nRemediation Sample#1\n\n\npackage com.JAVAEMNDS006;\n\nimport java.util.function.Predicate;\nimport java.util.logging.Level;\n\npublic class Logdebug_OkFinest\n{\n    private java.util.logging.Logger    logger;\n    \n    /**\n     * this method is OK because log to FINEST level is performed after checking taht FINEST level is active).\n     */\n    public void okFinestLog()\n    {\n        Predicate<String> log = x -> {\n        if (logger.isLoggable(Level.FINEST))\n            logger.finest(\"XXX\");\n        return true;\n        };\n    }\n    \n    public void okNotFinestLog()\n    {\n        logger.info(\"XXX\");\n    }\n}\n\n----------------------------------------------------------------------------------------------------------\nRemediation Sample#2\n\npackage com.JAVAEMNDS006;\n\nimport java.util.function.Predicate;\n\nimport org.apache.log4j.Logger;\n\n/**\n * oKDebugCommons is OK because it tests isDebugEnabled() before calling debug\n * \n *\n */\npublic class Logdebug_OkDebugCommons\n{\n    public boolean koDebugCommons1_1()\n    {\n    Predicate<String> log = x -> {\n        \n        Logger logger = Logger.getLogger(\"xxx\");\n        if(logger.isDebugEnabled())\n            logger.debug(\"XXXX\");    \n            return true;\n        };\n        return log.test(\"com\");\n    }\n}\n---------------------------------------------------------------------------------------------------------------Remediation \nRemediation Sample#3\n\n\npackage com.JAVAEMNDS006;\n\nimport java.util.function.Predicate;\n\nimport org.apache.log4j.Category;\n\n/**\n * all three methods are OK, because they properly test isDebugEnabled\n *  *\n */\npublic class Logdebug_Ok4jClass\n{\n    private Category tracer = Category.getInstance(this.getClass());\n    public void okDebug(String message)\n    {\n        Predicate<String> log = x -> {\n            if (tracer.isDebugEnabled())\n            tracer.debug(message+\" \"+System.currentTimeMillis());\n            return true;\n        };\n    }\n    \n    public void okDebug(Exception exception)\n    {\n        Predicate<String> log = x -> {\n            if (tracer.isDebugEnabled())\n            tracer.debug(exception);\n            return true;\n        };\n    }\n    \n    public void okDebug2(Exception exception)\n    {\n        Predicate<String> log = x -> {\n            if (!tracer.isDebugEnabled())\n            tracer.debug(exception);\n            return true;\n    };\n    }\n    \n    public void okNotDebugging(Exception exception)\n    {\n        tracer.fatal(exception);\n    }\n}\nSample#1\n\npackage com.JAVAEMNDS006;\n\nimport java.util.function.Predicate;\n\nimport org.apache.log4j.Category;\n\n/**\n * all 3 methods are KO\n *     none of them test isDebugEnabled before calling debug\n \n */\npublic class Logdebug_Ko4jClass\n{\n    private Category    tracer    = Category.getInstance(this.getClass());\n\n    public boolean koDebug1_3(String message)\n    {\n        Predicate<String> log = x -> {\n            \n            tracer.debug(message + \" \" + System.currentTimeMillis());\n        \n        return true;\n        };\n        return log.test(\"com\");\n    }\n\n    public boolean koDebug2_3(Exception exception)\n    {\n        Predicate<String> log = x -> {\n            \n            tracer.debug(exception);\n            return true;\n        };\n        return log.test(\"com\");\n    }\n\n    public boolean koDebug3_3(Exception exception)\n    {\n        Predicate<String> log = x -> {\n            if (tracer.isInfoEnabled())\n        \n            tracer.debug(exception);\n            return true;\n    };\n    return log.test(\"com\");\n    }\n}\n------------------------------------------------------------------------------------------------------------\nSample#2\n\npackage com.JAVAEMNDS006;\n\nimport java.util.function.Predicate;\n\nimport org.apache.log4j.Logger;\n\n/**\n * the koDebugCommons method is KO because it does not test log.isDebugEnabled() \n * \n *\n */\npublic class Logdebug_KoDebugCommons\n{\n     \n    public boolean koDebugCommons1_1()\n    {\n    Predicate<String> log = x -> {\n        Logger logger = Logger.getLogger(\"xxx\");\n    \n            logger.debug(\"XXXX\");    \n            return true;\n        };\n        return log.test(\"com\");\n    }\n}\n--------------------------------------------------------------------------------------------------------\nSample#3\n\npackage com.JAVAEMNDS006;\n\nimport java.util.function.Predicate;\nimport java.util.logging.Logger;\n\npublic class Logdebug_KoFinest\n{\n\n    private Logger    logger;\n\n    /**\n     * This method is KO,because log is performed to Finest level without testing that this level is enabled\n     */\n    public void koFinestLog1_1()\n    {\n        Predicate<String> log = x -> {\n        logger.finest( \"XXX\");\n        return true;\n    };\n    \n}\n}\nNumber of methods that call debug() methods", "urls": ["http://burtbeckwith.com/blog/?cat=8"]}, "4666": {"text": "When enforcing the utilization of JavaDoc Comments to document an application, all Classes and Interfaces must have JavaDoc Comments. These comments must be defined just before the declaration of the Class or Interface, with the appropriate structure (/** */)\nClasses and Interfaces must have JavaDoc Comments\nThis report lists all Classes and Interfaces not having JavaDoc comments.\nThis report provides the following information:\n Class or Interface Full Name\nThere is no dispute that these comments contribute to a developer's understanding and help a developer write reliable applications more quickly. Without documenting classes and interfaces it is dififcult for anyone else than the author to guess the purpose of the class or interface except by looking at the code and eventually the code called by the methods in the class.\nhttps://www.tutorialspoint.com/java/java_documentation.htm\n\nhttps://www.oracle.com/technical-resources/articles/java/javadoc-tool.html\nAdd JDK javadoc tool doc comments(/** documentation */ ) when preparing automatically generated documentation.\nRemediation Sample#1\n/**\n * @author PYG\n *\n * TODO To change the template for this generated type comment go to\n * Window - Preferences - Java - Code Style - Code Templates\n */\npublic interface OK_InterfaceComment\n{\n\n}\n---------------------------------------------------------------------\nRemediation Sample#2\npackage diag.doc001;\n\n/**\n * @author PYG\n *\n * TODO To change the template for this generated type comment go to\n * Window - Preferences - Java - Code Style - Code Templates\n */\npublic class OK_ClassComment\n\n{\n}\nSample#1\npackage diag.doc001;\n\n//\n// @author PYG\n//\npublic class KO_1_5ClassComment_2SLASH\n{\n\n}\n--------------------------------------------\nSample#2\n\npackage diag.doc001;\n\n/*\n * \n * @author PYG\n *\n * TODO To change the template for this generated type comment go to\n * Window - Preferences - Java - Code Style - Code Templates\n */\n----------------------------------------------\nSample#3\npublic class KO_2_5ClassComment_OneStar\n{\n}\n\n\npackage diag.doc001;\n\n//**\n// * @author PYG\n// *\n\npublic interface KO_1_5InterfaceComment_2Slash\n{\n\n}\n--------------------------------------------------------\nSample#4\n\n/*\n * \n */\npackage diag.doc001;\n\n/*\n * @author PYG\n *\n * TODO To change the template for this generated type comment go to\n * Window - Preferences - Java - Code Style - Code Templates\n */\npublic interface KO_2_5InterfaceComment_OneStar\n{\n\n}\nNumber of classes and interfaces (generic or not)", "urls": ["https://www.tutorialspoint.com/java/java_documentation.htm", "https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html"]}, "4596": {"text": "The rule reports all Java artifacts using 'java.lang.System.getenv()'\nAvoid using 'java.lang.System.getenv()'\nThis report lists all java artifacts using 'java.lang.System.getenv()'.\nIt provides the following information:\n - Artifact full name\nFor portability reasons, in Web applications, 'java.lang.System.getenv()' should not be used since it means using Operating System variables and therefore being dependent on the environment where the application is deployed.\nhttps://www.tutorialspoint.com/java/lang/system_getenv_string.htm\n\nhttps://wiki.sei.cmu.edu/confluence/display/java/ENV02-J.+Do+not+trust+the+values+of+environment+variables\nPrefer using property files.\npackage com.logicbig.example.system;\n\nimport java.util.Map;\n\npublic class GetenvExample {\n\n    public static void main(String... args) {\n        Map<String, String> map = System.getenv();\n        map.entrySet().forEach(System.out::println);\n    }\n}\n\n-----------------------------------------------------------\n\npublic class SystemSample {\n\n   public static void main(String[] args) throws Exception {\n\n      // gets the value of the specified environment variable \"PATH\"\n      System.out.println(\"System.getenv(\"PATH\") = \");\n      System.out.println(System.getenv(\"PATH\"));\n\n      // gets the value of the specified environment variable \"TEMP\"\n      System.out.print(\"System.getenv(\"TEMP\") = \");\n      System.out.println(System.getenv(\"TEMP\"));\n\n      // gets the value of the specified environment variable \"USERNAME\"\n      System.out.print(\"System.getenv(\"USERNAME\") = \");\n      System.out.println(System.getenv(\"USERNAME\"));\n   }\n}\nNumber of Java artifacts", "urls": ["https://www.tutorialspoint.com/java/lang/system_getenv_string.htm", "https://wiki.sei.cmu.edu/confluence/display/java/ENV02-J.+Do+not+trust+the+values+of+environment+variables"]}, "4600": {"text": "Java artifacts should not use 'java.System.exit()' or 'Runtime.getRuntime().exit(0)' or 'Runtime.getRuntime().halt(0)'  for application deployed on a Web Server or an Application Server (when web.xml and/or ejb-jar.xml file are present)\n\n.\nAvoid using Exit and Halt Methods on a Web/Application Server\nThis report lists  Java methods call or using 'java.System.exit()', 'Runtime.getRuntime().exit(0)' or 'Runtime.getRuntime().halt(0)'\nIt provides the following information:\n\n - method full name\nUsing the exit and halt methods in web application is a bad idea because it terminates not only program but also the Java Virtual Machine. Therefore it will shutdown the current application as well as other critical applications if any, running in the same JVM. This can result in DoS (Denial Of Service) attacks. Additionally, programs should perform necessary cleanup actions when forcibly terminated.\nhttp://cwe.mitre.org/data/definitions/382.html\n\nhttps://wiki.sei.cmu.edu/confluence/display/java/ERR09-J.+Do+not+allow+untrusted+code+to+terminate+the+JVM\n\nhttps://javarevisited.blogspot.com/2014/11/dont-use-systemexit-on-java-web-application.html\n\nhttps://www.baeldung.com/java-system-exit\n\nhttps://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html\nDon't use 'java.System.exit()', 'Runtime.getRuntime().exit(0)' and 'Runtime.getRuntime().halt(0)' to know what happened when you exit your program\npublic class ok_UseExit\n{\n    {\n        if (System.currentTimeMillis() >500000)\n           return; \n    }\n    \n    public OK_UseExit()\n    {\n        return;\n    }\n    \n    public void ok_go()\n    {\n         return;\n    }\n}\nsample #1\n\npublic class KO_UseExit\n{\n    {\n        if (System.currentTimeMillis() >500000)\n            System.exit(0);\n    }\n    \n    public KO_UseExit()\n    {\n        System.exit(0);\n    }\n    \n    public void ko_go()\n    {\n        System.exit(0);\n    }\n}\n\n-------------------------------------------------\nsample # 2\n\npublic class KO_UseExit\n{\n    {\n        if (System.currentTimeMillis() >500000)\n           Runtime.getRuntime().exit(0);\n    }\n    \n    public KO_UseExit()\n    {\n       Runtime.getRuntime().exit(0);\n    }\n    \n    public void ko_go()\n    {\n     Runtime.getRuntime().exit(0);\n    }\n}\n\n\n--------------------------------------------------------\n\nsample # 3\n\npublic class KO_UseExit\n{\n    {\n        if (System.currentTimeMillis() >500000)\n          Runtime.getRuntime().halt(0)\n    \n    public KO_UseExit()\n    {\n       Runtime.getRuntime().halt(0)\n    }\n    \n    public void ko_go()\n    {\n     Runtime.getRuntime().halt(0)\n    }\n}\nNumber of Java Artifacts\nJava artifacts should not use 'java.System.exit()' or 'Runtime.getRuntime().exit(0)' or 'Runtime.getRuntime().halt(0)'  for application deployed on a Web Server or an Application Server (when web.xml and/or ejb-jar.xml file are present).\n    \nAvoid using Exit and Halt Methods on a Web/Application Server\nThis report lists  Java methods call or using 'java.System.exit()', 'Runtime.getRuntime().exit(0)' or 'Runtime.getRuntime().halt(0)'\nIt provides the following information:\n\n - method full name\nUsing the exit and halt methods in web application is a bad idea because it terminates not only program but also the Java Virtual Machine. Therefore it will shutdown the current application as well as other critical applications if any, running in the same JVM. This can result in DoS (Denial Of Service) attacks. Additionally, programs should perform necessary cleanup actions when forcibly terminated.\nhttp://cwe.mitre.org/data/definitions/382.html\n\nhttps://wiki.sei.cmu.edu/confluence/display/java/ERR09-J.+Do+not+allow+untrusted+code+to+terminate+the+JVM\n\nhttps://javarevisited.blogspot.com/2014/11/dont-use-systemexit-on-java-web-application.html\n\nhttps://www.baeldung.com/java-system-exit\n\nhttps://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html\nDon't use 'java.System.exit()', 'Runtime.getRuntime().exit(0)' and 'Runtime.getRuntime().halt(0)' to know what happened when you exit your program\npublic class ok_UseExit\n{\n    {\n        if (System.currentTimeMillis() >500000)\n           return; \n    }\n    \n    public OK_UseExit()\n    {\n        return;\n    }\n    \n    public void ok_go()\n    {\n         return;\n    }\n}\nsample #1\n\npublic class KO_UseExit\n{\n    {\n        if (System.currentTimeMillis() >500000)\n            System.exit(0);\n    }\n    \n    public KO_UseExit()\n    {\n        System.exit(0);\n    }\n    \n    public void ko_go()\n    {\n        System.exit(0);\n    }\n}\n\n-------------------------------------------------\nsample # 2\n\npublic class KO_UseExit\n{\n    {\n        if (System.currentTimeMillis() >500000)\n           Runtime.getRuntime().exit(0);\n    }\n    \n    public KO_UseExit()\n    {\n       Runtime.getRuntime().exit(0);\n    }\n    \n    public void ko_go()\n    {\n     Runtime.getRuntime().exit(0);\n    }\n}\n\n\n--------------------------------------------------------\n\nsample # 3\n\npublic class KO_UseExit\n{\n    {\n        if (System.currentTimeMillis() >500000)\n          Runtime.getRuntime().halt(0)\n    \n    public KO_UseExit()\n    {\n       Runtime.getRuntime().halt(0)\n    }\n    \n    public void ko_go()\n    {\n     Runtime.getRuntime().halt(0)\n    }\n}\nNumber of Java Artifacts", "urls": ["http://cwe.mitre.org/data/definitions/382.html", "https://wiki.sei.cmu.edu/confluence/display/java/ERR09-J.+Do+not+allow+untrusted+code+to+terminate+the+JVM", "https://javarevisited.blogspot.com/2014/11/dont-use-systemexit-on-java-web-application.html", "https://www.baeldung.com/java-system-exit", "https://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html", "http://cwe.mitre.org/data/definitions/382.html", "https://wiki.sei.cmu.edu/confluence/display/java/ERR09-J.+Do+not+allow+untrusted+code+to+terminate+the+JVM", "https://javarevisited.blogspot.com/2014/11/dont-use-systemexit-on-java-web-application.html", "https://www.baeldung.com/java-system-exit", "https://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html"]}, "7964": {"text": "Number of violation occurrences\nThe rule reports Managed bean and Java methods that call a constructor of the class used to define this Managed bean. \nThe class can be instantiated directly (by new) or also by getBean. \n\nNote: Even though the getBean method is part of the Spring framework, it is considered as a bad practice to use it since it bypasses the Spring inversion of control mechanism. It will access directly the Bean factory, to either retreive the singleton instance of the bean, or create another instance of that bean. \nThe behavior is implicit, dependent on the way the bean is configured, and cannot be known by the caller. That's why this call is considered as an explicit instantiation. \nInstead, the developer should rely on Spring's injection to wire the bean to the proper location, and access it with an accessor.\nAvoid directly instantiating a Class used as a managed bean\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nWhen a class is used to instantiate a managed bean, this bean benefits from different key features of the underlying framework :\n    * Each bean is a component which can take advantage of all services of the framework (for instance, declarative transaction management in Spring)\n    * With CDI or Spring, the bean is eligible for injection into other objects.\n \nSo, if a class is instantiated as a managed bean and as a direct Java instance at the same time, for these two instances, you may see different and unpredictable behavior.\nUse only managed beans and when you need different instances of the same class, use the prototype mode attribute.\nIn the case of Spring \n    <bean id=\"myBean\" class=\"sample.MyBean\">\n    <property name=\"url\">\n        <value>http://localhost/myBeanService</value>\n    </property>\n</bean>\n\npublic class MyBean{\n    private String url;\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n}\n\npublic class AnotherClass {\n    MyBean bean = context.getBean(\"myBean\" , MyBean.class); //Fixed\n    void check() {\n      System.out.println(bean.getUrl());\n    }\n}\n\n------------------------------------------------------\nAnnotation Based Configuration\n\n@Component(@repository or @controller or @Service)\npublic class MyBean implements MyBeanInterface {\nprivate String url;\n\n  public String getUrl() {\n    return url;\n  }\n\n  public void setUrl(String url) {\n    this.url = url;\n  }\n}\n\npublic class AnotherClass {\n   @Autowired \n   MyBeanInterface bean; //Fixed\n    \n    public MyBeanInterface getBean() {\n        return bean;\n    }\n    \n    public void setBean(MyBeanInterface bean) {\n        this.bean = bean;\n    }\n}\n\n----------------------------------------------------------\npublic class ServiceLimits {\n\n    private List<Services> services;\n\n    public List<Services> getServices() {\n        return services;\n    }\n\n    public void setServiceLimits(List<Services> services) {\n        this.services = services;\n    }\n\n}\n\n@Configuration\npublic class Temp {\n\n    @Bean\n    public ServiceLimits serviceLimits(){\n        return new ServiceLimits();    \n    }\n \n}\n\n@Service\npublic class A {\n\n    @Autowired    \n    ServiceLimits serviceLimits;\n\n    public void acheck() {\n          System.out.println(serviceLimits.services);\n    }\n}\nXML Configuration\n    <bean id=\"myBean\" class=\"sample.MyBean\">\n  <property name=\"url\">\n     <value>http://localhost/myBeanService</value>\n  </property>\n</bean>\n\npublic class MyBean{\n  private String url;\n\n  public String getUrl() {\n    return url;\n  }\n\n  public void setUrl(String url) {\n    this.url = url;\n  }\n}\n\npublic class AnotherClass {\n    MyBean bean;\n\n    void check() {\n      bean = new MyBean();   // VIOLATION\n      System.out.println(bean.getUrl());\n    }\n}\n\n------------------------------------------------------\nAnnotation Based Configuration\n\n@Component(@repository or @controller or @Service)\npublic class MyBean implements MyBeanInterface {\nprivate String url;\n\n  public String getUrl() {\n    return url;\n  }\n\n  public void setUrl(String url) {\n    this.url = url;\n  }\n}\n\npublic class AnotherClass {\n    MyBean bean;\n\n    AnotherClass() {\n      bean = new MyBean();   // VIOLATION\n    }\n}\n\n----------------------------------------------------------\n\npublic class ServiceLimits {\n\n    private List<Services> services;\n\n    public List<Services> getServices() {\n        return services;\n    }\n\n    public void setServiceLimits(List<Services> services) {\n        this.services = services;\n    }\n}\n\n@Configuration\npublic class Temp {\n\n    @Bean\n    public ServiceLimits serviceLimits(){\n        return new ServiceLimits();    \n    }\n \n}\n\n@Service\npublic class A {\n    \n    public void acheck() {\n        ServiceLimits serviceLimits = new ServiceLimits();   //Violation\n        System.out.println(serviceLimits.services);\n    }\n}\nNumber of Non Abstract Java Artifacts", "urls": ["http://localhost/myBeanService", "http://localhost/myBeanService"]}, "7206": {"text": "This rule reports methods that use Instanceof inside a loop.\nAvoid the use of Instanceof inside loops\nThis report lists all methods with a call to instanceof inside a loop.\nIt provides the following information:\n  Method full name\nThe run-time type checking is a time expensive operation and as such should be avoided within loops.\nIn a more general matter, the use of Instanceof operator, run-time type checking might indicate a misuse of Object Oriented programming. Indeed, it is always recommended to design classes and interfaces so client code do not need to use Instanceof operator and downcasting. The recommended way is to prefer polymorphism over InstanceOf operator and downcasting.\nhttps://www.armedia.com/blog/instanceof-avoid-in-code/\nPrefer polymorphism over 'Instanceof' operator and downcasting.\n\nIt is always recommended to design classes and interfaces so client code need not to use Instanceof operator and downcasting. The recommended way is to prefer polymorphism over Instanceof operator and downcasting.\nclass BaseExample { ... }\nclass Example1 extends BaseExample { ... }\nclass Examplet2 extends BaseExample { ... }\n\nclass Test {\n  BaseExample[] exList;\n  void method () {\n     for (int i = exList.length-1; i >= 0; i--) {\n       // common method to refactor aMethod1 and aMethod2\n        exList[i].commonMethod(); // FIXED\n       } \n     }\n  }\n}\nclass BaseExample { ... }\nclass Example1 extends BaseExample { ... }\nclass Example2 extends BaseExample { ... }\n\nclass Test {\n  BaseExample[] exList;\n  void method () {\n     for (int i = exList.length-1; i >= 0; i--) {\n        if (exList[i] instanceof Example1) { // VIOLATION\n          ((Example1) exList[i]).aMethod1();\n       } elseif (exList[i] instanceof Example2) { // VIOLATION\n         ((Example2) exList[i]).aMethod2();\n     }\n  }\n}\nNumber of non abstract Java artifacts", "urls": ["https://www.armedia.com/blog/instanceof-avoid-in-code/"]}, "7956": {"text": "Nesting try/catch blocks hardly impacts the performance and the readability of source. This rule reports all methods which contain a try/catch block and are called within a loop (for, while, do while) at a depth level less than <depth level>.\n\n<depth level> is a parameter that can be changed at will.\nDEPRECATED:Avoid indirect exception handling inside loops\nThis reports all methods having a loop in which there is a call to a method that contains try/catch blocks.\nIt provides the following information:\n Method full name that has the loop, the call path from the method that contains the loop to the method that does the try/catch\n\nNote that:\n1/ The call path may contain different paths while only one is an error. For example:\nvoid myException(){\n     try{  throw exception(); }\n     catch(exception e){}\n}\n\nvoid g() {myException();}\n\nvoid  f() {\n       while (myCondition) { g ();}\n        g();\n        } \n\nwill report both path to g() while only one is a violation, the one that is called in the loop.\n\n2/ Several paths for the same method violating the rule are identified in the Metric Detail page by a sequence ID (in the Value column), this ID is dynamically set during each snapshot and the same path can have a different sequence ID in different snapshots.\nException handling tends to be relatively costly, given the work in unwinding the stack, trying various exception handlers, and so on. You should avoid placing try/catch blocks within a method that is called in a loop as it can add up when performed many times inside a loop.\nIf possible, put the loop inside the try/catch block.\npublic class ExceptionTest {\n     static final int N = 18000000;\n\n     public void myException(void) throws Throwable {\n         Throwable exc = new Throwable();\n         throw exc;\n    }\n}\n\npublic class LoopTest {\n     static final int N = 18000000;\n     private ExceptionTest et = new ExceptionTest();\n \n     public void myLoop(void) {\n         try {                                               \n             for (int i = 1; i <= N; i++) {\n                  et.myException(); // FIXED\n             }\n        } catch (Throwable e) { }\n    }\n}\npublic class ExceptionTest {\n    static final int N = 18000000;\n\n    public void myException(void) {\n         Throwable exc = new Throwable();\n         try {                                               \n             throw exc;\n         } catch (Throwable e) { }\n    }\n}\n\npublic class LoopTest {\n    static final int N = 18000000;\n    private ExceptionTest et = new ExceptionTest();\n \n    public void myLoop(void) {\n       for (int i = 1; i <= N; i++) {\n            et.myException(); // VIOLATION\n       }\n    }\n}\nNumber of methods that contain at least one loop", "urls": []}, "7638": {"text": "The use of the DriverManager class to directly manage the connection to the database violates the JEE restriction against the direct management of connections. \n\nThis rules checks if any method calling to java.sql.DriverManager.getConnection().\nAvoid directly managing the connection to the database by using DriverManager\nThis report lists all methods that call java.sql.DriverManager.getConnection() method.\nIt provides the following information: Method Full Name\nThe JEE standard forbids the direct management of connections as very expensive. It requires that applications use the container's resource management facilities to obtain connections to resources. Every major web application container provides pooled database connection management as part of its resource management framework. Duplicating this functionality in an application is difficult and error prone, which is part of the reason it is forbidden under the JEE standard.\nhttps://cwe.mitre.org/data/definitions/245.html\nUse a pool of connections unless the DriverManager is the implementation of the connection pool itself.\n\nIn a J2EE container, it is recommended to use a JNDI DataSource provided by the container. Outside of a J2EE container, consider Apache's Jakarta Commons DBCP  or C3P0. Commons DBCP's BasicDataSource and C3P0's ComboPooledDataSource are full connection pool beans, supporting the same basic properties as this class plus specific settings (such as minimal/maximal pool size etc)..\n\n\nInstead, JEE application should use the web application container's resource management facilities to obtain a connection to the database as shown in the following example.\nRemediation for Sample 1\n\npublic class DatabaseConnection {\nprivate static final String DB_DATASRC_REF = \"jdbc:mysql://localhost:3306/mysqldb\";\nprivate Connection conn = null;\n\npublic DatabaseConnection() {\n}\n\npublic void openDatabaseConnection() {\ntry {\nInitialContext ctx = new InitialContext();\nDataSource datasource = (DataSource) ctx.lookup(DB_DATASRC_REF);\nconn = datasource.getConnection();\n} catch (NamingException ex) {...}\n} catch (SQLException ex) {...}\n}\n\n// Member functions for retrieving database connection and accessing database\n...\n}\n\n-------------------------------------\nRemediation for Sample 2\n\n\nimport org.apache.commons.dbcp.BasicDataSource;\n\nBasicDataSource ds = new BasicDataSource();\nds.setDriverClassName(\"oracle.jdbc.driver.OracleDriver\");\nds.setUsername(\"scott\");\nds.setPassword(\"tiger\");\nds.setUrl(\"jdbc:oracle:thin:scott/tiger@myhost:1521:mysid\");\nConnection con = ds.getConnection();\nSample 1\n\npublic class DatabaseConnection {\nprivate static final String CONNECT_STRING = \"jdbc:mysql://localhost:3306/mysqldb\";\nprivate Connection conn = null;\n\npublic DatabaseConnection() {\n}\n\npublic void openDatabaseConnection() {\ntry {\nconn = DriverManager.getConnection(CONNECT_STRING);// VIOLATION\n} catch (SQLException ex) {...}\n}\n\n// \n...\n}\n\n--------------------------------\nSample 2\n\n\nConnection con = DriverManager.getConnection(URL, user, password); // VIOLATION\nNumber of java artifacts that reference java.sql.Connection class", "urls": ["https://cwe.mitre.org/data/definitions/245.html"]}, "7498": {"text": "Number of violation occurrences\nReports all getters that don't return the same collection instance as it was assigned by Hibernate or JPA to the setter method: any modification of the setter parameter or the attribute returned by the getter will be detected and reported.\nIn setter method, a modification occur when the class attribute is not initialized with the parameter directly. And in the getter when the return value is not the class attribute itself. To perform this check, any call to a method or a constructor in the getter or setter will be considered as a violation.\nThis metric take into account the case where getter and setter are implemented on an inherited class of the persistent class (can happen when inherited fields are persistent)\nAvoid Incorrect implementation of getters and setters for Collection Type\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nBy using getter and setter, the programmer can control how his important variables are accessed and updated in a correct manner, such as changing value of a variable within a specified range.\nKeep the same collection as reference\nprivate List<String> listTitles;\npublic void setListTitles(List<String> titles) {\n    this.listTitles = titles;\n}\npublic List<String> getListTitles() {\n    return this.listTitles;\n}\nprivate List<Person> listPeople = new ArrayList<Person>();     //VIOLATION\n    public void setListPeople(List<Person> list) {\n        for (Person aPerson : list) {\n            this.listPeople.add((Person) aPerson.clone());\n        }\n    }\n    public List<Person> getListPeople() {                      //VIOLATION\n        List<Person> listReturn = new ArrayList<Person>();\n        for (Person aPerson : this.listPeople) {\n            listReturn.add((Person) aPerson.clone());\n        }\n        return listReturn;\n    }\nNumber of fields setters and getters that have a Collection as parameter or return value", "urls": []}, "7246": {"text": "Efferent Coupling\nEfferent Coupling between packages (Ce) measures the total number of external classes coupled to classes of a package due to outgoing coupling. This is an indicator of the package's independence.\nThis rule reports all classes ( and interfaces ) of a package with a high efferent Coupling. \n\nThe threshold contains the maximum efferent coupling.\nAvoid Packages with High Efferent Coupling (CE)\nThis report all APM Java Classes of a package with a high efferent Coupling. \nIt provides the following information: \n- Class (Or Interface) \n- CE\nExcessive coupling is detrimental to modular design since classes are not independent. A large efferent coupling indicates that a class is unfocussed and may also indicate that it is unstable since it depends on the stability of all the types to which it is coupled. This prevents reuse since a high coupling possibly indicates a package is poorly designed and difficult to understand/maintain. Extracting classes from the original class so the class is decomposed into smaller classes can reduce efferent coupling, this improves modularity and promotes encapsulation.\nhttps://www.researchgate.net/publication/314082764_Software_Instability_Analysis_Based_on_Afferent_and_Efferent_Coupling_Measures\nReview the packages in order to be sure that they do not have High Efferent Coupling.\nNumber of APM Java All Classes referenced in DSSAPP_PACKAGES( Java and JSP Technology)", "urls": ["https://www.researchgate.net/publication/314082764_Software_Instability_Analysis_Based_on_Afferent_and_Efferent_Coupling_Measures"]}, "7708": {"text": "Reports all methods that reference:\n - net.sf.hibernate.Session.setFlushMode(org.hibernate.FlushMode) or org.hibernate.Session.setFlushMode(org.hibernate.FlushMode) \nand also the parameters:\n   * net.sf.hibernate.COMMIT, net.sf.hibernate.NEVER\n   * org.hibernate.FlushMode.COMMIT, org.hibernate.FlushMode.NEVER or org.hibernate.FlushMode.MANUAL\nAvoid using session.setFlushMode(FlushMode.COMMIT, FlushMode.NEVER or FlushMode.MANUAL)\nList all methods that call setFlushMode with FlushMode.COMMIT, FlushMode.NEVER or FlushMode.MANUAL as value.\n\nIt provides the following information:\n Method Full Name\nSession.setFlushMode(FlushMode.COMMIT, FlushMode.NEVER or FlushMode.MANUAL) specifies that the session won't be flushed before query execution (it will be flushed only at the end of the database transaction). Be aware that this setting may expose you to stale data: modifications you made to objects only in memory may conflict with the results of the query. We don't recommend that you change this setting from the default. \nIt's provided to allow performance optimization in rare cases. Likewise, most applications rarely need to call flush() explicitly. This functionality is useful when you're working with triggers, mixing Hibernate with direct JDBC, or working with buggy JDBC drivers. You should be aware of the option but not necessarily look out for use cases.\nhttps://www.cpe.ku.ac.th/~plw/oop/e_book/hibernate_in_action.pdf  p 160/161\nVerify that these settings are necessary.\npublic void testJEEPPUB003_1_SHOW_4() {\n        UsersFromVb newUser = new UsersFromVb(\"Jake2\",\"Roberts\",23,\"Chimp@EroticMonkey.com\");\n        \n        UsersFromVbHome userManager = new UsersFromVbHome();\n        //userManager.persist(newUser);\n        Session mySession = userManager.getSessionFactory().getCurrentSession();\n        mySession.getTransaction().begin();\n        //userManager.attachClean(newUser);\n        mySession.persist(newUser);\n        //userManager.persist(newUser);\n        mySession.getTransaction().commit();\n        \n    }\ncase#1:\n\npublic void testJEEPPUB003_1_SHOW_2() {\n        UsersFromVb newUser = new UsersFromVb(\"Jake2\",\"Roberts\",23,\"Chimp@EroticMonkey.com\");\n        \n        UsersFromVbHome userManager = new UsersFromVbHome();\n        //userManager.persist(newUser);\n        Session mySession = userManager.getSessionFactory().getCurrentSession();\n        mySession.getTransaction().begin();\n        //userManager.attachClean(newUser);\n        mySession.persist(newUser);\n        mySession.setFlushMode(FlushMode.COMMIT);   //VIOLATION\n        //userManager.persist(newUser);\n        mySession.getTransaction().commit();\n        \n    } \n\ncase#2:\n\n    public void testJEEPPUB003_1_SHOW_4() {\n        UsersFromVb newUser = new UsersFromVb(\"Jake2\",\"Roberts\",23,\"Chimp@EroticMonkey.com\");\n        \n        UsersFromVbHome userManager = new UsersFromVbHome();\n        //userManager.persist(newUser);\n        Session mySession = userManager.getSessionFactory().getCurrentSession();\n        mySession.getTransaction().begin();\n        //userManager.attachClean(newUser);\n        mySession.persist(newUser);\n        mySession.setFlushMode(FlushMode.MANUAL); //VIOLATION\n        //userManager.persist(newUser);\n        mySession.getTransaction().commit();\n        \n    }\nNumber of methods that reference org.hibernate.Session.setFlushMode or net.sf.hibernate.Session.setFlushMode", "urls": ["https://www.cpe.ku.ac.th/~plw/oop/e_book/hibernate_in_action.pdf"]}, "7678": {"text": "This rule checks all references to log4j, Logback and Java.Util.logger API usage. \nAny artifact that reference a class, an interface, a method or a field that belongs to a class from the package org.apache.log4j\nch.qos.logback.classic.Logger\njava.util.logging.Logger\n\nwill be reported as violation.\n\nThis rule can be customized by specifying any other specific implementations package to be avoided\nAvoid logging using basic java log files\nThis report lists all artifacts and fields that violate this rule.\nIt provides the following information:\n Artifact Full Name and Field Full Name\nInstead of being stick to a specific logging implementation, it is recommended to use Java-based logging utility and a programming model for logging and for other toolkits that provides APIs, log implementations, and wrapper implementations over some other tools \nas Apache Commons Logging (previously known as Jakarta Commons Logging or JCL).\nit's also recommanded to use Log interface that is intended to be both light-weight and an independent abstraction of other logging toolkits. It provides the middleware/tooling developer with a simple logging abstraction that allows the user (application developer) to plug in a specific logging implementation.\nhttps://stackify.com/java-logging-best-practices/\nhttps://www.sitepoint.com/which-java-logging-framework-has-the-best-performance/#loggingframeworkperformance\nPrefer for example using Simple Logging Facade for Java (SLF4J) that acts as a facade for different logging frameworks. It offers a generic API making the logging independent of the actual implementation.\nThis allows for different logging frameworks to coexist. It also helps migrate from one framework to another.\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nLog log = LogFactory.getLog(\"com.cast\"); // FIXED\nimport org.apache.log4j.*\nLogger  logger = Logger.getLogger(\"com.cast\"); // VIOLATION\nNumber of artifacts and fields that use org.apache.log4j, org.apache.commons.logging or other logging package specified in the threshold", "urls": ["https://stackify.com/java-logging-best-practices/", "https://www.sitepoint.com/which-java-logging-framework-has-the-best-performance/#loggingframeworkperformance"]}, "2262": {"text": "File directory\nTo be compliant with code Conventions for the JavaServer Pages Technology, this rule checks if all cascading style sheet files are in the recommended location :  <context root> /css/\nDEPRECATED: All cascading style sheet files should be in specific directory\nThis report lists all style sheet files (X) located outside the \"styles\" directory in a JSP Application. It provides the following information: File full name, File directory\nFor maintainability aspects, file organization must be respected.\nhttps://www.oracle.com/technical-resources/articles/javase/code-convention.html\nChange file location according to the recommended naming convention.\nNumber of CSS pages in a JSP Application", "urls": ["https://www.oracle.com/technical-resources/articles/javase/code-convention.html"]}, "4612": {"text": "Native Method name\nList all artifacts that call a native method except native methods contained in the libraries defined by the threshold parameter. \nThe threshold is a parameter and can be changed at will with libraries that you consider to be safe.\nAvoid using native Methods (JNI)\nThis report lists all artifacts using native methods except those contained in libraries defined by the parameter.\nIt provides the following information:\n - Artifact full name\n - Native Method name\nJNI is one of the most serious cause of application server crash that can be due for example to buffer overflow. Even if your code works on a plateform, it doesn't mean that it will work on other plateform because the internals of JVMs differ.\nIn case of crash, your JVM suplier's support will probably ask you to remove these calls before investigating your issue.\n\nAlso, for portability purposes, native Methods should not be used. Native Methods could be compared to Interfaces to encapsulate calls to C Methods and Functions. Doing so relies on having the appropriate environment setup at the operating system level.\n\nSee : CWE-111: Direct Use of Unsafe JNI\nhttps://cwe.mitre.org/data/definitions/111.html\nhttp://en.wikipedia.org/wiki/Java_Native_Interface#Pitfalls\nDon't use JNI for security reason\nclass Echo {\n\npublic native void runEcho();\nstatic {\n\nSystem.loadLibrary(\"echo\");\n}\npublic static void main(String[] args) {\n\nnew Echo().runEcho();   //VIOLATION\n}\n}\nNumber of Non Abstract Java Artifacts", "urls": ["https://cwe.mitre.org/data/definitions/111.html", "http://en.wikipedia.org/wiki/Java_Native_Interface#Pitfalls"]}, "7248": {"text": "Afferent Coupling\nAfferent Coupling (also known as Incoming Dependencies and Number of Types outside a Package that Depend on Types of the Package) indicates the number of other packages that depend upon classes within the analyzed package. Afferent Coupling is a time consuming determination of couplings between packages, hence showing which packages that depend upon each other. The number of packages that depend upon the analyzed package is an indication of the analyzed package's level of responsibility. In order to improve modularity and promote encapsulation, inter-object class couples should be kept to a minimum. If the package is relatively abstract then a large number of incoming dependencies is acceptable but the larger the number of couples, the higher the sensitivity to changes in other parts of the design, and therefore maintenance is difficult. Excessive coupling between concrete object classes is detrimental to modular design and prevents reuse.\n\nThe threshold contains the maximum afferent coupling.\nAvoid Packages with High Afferent Coupling (CA)\nThis report all APM Java Classes of a package with a high afferent Coupling. \nIt provides the following information : \n- Class\n- CA\nIf a package is highly abstract then it should be very stable.  If the package is highly concrete (un-abstract), then it would be acceptably unstable as it already has reached its maximum specialization. If a category is to be stable, it should also consist of abstract classes so that it can be extended. Stable categories that are extensible are flexible and do not constrain the design.\nhttps://dzone.com/articles/measuring-code-complexity\nhttp://www.arisa.se/compendium/node104.html\nReview the packages in order to have an Afferent Coupling.\nNumber of APM Java All Classes referenced in DSSAPP_PACKAGES( Java and JSP Technology)", "urls": ["https://dzone.com/articles/measuring-code-complexity", "http://www.arisa.se/compendium/node104.html"]}, "4702": {"text": "Number of violation occurrences\nThrowable.printStackTrace(...) prints a Throwable and its stack trace to some stream. If no argument is used, the default stream System.Err will be used, which could inadvertently expose sensitive information.\n\n\nThis rule will report a violation when printStackTrace is used without arguments: when the stack trace is printed to the default stream.\nAvoid using 'Throwable.printStackTrace()' with no argument\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nUsing 'Throwable.printStackTrace()' usually means that it is used to log the stack of errors, which has the risk of filling up the stdout or the log file.\nFollowing are some of the reasons why one should avoid invoking printStackTrace method on Throwable/Exception classes and instead use Logger method using one of the frameworks such as LogBack or Log4J:\n\n1. Difficult to Retrieve Logs for Debugging: The logs written using printStackTrace is written to System.err which is hard to route or filter elsewhere. Instead, using Loggers, it is easy to retrieve logs for debugging purposes.\n\n2. Violation of Coding Best Practices: Generally, as per coding guidelines in production-ready applications, developers need to use Logger methods for logging different levels of information. However, when it comes to exception handling, the instances of printStackTrace are commonly found in various places. This is, thus, a violation of coding practice and, thus, should be avoided.\nhttp://cwe.mitre.org/data/definitions/489.html\nOWASP Top 10 2017 Category A3 - Sensitive Data Exposure\nhttps://dzone.com/articles/java-top-5-exception-handling\nLoggers should be used instead to print Throwables, as they have many advantages:\n\nUsers are able to easily retrieve the logs.\nThe format of log messages is uniform and allow users to browse the logs easily.\npublic static void main(String[] args){\n    try {\n        test();\n    } catch (UnsupportedOperationException e) {\n        LOGGER.log(\"An exception \",e);\n    }\n}\npublic static void main(String[] args){\n    try {\n        test();\n    } catch (UnsupportedOperationException e) {\n        System.out.println(e);\n        e.printStackTrace();\n    }\n}\nNumber of non-abstract Java artifacts.", "urls": ["http://cwe.mitre.org/data/definitions/489.html", "https://dzone.com/articles/java-top-5-exception-handling"]}, "4744": {"text": "Entity Java Bean Name\nFor application using EJB 2.0, EJB Entities should be accessed through their local Interface instead of their remote Interface\nIn EJB 2.0, a bean that is destined to be remote extends EJBObject in its remote interface and EJBHome in its home interface.\n\nFor application using EJB 2.0, EJB Entities should be accessed through their local Interface instead of their remote Interface\", \n\n>> All application using EJB 2.0 should use local interface?? what if the client is not in the same JVM? In that case EJB has to use remote interface (if not using session facade pattern)\n>> If we are to check this condition only when the session facade pattern is used then total needs to be changed.\nDEPRECATED: EJB Entity access through their local Interface\nThis report lists all the Methods using the EJB Entity remote Interfaces.\nIt provides the following information:\n - Method full name\n - Entity Java Bean Name\nBest practices recommend that Entity beans only use Local Interface methods to expose their functions. So since, EJB 2.0, remote interface should not be used. Instead, opt for local interface as part of session fa\u00e7ade implementation. \nThis avoids the need for the JNDI lookup, which improves the performance\nEnterprise Java Programming with IBM WebSphere - page 508\nReview the source code and have the EJB Entities accessed through their local  Interface instead of their remote Interface.\npackage employee;\n\nimport employee.EmpRecord;\nimport javax.ejb.EJBObject;\nimport java.rmi.RemoteException;\n\npublic interface Employee extends EJBObject  {\n  public EmpRecord getEmployee (int empNumber)\n       throws java.sql.SQLException, RemoteException;\n}\nNumber of Methods accessing Java EJB Entity", "urls": []}, "4746": {"text": "Session Java Bean Name\nThis rule list all the EJB Session that are not accessed through their local remote Interface.\nDEPRECATED: EJB Session access through their local Interface\nThis report lists all the Methods using the EJB Session remote Interfaces.\nIt provides the following information:\n - Method full name\n - Session Java Bean Name\nSince EJB 2.0, EJB Session should be accessed through their local remote Interface instead of their remote Interface. This avoids the need for the JNDI lookup, which improves the performance.\nReview the source code and have the EJB Entities accessed through their local  Interface instead of their remote Interface.\nNumber of Methods accessing Java EJB Session", "urls": []}, "7148": {"text": "JSP Tiles Definition or JSP Tiles Attributes\nReports any direct references to JSP pages except those from Tiles.\nDEPRECATED: JSP pages should always be accessed through their tiles definition\nThis report lists all JSP pages that are not accessed through their tiles.\nIt provides the following information:\n - Page name\n - JSP Tiles Definition or JSP Tiles Attributes\nTo ease changes to the presentation layer, JSP Pages should always be accessed through their tiles definition. The Tiles framework makes it very easy to add and remove view components and to rearrange things.\nReview the source code and update it in order to have the JSP pages  accessed through their tiles definition\nNumber of JSP pages, when the tiles technology is used (object of type  \"Tiles Configuration File\" is present)", "urls": []}, "4604": {"text": "Java artifacts should not use 'java.lang.Error()'\nAvoid using 'java.lang.Error'\nThis report lists all java Objects using 'java.lang.Error()'. It provides the following information: Object full name\nUsing 'java.lang.Error()' is not recommended since it goes against the Exception error handling model. An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most of these errors are abnormal conditions.\nhttps://docs.oracle.com/javase/7/docs/api/java/lang/Error.html\nhttps://www.geeksforgeeks.org/errors-v-s-exceptions-in-java/\nhttps://www.cis.upenn.edu/~bcpierce/courses/629/jdkdocs/api/java.lang.Error.html\nPrefer using the exception error handling model instead of 'java.lang.Error'\nstatic private final class LookaheadSuccess extends java.lang.Exception { } //Fixed\nSample#1:\nstatic private final class LookaheadSuccess extends java.lang.Error { }   //VIOLATION\n\nSample#2:\nprivate void parseAndRun(String[] args)\n    {\n        debugLog(\"Start of parseAndRun(args)\");\n        boolean optionParsed;\n        try\n        {\n            debugLog(\"Before parseOptions(args)\");\n            optionParsed = parseOptions(args);\n            debugLog(\"After parseOptions(args)\");\n        }\n   \n        catch (Error e)   //VIOLATION\n        {\n            setErrorCode(ERROR_CODE_OPTION_PARSE_EXCEPTION);\n            throw Logging.fatal(e, \"cast.commandLine.exceptionDuringOptionCheck\");\n        }\n}\n\nSample#3:\n\n/** Constructor. */\npublic DataParserTokenManager(SimpleCharStream stream){\n   if (SimpleCharStream.staticFlag)\n      throw new Error(\"ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.\"); //VIOLATION\n   input_stream = stream;\n}\n\nSample#4:\n\n//Error Field\nError err = new Error();  //VIOLATION\nNumber of Java Objects", "urls": ["https://docs.oracle.com/javase/7/docs/api/java/lang/Error.html", "https://www.geeksforgeeks.org/errors-v-s-exceptions-in-java/", "https://www.cis.upenn.edu/~bcpierce/courses/629/jdkdocs/api/java.lang.Error.html"]}, "4578": {"text": "Returned Type Full Name\nWhen a collection is returned from a method, it should be of the Interface type, and not as the Class type. Collections are considered to be any classes implementing java.util.Collection, java.util.Collection<E>, java.util.Map or java.util.Map<U,V> or one of their sub-interfaces.\nCollection interfaces should be used as method return types instead of their implementation classes\nThis report lists all the Methods not using the Interfaces for Collection types. It provides the following information:\n - Method full name\n - Returned Type Full Name\nUsing the implementation class of a collection as the return type of your method ties your code to this specific implementation and makes it difficult to change the implementation class in the future.\n\nFor example, if you use the java.util.Collection interface, you can change your implementation class from a Set to a List or to a Queue according to your needs and performance requirements.\nhttp://java.sun.com/docs/books/tutorial/collections/interfaces/index.html\nhttps://en.wikipedia.org/wiki/Liskov_substitution_principle\nDeclare the type as an interface of a more appropriate collection.\n/**\n     * @return the list of all dataset boxes present on the graphic view\n     */\n    public List<DataSetBaseBox> getDataSetBoxes()\n    {\n        List<DataSetBaseBox> dataSetBaseBoxes = new List<DataSetBaseBox>();  //Fixed\n        for (Component c : getComponents())\n        {\n            if (c instanceof DataSetBaseBox)\n            {\n                dataSetBaseBoxes.add((DataSetBaseBox)c);\n            }\n        }\n        return dataSetBaseBoxes;\n    }\n/**\n     * @return the list of all dataset boxes present on the graphic view\n     */\n    public ArrayList<DataSetBaseBox> getDataSetBoxes()\n    {\n        ArrayList<DataSetBaseBox> dataSetBaseBoxes = new ArrayList<DataSetBaseBox>();  //VIOLATION\n        for (Component c : getComponents())\n        {\n            if (c instanceof DataSetBaseBox)\n            {\n                dataSetBaseBoxes.add((DataSetBaseBox)c);\n            }\n        }\n        return dataSetBaseBoxes;\n    }\nNumber of methods which return type implements or extend java.lang.Collection, java.lang.Collection<T>, java.lang.Map or java.lang.Map<U,V>", "urls": ["http://java.sun.com/docs/books/tutorial/collections/interfaces/index.html", "https://en.wikipedia.org/wiki/Liskov_substitution_principle"]}, "4580": {"text": "Collection Class Fullname\nReport any field declaration whose type is a class that implements an interface of type java.lang.Collection, java.lang.Collection<T>, java.lang.Map or java.lang.Map<U,V> or that implements an interface that inherits from these any of the aforementioned interfaces.\nCollection declarations should use interfaces instead of implementation classes\nThis report lists all the fields initialized with the Collection and Map implementation class. It provides the following information:\n - Field Full Name\n - Collection Class Fullname\nUsing the implementation class of a collection as the type of your instance ties your code to this specific implementation and makes it difficult to change the implementation in the future.\n\nFor example, if you use the java.util.Collection interface, you can change your implementation class from a Set to a List or to a Queue according to your needs and performance requirements.\nhttp://java.sun.com/docs/books/tutorial/collections/interfaces/index.html\nhttps://stackoverflow.com/questions/12321177/arraylist-or-list-declaration-in-java/12321186\nDeclare the type as an interface of a more appropriate collection.\nprivate List ok_01_08_field_declaration = new ArrayList(); //Fixed\nprivate ArrayList ko_02_08_initializer_declaration; // VIOLATION ,ArrayList is an implementation of the List interface.\nNumber of fields whose type implements or extends java.lang.Collection, java.lang.Collection<T>, java.lang.Map or java.lang.Map<U,V>", "urls": ["http://java.sun.com/docs/books/tutorial/collections/interfaces/index.html", "https://stackoverflow.com/questions/12321177/arraylist-or-list-declaration-in-java/12321186"]}, "4606": {"text": "Sun classes referenced by this artifact\nThis rule reports all Java artifacts using 'sun.*' Classes\nAvoid using 'sun.*' Classes\nThis report lists all java artifacts using 'sun.*' Classes.\nIt provides the following information:\n - Artifact full name\n - sun classes referenced by this artifact\nSun.*' Classes should not be used. Sun preserves the right to change the structure of those Classes without notice or documentation. Also, sun.* packages are not guaranteed to work on all Java-compatible platforms. These classes will not in general be present on another vendor's Java platform. If your Java program asks for a class \"sun.package.Foo\" by name, it may fail with ClassNotFoundError, and you will have lost a major advantage of developing in Java.\nhttps://www.oracle.com/technetwork/java/faq-sun-packages-142232.html\nAny direct calls to 'sun.*' classes should be avoided.\nimport sun.misc.BASE64Encoder\nNumber of Java objects", "urls": ["https://www.oracle.com/technetwork/java/faq-sun-packages-142232.html"]}, "4598": {"text": "This rule reports Java artifacts using 'java.lang.Runtime.exec()'\nAvoid using 'java.lang.Runtime.exec()'\nThis report lists all java artifacts using 'java.lang.Runtime.exec'.\nIt provides the following information:\n - Artifact full name\nFor portability reasons, 'java.lang.Runtime.exec()' should not be used since it means being dependent on the environment where the application is deployed.\nFor security reasons, 'java.lang.Runtime.exec()' can lead to malicious file execution resulting in devastating attacks such as total server compromise.\nOpen Web Application Security Project's Top Ten\nhttp://www.owasp.org/index.php/Top_10_2007-A3\nsee OWASP_Top_10_2007_for_JEE.pdf\nhttps://docs.oracle.com/javase/6/docs/api/java/lang/ProcessBuilder.html\nhttps://cwe.mitre.org/data/definitions/77\nhttps://cwe.mitre.org/data/definitions/78\nhttps://cwe.mitre.org/data/definitions/88\nhttps://www.sans.org/top25-software-errors/#cat1\nAlternative to java.lang.Runtime.exec(), we can also make use of java.lang.ProcessBuilder which makes it much easier to specify a process, set up its environment, spawn it, and handle its file descriptors.\nprivate boolean checkSudoPrivilege() throws InterruptedException, IOException {\n  // \"sudo -v\" returns non-zero value if the current user has problem running sudo command.\n  // It will always return zero if user is root.\n  Process process = Runtime.getRuntime().exec(\"sudo -v\");\n  int exitCode = process.waitFor();\n  return exitCode == 0;\n }\n}\nNumber of Java artifacts", "urls": ["http://www.owasp.org/index.php/Top_10_2007-A3", "https://docs.oracle.com/javase/6/docs/api/java/lang/ProcessBuilder.html", "https://cwe.mitre.org/data/definitions/77", "https://cwe.mitre.org/data/definitions/78", "https://cwe.mitre.org/data/definitions/88", "https://www.sans.org/top25-software-errors/#cat1"]}, "7668": {"text": "DOM Parser creates an In Memory tree representation of XML file and then parses it, so it requires more memory and it's advisable to have increased the heap size for DOM parser in order to avoid Java.lang.OutOfMemoryError:java heap space . \n\nParsing large or medium sized XML files using DOM parser will take a long time or even may not be able to load it completely simply because it requires lot of memory to create XML Dom Tree.\n\nThis rule checks all methods parsing XML files. A violation is reported when detecting a reference to javax.xml.parsers.DocumentBuilder class\nDEPRECATED: Avoid using DOM parser for large or medium sized XML file parsing\nList all methods, that reference javax.xml.parsers.DocumentBuilder class.\n\nIt provides the following information:\n Java Method Fullname\nEfficient parsing of XML documents is more and more critical as XML gets adopted more widely. It is very important to have an efficient way to parse XML data, especially in applications that are intended to handle large volumes. Improper parsing can result in excessive memory usage and processing times that can hurt scalability.\nhttp://ptgmedia.pearsoncmg.com/images/0131453491/samplechapter/megginson_ch08.pdf\nhttps://www.mysoftkey.com/java/difference-between-dom-and-sax-parser-in-java/\nPrefer using SAX XML parser for parsing large XML files in Java because it doesn't require to load whole XML file in Java and it can read a big XML file in small parts\n\nIt's specially recommended to use SAX when no modification are made on the document and when used in different threads (session, EJB...), in a loop.\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\n\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class SAXParserExample extends DefaultHandler{\n    [...]\n    \n    public SAXParserExample(){\n        [...]\n    }\n\n    private void parseDocument() {\n        SAXParserFactory spf = SAXParserFactory.newInstance();\n        try {\n            SAXParser sp = spf.newSAXParser();\n            sp.parse(\"sample.xml\", this);\n        }catch(SAXException se) {\n            se.printStackTrace();\n        }catch(ParserConfigurationException pce) {\n            pce.printStackTrace();\n        }catch (IOException ie) {\n            ie.printStackTrace();\n        }\n    }\n\n    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n        [...]\n    }\n\n    public void characters(char[] ch, int start, int length) throws SAXException {\n        [...]\n    }\n\n    public void endElement(String uri, String localName, String qName) throws SAXException {\n        [...]\n    }\n\n    [...]\n}\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\npublic class DomParserExample {\n    Document dom;\n\n    private void parseXmlFile(){\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        try {\n            DocumentBuilder db = dbf.newDocumentBuilder();  // VIOLATION\n            dom = db.parse(\"sample.xml\");\n        }catch(ParserConfigurationException pce) {\n            pce.printStackTrace();\n        }catch(SAXException se) {\n            se.printStackTrace();\n        }catch(IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n}\nNumber of methods that reference javax.xml.parsers.SAXParser and javax.xml.parsers.DocumentBuilder", "urls": ["http://ptgmedia.pearsoncmg.com/images/0131453491/samplechapter/megginson_ch08.pdf", "https://www.mysoftkey.com/java/difference-between-dom-and-sax-parser-in-java/"]}, "4708": {"text": "Dynamic instantiation method\nDynamic instantiation should be used only when necessary.\nDynamic instantiation is done through calls to:\n- 'java.lang.Class.newInstance()'\n- 'java.lang.reflect.Constructor.newInstance()' \n- 'java.lang.reflect.Array.newInstance(Class<?> ComponentType, int... dimensions)'\n- 'java.lang.reflect.Method.invoke(Object obj, Object... args)'\nmethods.\nAvoid using Dynamic Instantiation\nThis report lists all Artifacts using reflection API methods.\nIt provides the following information:\n - Artifacts full name\n - the method of the reflection API' that has been called\nDynamic instantiation is slower than a regular Class invocation or Method call\nhttps://docs.oracle.com/javase/tutorial/reflect/index.html\nYou should use class invocation or method call instead of dynamic instantiation\nSample1\npackage org.hsqldb;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n...\n\npublic class HsqlSocketFactory {\n\n    protected HsqlSocketFactory() throws Exception {}\n\n    public static HsqlSocketFactory getInstance(boolean tls)\n    throws Exception {\n        return tls ? getSSLImpl()\n                   : getPlainImpl();\n    }\n...\n----------------------------------------------------------------\nSample2\npackage com.tutorialspoint;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class MethodDemo {\n   public static void main(String[] args) \n      throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n\n      Method[] methods = SampleClass.class.getMethods();\n      SampleClass sampleObject = new SampleClass();\n      methods[1].invoke(sampleObject, \"data\");\n      System.out.println(methods[0].invoke(sampleObject));\n   }\n}\nNumber of Java artifacts", "urls": ["https://docs.oracle.com/javase/tutorial/reflect/index.html"]}, "7716": {"text": "Reports all JAVA singleton and factory classes for Spring based application \n\nA singleton is defined as:\n- a class with a static member with the same type as the class\n- a static method that refers the instance and return an object of same or a parent type\n(extended or implemented)\n- a class that has only private constructors\n\nA factory is defined as:\n- a class with a public static method that return a Java interface\n- a class that has only private or protected constructors\nAvoid defining singleton or factory classes when using Spring\nThe metric will list singleton or factories classes when Spring is used.\nIt provides the following information:\n  Class Full Name\nOn large software applications, the number of factory classes can become quite large. There is lot of code duplication because constructors are private and the usage of static methods and variables make the class not extendable. Thus very singleton must re-implement the same basic structure. \nSpring provides a core factory pattern, which eliminates the need to manually program factory objects (usually realized as singletons). It allows you to decouple the configuration and specification of dependencies from your actual program logic. You will remove the need of your own glue code and gain a much more robust factory implementation with better error handling and fully de-coupled configuration mechanism\n\nIt will also avoid to fall into the classic double-checked locking issue where you can easily have more than one singleton instance when invoked into a multi-threaded application.\nhttp://www.devx.com/Java/Article/21665/1763/page/2\nhttp://static.springframework.org/spring/docs/2.0.x/reference/beans.html#beans-factory-scopes-singleton\nPrefer using the core factory pattern provided by Spring to eliminate the need to manually program factory objects\n----> Spring XML file\n// FIXED with Spring\n<beans>\n     <bean name=\"theInterface\"\n          class=\"MyConcrete\">\n</beans>\n\n----> Java Client code\nInputStream is = new FileInputStream(\"spring_beans.xml\");\nBeanFactory factory = new XmlBeanFactory(is);\n\nMyInterface theInterface = (MyInterface) factory.getBean(\"theInterface\");\nString name = theInterface.getAName();\n\n------------------------------------------------------\n-----> Spring XML File\n<bean id=\"scopeTest\" class=\"com.example.scope.Scope\" scope=\"singleton\">\n        <property name=\"name\" value=\"Shamik Mitra\"/>    \n</bean> \n\n-----> Java File\n\n@Component\n@Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON)\npublic class TwitterMessageService implements MessageService {\n\n    private String message;\n\n    @Override\n    public String getMessage() {\n        return message;\n    }\n\n    @Override\n    public void setMessage(String message) {\n        this.message = message;\n    }\n}\n-----> MyInterface.java\ninterface MyInterface {\n  public String getAName();\n}\n-----> MyConcrete.java\nclass MyConcrete extends MyInterface {\n  public MyConcrete() {\n    ...\n  }\n  public String getAName() {\n    ...\n  }\n}\n-----> MyFactory.java\n// VIOLATION: the factory pattern is detected\nclass MyFactory {\n  private MyFactory() {\n    ...\n  }\n  public static MyInterface getMyInterface () {\n    ...\n  }\n}\n----> Java Client code\nMyInterface theInterface = MyFactory.getMyInterface ();\nString name = theInterface.getAName();\n\n----------------------------------------------\nclass Singleton \n{ \n    // static variable single_instance of type Singleton \n    private static Singleton single_instance = null; \n  \n    // variable of type String \n    public String s; \n  \n    // private constructor restricted to this class itself \n    private Singleton() //VIOLATION Detected\n    { \n        s = \"Hello I am a string part of Singleton class\"; \n    } \n  \n    // static method to create instance of Singleton class \n    public static Singleton getInstance() \\\\ //VIOLATION Detected\n    { \n        if (single_instance == null) \n            single_instance = new Singleton(); \n  \n        return single_instance; \n    } \n}\nNumber of Java singleton, factory and Spring beans when Spring is used", "urls": ["http://www.devx.com/Java/Article/21665/1763/page/2", "http://static.springframework.org/spring/docs/2.0.x/reference/beans.html#beans-factory-scopes-singleton"]}, "4722": {"text": "Database object used\nAll Classes should not have embedded SQL to the database. \nThis rule reports all Classes having direct access to a database object\nDEPRECATED: Avoid having classes referencing Database objects\nThis report lists all Classes having accesses to the database.\nIt provides the following information:\n - Class full name\n - Database object used\nThis rules permits to verify that only a specific set of classes are making access to the database and not all the application. Usually DAO classes are used to make access to the database.\nhttp://best-practice-software-engineering.ifs.tuwien.ac.at/patterns/dao.html\nhttps://www.oracle.com/java/technologies/dataaccessobject.html\nReview the architecture of the application to move all classes that reference the database in a specific layer usually called data layer.\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.function.Predicate;\n\npublic class ClassUsingDB_KO {\n    \n    private Connection connection;\n\n    boolean avoidSubqueries() {\n        Predicate<String> sql = x -> {\n            try {\n                    Statement statement = connection.createStatement();\n                    statement.executeQuery(\n                        \"select a.AU_FNAME from AUTHORS a where a.AU_ID in (select t.AU_ID from TITLEAUTHOR t)\");\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            return true;\n        };\n        return sql.test(\"xx\");\n    }\n\n}\nNumber of Java classes", "urls": ["http://best-practice-software-engineering.ifs.tuwien.ac.at/patterns/dao.html", "https://www.oracle.com/java/technologies/dataaccessobject.html"]}, "7292": {"text": "Cyclically called / inherited Package full name\nThis metric reports all packages that have one-on-one and more static circular dependencies.\nDependencies mean:\n - references through static methods call\n - references through class fields\n - references through inheritance\n\nNote that all these links are static link and not runtime.\nThe threshold parameter permit to define the maximal number of packages to cross for a cycle.\n\nNote that cycle notion means here a directed path in a graph that is directed by dependencies relations.\nAvoid cyclical calls and inheritances between packages\nThis report lists all packages with static cyclical call to or inheritance with another Java Package.\nIt provides the following information:\n  - Package full name\n  - cyclically called / inherited Package full name\nWhen two packages refer to each other through a call, the result is a circular dependency. Neither packages can function without the other, and so neither is reusable without the other. In some cases redesign may eliminate these dependencies.\nWhen circular references are necessary, redesign it to ensure reusability. The same problem happen when some classes from a package A inherit from classes of a package B and other classes from package B inherit from other classes from package A. This rule can be extended to circular dependencies for more than 2 packages (for example a package A call a package B that call a package C, that call package A).\nhttp://en.wikipedia.org/wiki/Circular_dependency\nhttps://wiki.sei.cmu.edu/confluence/display/java/DCL60-J.+Avoid+cyclic+dependencies+between+packages\nIf there are circular relationships among packages, the partitioning is not clear and should be redesigned. Use CAST Enlighten to see all dependencies to fix.\npackage bank;\npublic interface BankApplication {  \n  void depositFunds(BankApplication ba, String username, double amount);\n  double getBalance(String accountNumber);\n  double getUserBalance(String accountNumber);\n  boolean exists(String username);\n}\n \npackage account;\nimport bank.BankApplication;  // Import from a third package\nclass AccountHolder  {\n  private BankApplication ba;\n  public void setBankApplication(BankApplication newBA) {\n    ba = newBA;\n  }\n \n  public synchronized void depositFunds(BankApplication ba,\n      String username, double amount) {\n    // Use a utility method of UserDetails\n    // to check whether username exists\n    if (ba.exists(username)) {\n      // Deposit the amount\n    }\n  }\n  public double getBalance(String accountNumber) {\n    // Return the account balance\n    return 1.0;\n  }  \n}\n \npackage user;\nimport account.AccountHolder; // One-way dependency\nimport bank.BankApplication;  // Import from a third package\npublic class UserDetails extends AccountHolder\n      implements BankApplication {\n  public synchronized double getUserBalance(\n      String accountNumber) {\n    // Use a method of AccountHolder to get the account balance\n    return getBalance(accountNumber);\n  }\n  public boolean exists(String username) {\n    // Check whether user exists\n    return true;\n  }\n}\npackage account;\nimport user.User;\npublic class AccountHolder {\n \n  private User user;\n  public void setUser(User newUser) {user = newUser;}\n  \n  synchronized void depositFunds(String username, double amount) {\n    // Use a utility method of User to check whether username exists\n    if (user.exists(username)) {\n      // Deposit the amount\n    }\n  }\n \n  protected double getBalance(String accountNumber) {\n    // Return the account balance\n    return 1.0;\n  }\n}\n \npackage user;\nimport account.AccountHolder;\npublic class UserDetails extends AccountHolder {\n  public synchronized double getUserBalance(String accountNumber) {\n    // Use a method of AccountHolder to get the account balance\n    return getBalance(accountNumber);\n  }\n}\n  \npublic class User {\n    private AccountHolder acc;\n      public boolean exists(String username) {\n          if(username != \"\") {\n              acc = new AccountHolder();\n          }\n        // Check whether user exists\n        return true; // Exists\n      }\n    }\nTotal number of packages", "urls": ["http://en.wikipedia.org/wiki/Circular_dependency", "https://wiki.sei.cmu.edu/confluence/display/java/DCL60-J.+Avoid+cyclic+dependencies+between+packages"]}, "4610": {"text": "Reports all anonymous class except classes that implement a specific interface.  The threshold parameter permits to set the list of interfaces. This list is initialized with the interface java.util.EventListener (to exclude event listener in swing) and can be updated with other interfaces.\nAvoid using anonymous Classes\nThis report lists all Classes using anonymous Classes except those that are implementing a specific interface defined in the threshold parameter.\nIt provides the following information:\n Class full name\nFor maintenance reason, using anonymous Classes should be done only when necessary since it makes the application more difficult to understand and modify. There are some exception to this rule such as event listener in swing, the visitor pattern...\nNumber of classes", "urls": []}, "7434": {"text": "Number of violation occurrences\nAll Java objects are expected to obey a number of invariants related to equality. One of these invariants is that equal objects must have equal hashcodes.\nFor example, a class that is made persistent requires both hashCode() and equals() methods to be defined. This issue can prevent the software from running reliably, due to incorrect or unexpected comparison results. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.\n\nThis rule reports all classes that override\n- only boolean equals(Object) but not overriding hashCode()\nor \n- only int hashCode() but not overriding equals()\nEnsure to override both equals() and hashCode()\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nOften classes are used in HashMap to provide an efficient storage and retrieval. The Java platform architects anticipated the importance of hash-based collection classes -- such as Hashtable, HashMap, and HashSet -- in typical Java applications, and comparing against many objects with equals() can be computationally expensive.\nIf your java class is used or can be used in a hash-based collection, override both of these methods to avoid any issues that can be painful to find when the issue appear in production because the error is not in the code that is present, but in the code that is absent.\nhttps://www.geeksforgeeks.org/override-equalsobject-hashcode-method/\nhttps://howtodoinjava.com/java/basics/java-hashcode-equals-methods/\nAlways override hashCode() when overriding equals() method\nclass Example {\n   int id;\n\n   public int getId() {\n      return id;\n   }\n    public boolean equals(Object obj) {\n         return (obj instanceof Example\n            && id == ((Example) obj).getId());\n   }\n   public int hashCode() {  // FIXED\n       return id/10;\n   }\n}\nclass Example {\n   int id;\n\n   public int getId() {\n      return id;\n   }\n    public boolean equals(Object obj) {\n         return (obj instanceof Example\n            && id == ((Example) obj).getId());\n   }\n       // VIOLATION: missing hashCode()\n}\nNumber of classes that override equals() or (not exclusive) hashCode()", "urls": ["https://www.geeksforgeeks.org/override-equalsobject-hashcode-method/", "https://howtodoinjava.com/java/basics/java-hashcode-equals-methods/"]}, "4670": {"text": "Number of violation occurrences\nWhen enforcing the utilization of JavaDoc Comments to document an application, all Methods must have JavaDoc Comments. Those comments must be defined just before the declaration of the Method with the appropriate structure (/** */)\n\nThe Private Methods are not Considered bu this rule\nException: \n-  Methods that implement or override a method in an interface or superclass without adding any interesting behavior beyond what is already documented for the overridden method\n- Getters and Setters\n- Empty constructors\nPublic Methods must have JavaDoc comments\nThis report lists Methods not having JavaDoc comments.\nThis report provides the following information:\n Method full name\nThere is no dispute that these comments contribute to a developer's understanding and help a developer write reliable applications more quickly. Without documenting methods it is dififcult for anyone else than the author to guess the purpose of the method except by looking at the code and eventually the code called by this method.\nhttps://developer.atlassian.com/server/confluence/javadoc-standards/\nYou should add JavaDoc Comments for all  methods (Except Private Methods,getters and setters, Empty Constructors and Methods overriding another method) of the application.\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n    if(args.length == 0) {\n        throw new NoNameException();\n    } else {\n        return args[0];\n    }\n}\npublic static String classMethod(String[] args) throws NoNameException {  //Violation\n    if(args.length == 0) {\n        throw new NoNameException();\n    } else {\n        return args[0];\n    }\n}\nNumber of methods Excluding Priviate Methods", "urls": ["https://developer.atlassian.com/server/confluence/javadoc-standards/"]}, "4672": {"text": "Undocumented parameters\nThe \"@param\" tag should be followed by the parameter's name, and then a description of that parameter.The number of parameters should match the number of @param.\nPublic Methods must have appropriate JavaDoc @param tags\nThis report lists all Methods not having the appropriate @param JavaDoc comments.\nThis report provides the following information:\n - Method full name\n - Undocumented parameters\nThere is no dispute that these comments contribute to a developer's understanding and help a developer write reliable applications more quickly.\nWithout documenting parameters it is difficult for anyone else than the author to guess the purpose of the parameter except by looking at the code that is using it.\nWhen enforcing the use of JavaDoc Comments to document an application, the @param tags should be used to document the parameters of a given Method.\nhttps://www.oracle.com/technetwork/java/javase/documentation/index-137868.html#@param\nAdd a @param with a description for each method parameters.\n/**\n * @param  url  an absolute URL giving the base location of the image\n * @param  name the location of the image, relative to the url argument\n * @return      the image at the specified URL\n * @see         Image\n */\n public Image getImage(URL url, String name) {\n        try {\n            return getImage(new URL(url, name));\n        } catch (MalformedURLException e) {\n            return null;\n        }\n }\npublic Image getImage(URL url, String name) {   //Violation\n        try {\n            return getImage(new URL(url, name));\n        } catch (MalformedURLException e) {\n            return null;\n        }\n }\nNumber of java methods with at least one parameter", "urls": ["https://www.oracle.com/technetwork/java/javase/documentation/index-137868.html#@param"]}, "4674": {"text": "Number of violation occurrences\nWhen enforcing the utilization of JavaDoc Comments to document an application, the @return tags should be used to document the return type of a given Method.\nPublic Methods must have appropriate JavaDoc @return tags\nThis report lists all Methods not having the appropriate @return JavaDoc comments.\nThis report provides the following information:\n Method full name\nThere is no dispute that these comments contribute to a developer's understanding and help a developer write reliable applications more quickly. Without documenting returned value, it is dififcult for anyone else than the author to guess its purpose except by looking at the code that is using it.\nhttps://www.oracle.com/technetwork/java/javase/documentation/index-137868.html#@exception\nhttps://developer.atlassian.com/server/confluence/javadoc-standards/\nAdd @return tag for every method that returns something other than void\nRemediation Sample:\n------------------\n\npublic class AddNum {\n   /**\n   * This method is used to add two integers. This is\n   * a the simplest form of a class method, just to\n   * show the usage of various javadoc Tags.\n   * @param numA This is the first paramter to addNum method\n   * @param numB  This is the second parameter to addNum method\n   * @return int This returns sum of numA and numB.                //Fixed\n   */\n   public int addNum(int numA, int numB) {\n      return numA + numB;\n   }\n}\npublic class AddNum {\n   \n   public int addNum(int numA, int numB) {     //VIOLATION:No @return tag.\n      return numA + numB;\n   }\n\n   /**\n   * This is the main method which makes use of addNum method.\n   * @param args Unused.\n   * @exception IOException On input error.\n   * @see IOException\n   */\n\n   public static void main(String args[]) throws IOException {    //No Violation since the method is not returning anything.\n      AddNum obj = new AddNum();\n      int sum = obj.addNum(10, 20);\n\n      System.out.println(\"Sum of 10 and 20 is :\" + sum);\n   }\n}\nNumber of methods that return a value", "urls": ["https://www.oracle.com/technetwork/java/javase/documentation/index-137868.html#@exception", "https://developer.atlassian.com/server/confluence/javadoc-standards/"]}, "7728": {"text": "Number of violation occurrences\nThis rule reports violation for all methods that \ncall one of the following methods:\n  - <class full name>.start() where <class full name> inherit from java.lang.Thread\n  - java.lang.Thread.start()\nor reference one of the following interfaces or an implementation of these:\n  - java.util.concurrent.Executor\n  - java.util.concurrent.ExecutorService\n\nThis rule is applied only for EJB based application\nAvoid thread creation for application running on application server\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nOne of the reasons why an application server has been created is thread management that is complex to develop. It manages multiple threads for different types of components, and in order to effectively maximize performance and resource utilization, it requires control of the threads being run on a given machine.\n\nMore often than not, threads are created when there is no time to implement a better solution. However, the consequences can be serious in terms of performance and robustness. \n\nThe EJB specification prohibits applications from managing their own threads.\nThreads in the JVM are a limited resource that must be allocated thoughtfully. Your applications may break or cause poor Application Server performance when the server load increases. Problems such as deadlocks and thread starvation may not appear until the application is under a heavy load.\nAlso multithreaded modules are complex and difficult to debug. Interactions between application-generated threads and Application Server threads are especially difficult to anticipate and analyze.\nEJB specifications, https://www.oracle.com/java/technologies/restriction.html; J2EE Best Practices: Java Design Patterns, Automation, and Performance - 2002 page 439\nUse Message Driven Bean to send messages (through JMS) that will be consumed in parallel or implement JCA where the application server manages threads efficiently and can use thread pooling if necessary.\nclass BasicThread implements Runnable {\n        public void run() {\n            [...]\n        }\n}\n\nclass SimpleThread extends Thread {\n    public SimpleThread(String str) {\n       super(str);\n    }\n    public void run() {\n       [...]\n    }\n}\n\nclass ThreadLaunch {\n    public static void main (String args[]) {\n      Runnable runnable = new BasicThread();\n        new Thread(runnable).start(); // VIOLATION\n        new SimpleThread(\"Thread\").start(); // VIOLATION\n    }\n}\nNumber of Java methods and constructors present in the application that is being analyzed", "urls": ["https://www.oracle.com/java/technologies/restriction.html"]}, "7256": {"text": "Number of violation occurrences\nutility classes were not designed to be instantiated: an instance would be nonsensical. In the absence of explicit constructors, however, the compiler provides a public, parameterless default constructor. To a user, this constructor is indistinguishable from any other. It is not uncommon to see unintentionally instantiable classes in published APIs.\n\n\nUtility classes must have a private default constructor, but not other constructors. Default constructors are constructors without any parameters. Utility classes are static classes: all their fields and methods are static.\n\nExceptions\nWhen class contains public static void main(String[] args) method it is not considered as utility class and will be ignored by this rule.\nProvide a private default Constructor for utility Classes\nAssociated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code\nUtility classes are not meant to be instantiated because all the functionalities that they provide are accessible without instantiating the class. Instantiating these classes means that the developer has misused the class. It also consumes memory unnecessarily. Instead, providing a private default constructor ensures that the class is not instantiated.\nhttp://www.informit.com/articles/article.aspx?p=1216151&seqNum=4\nhttp://www.javapractices.com/Topic40.cjp\nAdd a private default constructor to ensure that the class cannot be instantiated.\npublic class MyClassUtility\n{\n      static public bool MyUtilityFunction() {\n            // Do Something Usefull \n            return true;\n      }\n\n      private MyUtilityClass() {  // FIXED\n            // Avoid instantiation of the class\n      }\n      static int UtilityCount;\n}\npublic class MyClassUtility\n{\n      static public bool MyUtilityFunction() {\n            // Do Something Usefull \n            return true;\n      }\n\n      static int UtilityCount;\n}  // VIOLATION\nNumber of utility classes (all their fields and methods are static)", "urls": ["http://www.informit.com/articles/article.aspx?p=1216151&seqNum=4", "http://www.javapractices.com/Topic40.cjp"]}}